code,test
"<template>   <component :is=""myComponent"" /> </template>  <script lang=""ts""> import WarningIcon from '@/Common/components/Icons/WarningIcon.vue' import LoadedIcon from '@/Common/components/Icons/LoadedIcon.vue' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue' import PendingIcon from '@/Common/components/Icons/PendingIcon.vue' import { defineComponent, computed } from 'vue' import { StateUpload } from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import FileIcon from '@/Common/components/Icons/FileIcon.vue'  export default defineComponent({   name: 'NattoUploadStateIcon',   props: {     statusIcon: {       type: Number,       required: true     }   },   components: {     WarningIcon,     LoadedIcon,     LoadingIcon,     PendingIcon   },   setup(props) {     const myComponent = computed(() => {       switch (props.statusIcon) {         case StateUpload.ERROR:           return WarningIcon         case StateUpload.CANCELED:           return WarningIcon         case StateUpload.UPLOADING:           return LoadingIcon         case StateUpload.UPLOADED:           return LoadedIcon         case StateUpload.PENDING:           return PendingIcon         default:           return FileIcon       }     })      return {       myComponent     }   } }) </script>","describe('NattoUploadStateIcon', () => {   describe('binding', () => {     it('Should display warning icon when state is canceled', () => {       const wrapper = createWrapper(StateUpload.CANCELED)       const NattoUploadStateIconWrapper: DOMWrapper<any> =         wrapper.find('.warning')        expect(NattoUploadStateIconWrapper.classes().length).toBeGreaterThan(0)     })     it('Should display warning icon when state is errored', () => {       const wrapper = createWrapper(StateUpload.ERROR)       const NattoUploadStateIconWrapper: DOMWrapper<any> =         wrapper.find('.warning')        expect(NattoUploadStateIconWrapper.classes().length).toBeGreaterThan(0)     })     it('Should display loading icon when state is loading', () => {       const wrapper = createWrapper(StateUpload.UPLOADING)       const NattoUploadStateIconWrapper: DOMWrapper<any> =         wrapper.find('.loader')        expect(NattoUploadStateIconWrapper.classes().length).toBeGreaterThan(0)     })      it('Should display loading icon when state is pending', () => {       const wrapper = createWrapper(StateUpload.PENDING)       const NattoUploadStateIconWrapper: DOMWrapper<any> =         wrapper.find('.pending')        expect(NattoUploadStateIconWrapper.classes().length).toBeGreaterThan(0)     })      it('Should display loaded icon when state is loaded', () => {       const wrapper = createWrapper(StateUpload.UPLOADED)       const NattoUploadStateIconWrapper: DOMWrapper<any> =         wrapper.find('.success')        expect(NattoUploadStateIconWrapper.classes().length).toBeGreaterThan(0)     })      it('Should display file icon when state is not set', () => {       const wrapper = createWrapper()       const fileIconWrapper = wrapper.findComponent(FileIcon)        expect(fileIconWrapper.exists()).toBe(true)     })   }) }) "
"<template>   <div class=""ged-card-content"">     <h1 class=""ged-card-content__title"">       {{ $t('ged.title') }}     </h1>     <no-access-box v-if=""hasDSInactive"" />     <template v-else>       <shortcuts :folders=""folders"" />       <natto-drop-zone :disabled=""isUploading"" @files-changes=""onFilesChange"">         <ged-card-upload-box           @click=""handleGedCardUploadBoxClick""           :is-uploading=""isUploading""         />       </natto-drop-zone>     </template>   </div> </template>  <script lang=""ts""> import { defineComponent, onMounted, computed } from 'vue' import Shortcuts from '@/Common/components/Home/Card/GedCardContent/Shortcuts/Shortcuts.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import NoAccessBox from '@/Common/components/Home/Card/GedCardContent/NoAccess/NoAccessBox.vue' import GedCardUploadBox from '@/Common/components/Home/Card/GedCardContent/UploadBox/GedCardUploadBox.vue' import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers' import NattoDropZone from '@/Common/components/Upload/NattoDropZone.vue' import FileUpload, {   StateUpload } from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'GedCardContent',   components: { NattoDropZone, GedCardUploadBox, Shortcuts, NoAccessBox },   setup() {     const store = useStore()     const { fetchFolders, folders } = useSearchStoreHelpers()     const { isUploading, setFiles } = useUploadStoreHelpers()     const { goToMainView } = useSearchNavigator()      onMounted(async () => {       await fetchFolders(store)     })      const handleGedCardUploadBoxClick = () => {       if (isUploading(store).value) {         return       }        goToMainView({ openSelectFilesWindow: true })     }      const onFilesChange = (files: File[]) => {       if (isUploading(store).value) {         return       }        setFiles(         store,         files.map((f: File) => new FileUpload(f, StateUpload.TO_UPLOAD))       )        goToMainView({ openWhoUploadModal: true })     }      return {       handleGedCardUploadBoxClick,       onFilesChange,       folders: folders(store),       isUploading: isUploading(store),       hasDSInactive: computed(         () =>           !folders(store).value.isLoading &&           !folders(store).value.collection.length       )     }   } }) </script>","describe('GedCardContent', () => {   beforeEach(() => {     wrapper = createWrapper()     shortcutsWrapper = findShortcuts(wrapper)     gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)     noAccessWrapper = findNoAccess(wrapper)     nattoDropZoneWrapper = findNattoDropZone(wrapper)   })    describe('rendering', () => {     expect(wrapper.text()).toContain('ged.title')   })   describe('bindings with Shortcut', () => {     describe('props bindings ', () => {       test('Shortcuts', async () => {         wrapper = createWrapper(           createSearchStoreMocked({ folders: useFoldersData().FoldersData })         )          shortcutsWrapper = findShortcuts(wrapper)          expect(shortcutsWrapper.props('folders')).toEqual(           useFoldersData().FoldersData         )       })       test('GedCardUploadBox', async () => {         wrapper = createWrapper(           createSearchStoreMocked({ folders: useFoldersData().FoldersData })         )          gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)          expect(gedCardUploadBoxWrapper.props('isUploading')).toBeFalsy()       })     })     describe('rendering', () => {       it('Should display no-access component and hide other components when there is no folder', () => {         wrapper = createWrapper()         noAccessWrapper = findNoAccess(wrapper)         expect(noAccessWrapper.exists()).toBeTruthy()         expect(shortcutsWrapper.exists()).toBeFalsy()         expect(gedCardUploadBoxWrapper.exists()).toBeFalsy()       })        it('Should display shortcuts and upload box components when there is some folders', () => {         wrapper = createWrapper(           createSearchStoreMocked({             folders: useFoldersData().FoldersData           })         )         noAccessWrapper = findNoAccess(wrapper)         shortcutsWrapper = findShortcuts(wrapper)         gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)         expect(noAccessWrapper.exists()).toBeFalsy()         expect(shortcutsWrapper.exists()).toBeTruthy()         expect(gedCardUploadBoxWrapper.exists()).toBeTruthy()       })     })   })   describe('bindings with GedCardUploadBox', () => {     test('props bindings', () => {       wrapper = createWrapper(         createSearchStoreMocked({           folders: useFoldersData().FoldersData         })       )       gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)        expect(gedCardUploadBoxWrapper.props('isUploading')).toBe(false)     })     describe('events', () => {       it('should NOT go to MainView when upload in progress', async () => {         const wrapper = createWrapper(           createFileStoreMock({             isUploading: true,             folders: useFoldersData().FoldersData           })         )          gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)          await gedCardUploadBoxWrapper.vm.$emit('click')         expect(router.push).toHaveBeenCalledTimes(0)       })       it('should go to MainView with windows explorer opened when no upload in progress', async () => {         const wrapper = createWrapper(           createFileStoreMock({             isUploading: false,             folders: useFoldersData().FoldersData           })         )          gedCardUploadBoxWrapper = findGedCardUploadBox(wrapper)          await gedCardUploadBoxWrapper.vm.$emit('click')          expect(router.push).toHaveBeenCalledWith({           name: 'MainView',           query: { openSelectFilesWindow: true }         })       })     })   })   describe('bindings with NattoDropZone', () => {     it('should dispatch setFiles action and go to Main view when NattoDropZone emit files-changes event', async () => {       const storeFileModule = createFileStoreMock()        storeFileModule.dispatch = jest.fn()       wrapper = createWrapper(storeFileModule)        const fileList: File[] = [         new File([''], 'File1'),         new File([''], 'File1')       ]        nattoDropZoneWrapper = findNattoDropZone(wrapper)       await nattoDropZoneWrapper.vm.$emit('files-changes', fileList)        expect(storeFileModule.dispatch).toHaveBeenCalledWith(         'GED/DataManipulation/Upload/setFiles',         [           {             destination: null,             errorDescription: {},             file: new File([''], 'File1'),             state: 0           },           {             destination: null,             errorDescription: {},             file: new File([''], 'File1'),             state: 0           }         ]       )        expect(router.push).toHaveBeenCalledWith({         name: 'MainView',         query: { openWhoUploadModal: true }       })     })   }) }) "
"<template>   <section class=""ged-card-upload-box"">     <upload-pictos :is-uploading=""isUploading"" />     <upload-texts :is-uploading=""isUploading"" />   </section> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import UploadTexts from '@/Common/components/Home/Card/GedCardContent/UploadBox/Texts/UploadTexts.vue' import UploadPictos from '@/Common/components/Home/Card/GedCardContent/UploadBox/Pictos/UploadPictos.vue'  export default defineComponent({   name: 'GedCardUploadBox',   components: { UploadPictos, UploadTexts },   props: {     isUploading: {       type: Boolean,       default: false     }   } }) </script>","describe('GedCardUploadBox', () => {   beforeEach(() => {     wrapper = createWrapper()     uploadTextsWrapper = findUploadTexts(wrapper)     uploadPictosWrapper = findUploadPictos(wrapper)   })    describe('bindings with UploadPictos', () => {     test('props bindings', () => {       expect(uploadPictosWrapper.props('isUploading')).toBe(true)     })   })   describe('bindings with UploadTexts', () => {     test('props bindings', () => {       expect(uploadTextsWrapper.props('isUploading')).toBe(true)     })   }) }) "
"<template>   <div class=""icon-box"">     <wait-picto v-if=""isUploading"" />     <upload-picto v-else />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import WaitPicto from '@/Common/components/Home/Card/GedCardContent/UploadBox/Pictos/WaitPicto.vue' import UploadPicto from '@/Common/components/Home/Card/GedCardContent/UploadBox/Pictos/UploadPicto.vue'  export default defineComponent({   name: 'UploadPictos',   components: { UploadPicto, WaitPicto },   props: {     isUploading: Boolean   } }) </script>","describe('UploadPictos', () => {   beforeEach(() => {     wrapper = createWrapper()     uploadPictoWrapper = findUploadPicto(wrapper)     waitPictoWrapper = findWaitPicto(wrapper)   })    describe('rendering', () => {     const cases = [       { isUploading: false, uploadPictoExists: true, waitPictoExists: false },       { isUploading: true, uploadPictoExists: false, waitPictoExists: true }     ]      test.each(cases)(       'should render UploadPicto when there is no upload in progress',       ({ isUploading, uploadPictoExists, waitPictoExists }) => {         wrapper = createWrapper({ isUploading })          uploadPictoWrapper = findUploadPicto(wrapper)         waitPictoWrapper = findWaitPicto(wrapper)          expect(uploadPictoWrapper.exists()).toBe(uploadPictoExists)         expect(waitPictoWrapper.exists()).toBe(waitPictoExists)       }     )   }) }) "
"<template>   <div class=""upload-texts"">     <span class=""upload-texts__title"">       {{ $t(boxInnerText.title) }}     </span>     <div class=""upload-texts__subtitle"">       {{         isUploading           ? $t(boxInnerText.subtitle)           : `${$t(boxInnerText.subtitle)} ${authorizedTypes}`       }}     </div>   </div> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import constants from '@/Common/constants'  export default defineComponent({   name: 'UploadTexts',    props: {     isUploading: Boolean   },    setup(props) {     const types = constants.allowedTypes      const authorizedTypes = computed(() =>       types.reduce((accumulator, currentValue) =>         accumulator.concat(', ', currentValue)       )     )      return {       authorizedTypes,       boxInnerText: computed(() => {         return !props.isUploading           ? {               title: 'ged.upload.default.title',               subtitle: 'ged.upload.default.subtitle'             }           : {               title: 'ged.upload.disabled.title',               subtitle: 'ged.upload.disabled.subtitle'             }       })     }   } }) </script>","describe('UploadTexts', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     const cases = [       {         isUploading: false,         title: 'ged.upload.default.title',         subtitle: 'ged.upload.default.subtitle Jpeg, Png, Pdf, Doc, Xls'       },       {         isUploading: true,         title: 'ged.upload.disabled.title',         subtitle: 'ged.upload.disabled'       }     ]      it.each(cases)(       'should display good title and subtitle when uploading',       ({ subtitle, title, isUploading }) => {         wrapper = createWrapper({ isUploading })          expect(wrapper.text()).toContain(title)         expect(wrapper.text()).toContain(subtitle)       }     )   }) }) "
"<template>   <div     v-loading=""folders.isLoading""     element-loading-background=""transparent""     class=""shortcuts-container""     :class=""{ loading: folders.isLoading }""   >     <shortcut       v-for=""folder in folders.collection""       :key=""folder.id""       :folder-name=""folder.name""       @click=""goToArboView({ folderId: folder.id })""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import Shortcut from '@/Common/components/Home/Card/GedCardContent/Shortcuts/Shortcut.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator.ts'  export default defineComponent({   name: 'Shortcuts',   components: { Shortcut },   props: {     folders: {       type: Folders,       required: true     }   },    setup() {     const { goToArboView } = useSearchNavigator()      return {       goToArboView     }   } }) </script>","describe('Shortcuts', () => {   beforeEach(() => {     wrapper = createWrapper()     shortcutWrappers = findShortcuts(wrapper)   })    describe('rendering', () => {     it('should have loading class when folders are loading', () => {       wrapper = createWrapper({ folders: Folders.loading() })        expect(wrapper.classes()).toContain('loading')     })   })   describe('bindings with Shortcut', () => {     test('props bindings', () => {       expect(shortcutWrappers).toHaveLength(5)       expect(shortcutWrappers[0].props('folderName')).toBe('A classer')     })     describe('events', () => {       it('should go to arbo view with correct folder id when click on shortcut', async () => {         await shortcutWrappers[0].vm.$emit('click')          expect(router.push).toHaveBeenCalledWith({           name: 'ArboView',           query: { folderId: 1122 }         })       })     })   }) }) "
"<template>   <natto-shortcut-card     class=""shortcut""     :text=""folderName""     prepend-icon=""documents""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoShortcutCard from '@/Common/components/Cards/NattoShortcutCard.vue'  export default defineComponent({   name: 'Shortcut',   components: { NattoShortcutCard },   props: {     folderName: {       type: String,       required: true     }   } }) </script>","describe('Shortcut', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoShortcutCardWrapper = findNattoShortcutCard(wrapper)   })    describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       expect(nattoShortcutCardWrapper.props('text')).toBe('test')       expect(nattoShortcutCardWrapper.props('prependIcon')).toBe('documents')     })   }) }) "
"<template>   <div v-if=""filePath"" :title=""filePath.join('/')"">     <span v-for=""(item, index) in formattedFilePath"" :key=""item"">       <span>         {{ item }}       </span>       <span         v-if=""index !== formattedFilePath.length - 1""         class=""el-icon-arrow-right""       />     </span>   </div> </template>  <script lang=""ts""> import { defineComponent, computed, PropType } from 'vue' export default defineComponent({   name: 'FilePathText',   props: {     filePath: {       type: Array as PropType<string[]>,       required: true     }   },   setup(props) {     const formattedFilePath = computed(() => {       if (!props.filePath) {         return []       }        return props.filePath.length < 6         ? props.filePath         : [props.filePath[0], '...', props.filePath[props.filePath.length - 1]]     })      return {       formattedFilePath     }   } }) </script>","describe('FilePathText', () => {   describe('binding', () => {     describe('props', () => {       it('Should not display anything when folders null(header case)', () => {         const wrapper = createWrapper()         const spanWrapper: DOMWrapper<HTMLSpanElement>[] =           wrapper.findAll('span')         expect(spanWrapper).toStrictEqual([])       })        it('Should display all folders when folders < 6', () => {         const wrapper = createWrapper({ filePath: ['A', 'B'] })         const divWrapper: DOMWrapper<any>[] = wrapper.findAll('div')         const spanWrapper: DOMWrapper<any>[] = wrapper.findAll('span')          expect(divWrapper[0].attributes('title')).toBe('A/B')         expect(spanWrapper[1].text()).toBe('A')         expect(spanWrapper[2].classes('el-icon-arrow-right')).toBeTruthy()         expect(spanWrapper[3].text()).toBe('B')       })        it('Should display first and last folder when folders > 6', () => {         const wrapper = createWrapper({           filePath: ['A', 'B', 'C', 'D', 'E', 'F', 'G']         })         const divWrapper: DOMWrapper<any>[] = wrapper.findAll('div')         const spanWrapper: DOMWrapper<any>[] = wrapper.findAll('span')          expect(divWrapper[0].attributes('title')).toBe('A/B/C/D/E/F/G')         expect(spanWrapper[1].text()).toBe('A')         expect(spanWrapper[2].classes('el-icon-arrow-right')).toBeTruthy()         expect(spanWrapper[4].text()).toBe('...')         expect(spanWrapper[5].classes('el-icon-arrow-right')).toBeTruthy()         expect(spanWrapper[7].text()).toBe('G')       })     })   }) }) "
"<template>   <span>{{ filenameFormatted }}</span> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import useStringHelpers from '@/Common/hooks/useStringHelpers' export default defineComponent({   name: 'FilenameText',   props: {     filename: {       type: String,       required: true     },     maxLength: {       type: [Number, String],       default: 45,       validator: (value: number) => value >= 45     }   },   setup(props) {     const { ellipsify } = useStringHelpers()      const filenameFormatted = computed(() =>       ellipsify(props.filename, Number(props.maxLength))     )      return {       filenameFormatted     }   } }) </script>","describe('FilenameText', () => {   describe('binding', () => {     describe('props', () => {       it('Should display filename formated when send filename props with length > 45', () => {         const wrapper = createWrapper(           'nomdefichiersuuuupeeeeeeeeeeeeeeeeeeeerlongggg!!.pdf'         )         const spanWrapper: DOMWrapper<any>[] = wrapper.findAll('span')          expect(spanWrapper.length).toBe(1)         expect(spanWrapper[0].text()).toBe('nomdefichiersuuuupee...gggg!!.pdf')       })        it('Should display filename formated when send filename props with length < 45', () => {         const wrapper = createWrapper('nomdefichier.pdf')         const spanWrapper: DOMWrapper<any>[] = wrapper.findAll('span')          expect(spanWrapper.length).toBe(1)         expect(spanWrapper[0].text()).toBe('nomdefichier.pdf')       })     })   }) }) "
"<template>   <iframe :src=""urlFile"" class=""natto-doc-viewer"" /> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue'  export default defineComponent({   name: 'NattoDocViewer',    props: {     file: {       type: Blob,       required: true     }   },    setup(props) {     const urlFile = computed(() => URL.createObjectURL(props.file))      return {       urlFile     }   } }) </script>","describe('NattoDocViewer', () => {   beforeEach(() => {     wrapper = createWrapper()     iFrameWrapper = findIframe(wrapper)   })    describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       expect(iFrameWrapper.attributes()).toStrictEqual({         class: 'natto-doc-viewer',         src: 'https://myObjectUrl.com'       })     })   }) }) "
"<template>   <el-tag :class=""$attrs.class"" class=""natto-tag"" :closable=""closable"">     <slot />   </el-tag> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoTag',    props: {     closable: Boolean   } }) </script>","describe('NattoTag', () => {   beforeEach(() => {     wrapper = createWrapper()     elTagWrapper = findElTag(wrapper)   })    describe('bindings with ElTag', () => {     test('props bindings', () => {       expect(elTagWrapper.attributes('closable')).toBe('false')     })     test('slot default rendering', () => {       wrapper = createWrapper({ defaultSlot: '<div>Columbo</div>' })        elTagWrapper = findElTag(wrapper)       expect(elTagWrapper.text()).toBe('Columbo')     })   }) }) "
"<template>   <el-badge class=""natto-badge"" :hidden=""value === 0"" :value=""value"">     <slot />   </el-badge> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoBadge',    props: {     value: {       type: Number,       required: true     }   } }) </script>","describe('NattoBadge', () => {   beforeEach(() => {     wrapper = createWrapper('<div>I fill the default slot</div>', 2)   })    describe('binding', () => {     it('props', () => {       const badgeWrapper: VueWrapper<any> = wrapper.findComponent(ElBadge)        expect(badgeWrapper.attributes('value')).toBe('2')     })   })    describe('rendering', () => {     it('should render the default slot', () => {       expect(wrapper.html()).toContain('I fill the default slot')     })   }) }) "
"<template>   <natto-tooltip :disabled=""!disabled"">     <el-dropdown-item       :disabled=""disabled""       :icon=""`el-icon-${icon}`""       @click=""handleItemClick""     >       {{ label }}     </el-dropdown-item>     <template #content>       {{ tooltipContent }}     </template>   </natto-tooltip> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoTooltip from '@/Common/components/Tooltips/NattoTooltip.vue'  export default defineComponent({   name: 'NattoDropdownItem',   components: { NattoTooltip },   props: {     icon: {       type: String,       default: ''     },     label: {       type: String,       required: true     },     disabled: Boolean,     tooltipContent: String   },    emits: ['click'],    setup(props, { emit }) {     return {       handleItemClick: () => {         emit('click')       }     }   } }) </script>","describe('NattoDropdownItem', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('bindings with ElDropdownItem', () => {     it('props <=> :props', () => {       wrapper = createWrapper({         icon: 'delete',         label: 'Supprimer',         disabled: false       })        const ElDropdownItemWrapper = findElDropdownItem(wrapper)        expect(ElDropdownItemWrapper.props('icon')).toBe('el-icon-delete')       expect(ElDropdownItemWrapper.props('disabled')).toBe(false)       expect(ElDropdownItemWrapper.text()).toContain('Supprimer')     })     describe('events', () => {       it('should emit click when ElDropdownItem is clicked', async () => {         const ElDropdownItemWrapper = findElDropdownItem(wrapper)          await ElDropdownItemWrapper.vm.$emit('click')          expect(wrapper.emitted('click')).toHaveLength(1)       })     })   }) }) "
"<template>   <ElRadioGroup>     <MpRadio       v-for=""radioItem in radioItems""       :key=""radioItem.value""       :label=""radioItem.value""     >       {{ radioItem.label }}     </MpRadio>   </ElRadioGroup> </template>  <script lang=""ts""> import { defineComponent, PropType } from 'vue'  export type RadioItem = {   value: boolean | string | number | Record<string, any>   label: string }  export default defineComponent({   name: 'NattoRadioGroup',    props: {     radioItems: {       type: Array as PropType<RadioItem[]>,       required: true     }   } }) </script>","describe('NattoRadioGroup', () => {   beforeEach(() => {     wrapper = createWrapper()     mpRadiosWrapper = findMpRadios(wrapper)   })    describe('bindings with ElRadio', () => {     test('props bindings', () => {       expect(mpRadiosWrapper[0].props()).toStrictEqual({ label: 1 })       expect(mpRadiosWrapper[1].props()).toStrictEqual({ label: 2 })       expect(mpRadiosWrapper[2].props()).toStrictEqual({ label: 3 })     })     it('should render labels', () => {       const text = wrapper.text()        expect(text).toContain('First Value')       expect(text).toContain('Second Value')       expect(text).toContain('Third Value')     })   }) }) "
"<template>   <mp-tabs     :tab-items=""items""     v-model=""activeName""     @tab-click=""handleClick""     :stretch=""stretch""   >     <template v-for=""item in items"" #[item.name]>       <slot :name=""item.name""></slot>     </template>   </mp-tabs> </template>  <script lang=""ts""> import { defineComponent, PropType, ref, watch } from 'vue' import { TabItem } from '@/Common/types/common' import _ from 'lodash'  export default defineComponent({   name: 'NattoTabs',   emits: ['tab-selected'],   props: {     items: {       type: Array as PropType<TabItem[]>,       required: true     },     stretch: Boolean   },    setup(props, { emit }) {     let activeName = ref(props.items[0].name)      watch(       () => _.cloneDeep(props.items),       (currentValue) => {         activeName.value = currentValue[0].name       }     )      return {       activeName,       handleClick: (tab: { props: { name: string } }) => {         emit('tab-selected', tab.props.name)       }     }   } }) </script>","describe('natto-tabs', () => {   beforeEach(() => {     wrapper = createWrapper(items)     mpTabsWrapper = wrapper.findComponent(MpTabs)   })   describe('bindings with MpTabs', () => {     it('props bindings', () => {       expect(mpTabsWrapper.props('tabItems')).toStrictEqual(items)     })      describe('events', () => {       it('Should emit tab-selected event on ElTabs click', async () => {         await mpTabsWrapper.vm.$emit('tab-click', selected)         expect(wrapper.emitted()['tab-selected'].length).toBe(1)         expect(wrapper.emitted()['tab-selected'][0]).toContain('1234')       })     })   }) }) "
"<template>   <p class=""warning-text"">     {{ errorMessage }}   </p> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoError',    props: {     errorMessage: String   } }) </script>","describe('NattoError', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     test('should render the error', () => {       wrapper = createWrapper({ errorMessage: 'error' })        expect(wrapper.text()).toContain('error')     })   }) }) "
"<template>   <mp-input     v-model=""input""     type=""text""     :placeholder=""placeholder""     :disabled=""disabled""     :clearable=""clearable""     class=""natto-input""     :class=""$attrs.class""     @input=""handleChange""   >     <template #prefix>       <slot name=""prefix"" />     </template>   </mp-input> </template>  <script lang=""ts""> import { defineComponent, ref, watch } from 'vue' import { debounce } from 'lodash'  export default defineComponent({   name: 'NattoInput',   props: {     placeholder: {       type: String,       default: 'Entrez du texte'     },     modelValue: {       type: String,       default: ''     },     disabled: Boolean,     clearable: Boolean,     debounceTime: {       type: Number,       default: 0     }   },    emits: ['update:modelValue'],    setup(props, { emit }) {     const input = ref(props.modelValue)      const debounceF = debounce((value: string) => {       emit('update:modelValue', value)     }, props.debounceTime)      const handleChange = (value: string) => {       if (props.debounceTime) {         debounceF(value)       } else {         emit('update:modelValue', value)       }     }      watch(       () => props.modelValue,       () => {         input.value = props.modelValue       }     )      return {       handleChange,       input     }   } }) </script>","describe('NattoInput', () => {   beforeEach(() => {     wrapper = createWrapper()     mpInputWrapper = findMpInput(wrapper)   })   describe('binding', () => {     it('should binds with the props', () => {       const wrapper = createWrapper({         modelValue: 'test',         placeholder: 'Ma recherche ici',         disabled: false,         clearable: true       })        const mpInputWrapper = findMpInput(wrapper)        expect(mpInputWrapper.props().modelValue).toBe('test')       expect(mpInputWrapper.attributes().placeholder).toBe('Ma recherche ici')       expect(mpInputWrapper.attributes().disabled).toBe('false')       expect(mpInputWrapper.attributes().clearable).toBe('true')     })     it('should reset model-value prop of ElInput when search changes', async () => {       // When search prop changes       await wrapper.setProps({ modelValue: 'gustave' })        // Then ElInput model-value prop must be gustave       expect(findMpInput(wrapper).props().modelValue).toBe('gustave')     })   })   describe('events', () => {     it('Should fire update:modelValue event when ElInput emit input', async () => {       await mpInputWrapper.vm.$emit('input')        expect(wrapper.emitted('update:modelValue')).toBeTruthy()     })     it('Should fire handleChange when input is fired from el input', async () => {       await mpInputWrapper.vm.$emit('input', 'test')        expect(wrapper.emitted()['update:modelValue'].length).toBe(1)       expect(wrapper.emitted()['update:modelValue'][0]).toStrictEqual(['test'])     })     it('Should emit update:modelValue when input is emitted from el input when debounce is NOT active', async () => {       wrapper = createWrapper({         modelValue: ''       })        mpInputWrapper = findMpInput(wrapper)       await mpInputWrapper.vm.$emit('input', 'test')       await flushPromises()        expect(wrapper.emitted()['update:modelValue'].length).toBe(1)       expect(wrapper.emitted()['update:modelValue']).toStrictEqual([['test']])     })     it('Should fire handleChange when input is fired from el input when debounce is active', async (done) => {       wrapper = createWrapper({         modelValue: '',         debounceTime: 1000       })        mpInputWrapper = findMpInput(wrapper)       await mpInputWrapper.vm.$emit('input', 'test')        setTimeout(() => {         expect(wrapper.emitted()['update:modelValue'].length).toBe(1)         expect(wrapper.emitted()['update:modelValue']).toStrictEqual([['test']])         done()       }, 1000)     })   }) }) "
"<template>   <el-select v-model=""selectedValue"">     <el-option       v-for=""item in options""       :key=""item.value""       :label=""item.label""       :value=""item.value""     >     </el-option>   </el-select> </template>  <script lang=""ts""> import useVModel from '@/Common/hooks' import { defineComponent, PropType } from 'vue' import SelectOption from '@/Common/models/Select/SelectOption'  export default defineComponent({   name: 'NattoSelect',   props: {     options: {       type: Array as PropType<SelectOption[]>     },     modelValue: [String, Number]   },   setup(props) {     const selectedValue = useVModel(props)      return {       selectedValue     }   } }) </script>","describe('NattoSelect', () => {   beforeEach(() => {     wrapper = createWrapper(1, [       new SelectOption('', undefined),       new SelectOption('l1', 1),       new SelectOption('l2', 2),       new SelectOption('l3', 3)     ])   })   describe('bindings', () => {     describe('props', () => {       it('Should send correctly props to ElSelect component - default case', () => {         const elSelectWrapper = wrapper.findComponent(ElSelect)          expect(elSelectWrapper.props('modelValue')).toBe(1)       })       it('Should send correctly props to ElSelect component - non default case', () => {         wrapper = createWrapper(1, [           new SelectOption('', undefined),           new SelectOption('l1', 1),           new SelectOption('l2', 2),           new SelectOption('l3', 3)         ])         const elSelectWrapper = wrapper.findComponent(ElSelect)          expect(elSelectWrapper.props('modelValue')).toBe(1)       })     })   })   describe('events', () => {     test('Switch of el select value should trigger an emit from NattoSelect', () => {       const elSelectWrapper = wrapper.findComponent(ElSelect)        elSelectWrapper.vm.$emit('update:modelValue', 2)        expect(wrapper.emitted('update:modelValue')).toEqual([[2]])       expect(wrapper.emitted('update:modelValue')).toBeTruthy()     })   }) }) "
"<template>   <natto-card class=""natto-shortcut-card"" :class=""type"">     <div class=""natto-shortcut-card__content"">       <div class=""natto-shortcut-card__prepend-icon"">         <mp-icon :name=""prependIcon"" />       </div>       <span         v-loading=""loading""         element-loading-background=""#fce4e9""         class=""natto-shortcut-card__text""         >{{ text }}       </span>       <arrow-right-icon class=""natto-shortcut-card__arrow-right"" />     </div>   </natto-card> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import ArrowRightIcon from '@/Common/components/Icons/ArrowRightIcon.vue' import NattoCard from '@/Common/components/Cards/NattoCard.vue'  export default defineComponent({   name: 'NattoShortcutCard',   components: { NattoCard, ArrowRightIcon },   props: {     text: String,     prependIcon: String,     loading: Boolean,     type: {       type: String,       validator: (type: string) =>         ['primary', 'secondary', 'danger'].includes(type),       default: 'primary'     }   } }) </script>","describe('NattoShortcutCard', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoCardWrapper = findNattoCard(wrapper)     mpIconWrapper = findMpIcon(wrapper)   })    describe('bindings with NattoCard', () => {     test('props bindings', () => {       expect(wrapper.text()).toContain('test')       expect(nattoCardWrapper.classes()).toContain('primary')       expect(mpIconWrapper.props('name')).toBe('delete')     })   }) }) "
"<template>   <MpInCard :class=""$attrs.class"">     <slot />   </MpInCard> </template>  <script> export default {   name: 'NattoCard' } </script>","describe('NattoCard', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('should render the default slot', () => {       wrapper = createWrapper('<div>Je suis le default slot</div>')        expect(wrapper.html()).toContain('Je suis le default slot')     })   }) }) "
"<template>   <div class=""natto-highlighter__container"">     <span       v-for=""(splittedItem, index) in textSplitted""       :key=""`splitted ${index}`""     >       <MpHighlight         v-if=""compareSplittedItemWithQuery(splittedItem)""         :text=""splittedItem""       />       <span v-else>{{ splittedItem }}</span>     </span>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useStringHelpers from '@/Common/hooks/useStringHelpers'  export default defineComponent({   name: 'NattoHighlighter',    props: {     text: {       type: String,       required: true     },     query: {       type: String,       required: true     }   },    setup(props) {     const { splitter, sanitize } = useStringHelpers()      const textSplitted = splitter(props.text, props.query)      const compareSplittedItemWithQuery = (splittedItem: string): boolean =>       sanitize(splittedItem) === sanitize(props.query)      return {       textSplitted,       compareSplittedItemWithQuery     }   } }) </script>","describe('NattoHighlighter', () => {   beforeEach(() => {     wrapper = createWrapper()     mpHighlightWrapper = findMpHighlight(wrapper)   })    describe('rendering', () => {     it('should contain 2 children when the text is ""je suis columbo"" (2 parts [je suis, columbo])', () => {       expect(wrapper.findAll('.natto-highlighter__container > *')).toHaveLength(         2       )     })     it('should render the text without the query', () => {       expect(wrapper.text()).toContain('je suis')       expect(wrapper.text()).not.toContain('columbo')     })   })   describe('bindings with MpHighlight', () => {     describe('rendering', () => {       it('should render MpHighlight only once because the query ""columbo"" appear one time in the text', () => {         expect(wrapper.findAllComponents(MpHighlight)).toHaveLength(1)       })       it('should not render any MpHighlight component when the query does not match any part of the text', () => {         wrapper = createWrapper({ text: 'je suis columbo', query: 'peter' })         expect(findMpHighlight(wrapper).exists()).toBe(false)       })     })     test('props bindings', () => {       expect(mpHighlightWrapper.attributes('text')).toBe('columbo')     })   }) }) "
"<template>   <el-date-picker     class=""natto-date-picker""     v-model=""selectedDate""     type=""date""     :placeholder=""placeholder""     :disabled-date=""disabledDate""     :default-time=""defaultTime""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useVModel from '@/Common/hooks' import useDates from '@/Common/hooks/useDates'  export default defineComponent({   name: 'NattoDatePicker',   props: {     placeholder: String,     lockafter: [Date, String],     lockbefore: [Date, String],     modelValue: String,     defaultTime: [Date, String]   },   setup(props) {     const { isBefore, isAfter } = useDates()      const selectedDate = useVModel(props)     const disabledDate = function (time: Date) {       let disabled = false        if (props.lockafter) {         disabled = isAfter(time.toString(), props.lockafter.toString())       }        if (props.lockbefore) {         disabled =           disabled || isBefore(time.toString(), props.lockbefore.toString())       }        return disabled     }      return { selectedDate, disabledDate }   } }) </script>","describe('NattoDatePicker', () => {   beforeEach(() => {     wrapper = createWrapper(       new Date(1998, 5, 15, 10, 33, 30, 0),       'placehold1',       new Date(1998, 0, 1, 10, 33, 30, 0),       new Date(1999, 11, 31, 10, 33, 30, 0)     )   })   describe('bindings', () => {     describe('props', () => {       it('Should send correctly props to ElDatePicker component', () => {         const elDatePicker: VueWrapper<any> =           wrapper.findComponent(ElDatePicker)          expect(elDatePicker.props('placeholder')).toBe('placehold1')         expect(elDatePicker.props('modelValue')).toStrictEqual(           new Date(1998, 5, 15, 10, 33, 30, 0)         )         expect(elDatePicker.props('defaultTime')).toBeUndefined()       })       it('disable date should return false for each date not inside the before and after props date period', () => {         const elDatePicker: VueWrapper<any> =           wrapper.findComponent(ElDatePicker)          expect(           elDatePicker.props('disabledDate')(new Date(1997, 10, 23))         ).toBeTruthy()         expect(           elDatePicker.props('disabledDate')(new Date(2000, 0, 1))         ).toBeTruthy()         expect(           elDatePicker.props('disabledDate')(             new Date(1998, 1, 12, 10, 33, 30, 0)           )         ).toBeFalsy()       })       it('lockerafter and lockbefore can be undefined', () => {         wrapper = createWrapper(           new Date(1998, 5, 15, 10, 33, 30, 0),           'placehold1'         )          const elDatePicker: VueWrapper<any> =           wrapper.findComponent(ElDatePicker)          expect(elDatePicker.props('lockafter')).toBeUndefined()         expect(elDatePicker.props('lockbefore')).toBeUndefined()         expect(           elDatePicker.props('disabledDate')(             new Date(1998, 1, 12, 10, 33, 30, 0)           )         ).toBeFalsy()       })     })   }) }) "
"<template>   <span> {{ formattedDate }} </span> </template>  <script> import { computed, defineComponent } from 'vue' import useDates from '@/Common/hooks/useDates'  export default defineComponent({   name: 'NattoDate',    props: {     date: {       type: String,       required: true     },     format: {       type: String,       default: 'DD MMMM YYYY'     }   },    setup(props) {     const { format } = useDates()     const formattedDate = computed(() => format(props.date, props.format))      return {       formattedDate     }   } }) </script>","describe('NattoDate', () => {   describe('rendering', () => {     it('should render the date formatted', () => {       wrapper = createWrapper({         date: '2019-01-19T10:00:00+00:00',         format: 'DD MMMM YYYY'       })        expect(wrapper.html()).toContain('19 janvier 2019')     })   }) }) "
"<template>   <mp-pagination     :page-size=""pageSize""     :current-page=""pageNumber""     :page-count=""pageCount""     hide-on-single-page     :total=""itemsTotal""     @current-change=""pageChanged""   /> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue'  export default defineComponent({   name: 'NattoPagination',   props: {     pageNumber: {       type: Number,       required: true     },     itemsTotal: {       type: Number,       required: true     },     pageSize: {       type: Number,       required: true     }   },   emits: ['page-opened'],   setup(props, { emit }) {     return {       pageCount: computed(() => Math.ceil(props.itemsTotal / props.pageSize)),       pageChanged(pageNumber: number) {         emit('page-opened', pageNumber)       }     }   } }) </script>","describe('NattoPagination', () => {   beforeEach(() => {     wrapper = createWrapper(100, 10, 10)   })   describe('bindings', () => {     describe('props', () => {       it('Should send correctly props to MpPagination', () => {         const mpPaginationWrapper = wrapper.findComponent(MpPagination)          expect(mpPaginationWrapper.attributes('page-size')).toBe('10')         expect(mpPaginationWrapper.attributes('total')).toBe('100')         expect(mpPaginationWrapper.attributes('page-count')).toBe('10')         expect(mpPaginationWrapper.attributes('current-page')).toBe('10')       })     })   })   describe('events', () => {     test('Paging should trigger an page-opened event when MpPagination emits a current-change event', () => {       const mpPaginationWrapper = wrapper.findComponent(MpPagination)        mpPaginationWrapper.vm.$emit('current-change', 3)        expect(wrapper.emitted('page-opened')).toEqual([[3]])       expect(wrapper.emitted('page-opened')).toBeTruthy()     })   }) }) "
"<template>   <natto-dialog v-model=""isOpened"" @close=""$emit('on-modal-close')"">     <div class=""modal-two-columns"" :class=""{ noPadding }"">       <div class=""modal-header"">         <slot name=""modal-header"">[Header]</slot>       </div>       <div class=""modal-subheader"">         <slot name=""modal-subheader"">[Subheader]</slot>       </div>       <div class=""modal-leftpanel-title modal-panel-title"">         <slot name=""modal-leftpanel-title"">[Left title]</slot>       </div>       <div class=""modal-leftpanel-content"">         <slot name=""modal-leftpanel-content"">[Left content]</slot>       </div>       <div class=""modal-rightpanel-title modal-panel-title"">         <slot name=""modal-rightpanel-title"">[Right title]</slot>       </div>       <div class=""modal-rightpanel-content"">         <slot name=""modal-rightpanel-content"">[Right content]</slot>       </div>       <div class=""actions"">         <slot name=""actions"">[Actions]</slot>       </div>     </div>   </natto-dialog> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useVModel from '@/Common/hooks' import NattoDialog from '@/Common/components/Modals/NattoDialog.vue'  export default defineComponent({   name: 'ModalTwoColumns',   components: { NattoDialog },   props: {     modelValue: Boolean,     noPadding: {       type: Boolean,       default: true     }   },   setup(props) {     const isOpened = useVModel(props)      return {       isOpened     }   } }) </script>","describe('ModalTwoColumns', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('bindings', () => {     describe('props', () => {       it('Should pass modelValue props without changes', () => {         // Construct a component with a value different than default false         wrapper = createWrapper(true)          // Check if ElDialog prop modelValue is true         expect(findNattoDialog(wrapper).props().modelValue).toBe(true)       })     })   })   describe('rendering', () => {     describe('noPadding prop', () => {       it('modal should not had any padding', () => {         const wrappper = createWrapper(true, true)          const divSectionModal: DOMWrapper<HTMLDivElement> =           wrappper.find('.modal-two-columns')          expect(divSectionModal.classes('noPadding')).toBeTruthy()       })       it('modal should had a default padding', () => {         const wrappper = createWrapper(false)          const divSectionModal: DOMWrapper<HTMLDivElement> =           wrappper.find('.modal-two-columns')          expect(divSectionModal.classes('noPadding')).toBeFalsy()       })     })   })   describe('events', () => {     test('ModalTwoColumns should trigger an update:modelValue event when ElDialog emits an update:modelValue event', () => {       // When ElDialog emit an update:modelValue event (ModalTwoColumns <= ElDialog)       const ElDialogWrapper = findNattoDialog(wrapper)        ElDialogWrapper.vm.$emit('update:modelValue', true)        // Then ModalTwoColumns should trigger an update:modelValue with same payload       expect(wrapper.emitted('update:modelValue')).toEqual([[true]])       expect(wrapper.emitted('update:modelValue')).toBeTruthy()     })     it('ModalTwoColumns should trigger an on-modal-close event when ElDialog emits an close event', () => {       // When ElDialog emit an update:modelValue event (ModalTwoColumns <= ElDialog)       const ElDialogWrapper = findNattoDialog(wrapper)        ElDialogWrapper.vm.$emit('close')        // Then ModalTwoColumns should trigger an update:modelValue with same payload       expect(wrapper.emitted('on-modal-close')).toBeTruthy()     })   }) }) "
"<template>   <natto-dialog     v-model=""isOpened""     @close=""handleClose""     custom-class=""natto-type-popup-container""     title=""Avant d'allez plus loin...""   >     <div class=""modal-content-container"">       <p class=""question"">         Dans quel répertoire souhaitez-vous déposer vos fichiers ?       </p>       <div class=""folders"">         <div           v-for=""folder in folders.collection""           :key=""folder.id""           class=""folder-item""           :class=""selectedDefaultFolderId === folder.id ? 'selected' : ''""           @click=""folderItemClick(folder)""         >           <div class=""folder-icon-container"">             <div :class=""`folder-icon ${categoryCode(folder.name)}`""></div>           </div>           <div class=""folder-name"">{{ folder.name }}</div>         </div>       </div>     </div>     <template #footer>       <span class=""dialog-footer"">         <el-button class=""client-cta n-btn nbtn-blue"" @click=""treatByClient""           >Je veux trier mes fichiers moi-même</el-button         >         <el-button           class=""collab-cta n-btn""           :class=""enableCollabCTA ? 'nbtn-complete' : 'nbtn-grey'""           @click=""treatByCollab""           >Je laisse mon collaborateur KPMG trier mes fichiers</el-button         >       </span>     </template>   </natto-dialog> </template>  <script lang=""ts""> import { defineComponent, ref, computed } from 'vue' import useVModel from '@/Common/hooks' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import NattoDialog from '@/Common/components/Modals/NattoDialog.vue'  export default defineComponent({   name: 'NattoUploadTypePopup',   components: { NattoDialog },   props: {     modelValue: { type: Boolean, default: false },     folders: {       type: Folders,       required: true     }   },   emits: [     'on-treat-by-client',     'on-treat-by-collab',     'popup-folder-select-close'   ],   setup(props, { emit }) {     const isOpened = useVModel(props)      const selectedDefaultFolderId = ref(0)      const categoryCode = (folderName: string) => {       return folderName.includes('Comptabilité')         ? 'compta'         : folderName.includes('Gestion Sociale')         ? 'gs'         : ''     }      const folderItemClick = (folder: Folder) => {       if (folder.properties?.tracingName) {         trackEventFactory(           analyticsCode['updm-select-tree-folder'],           folder.properties.tracingName         )       }       selectedDefaultFolderId.value = folder.id ?? 0     }      const treatByClient = () => {       emit('on-treat-by-client', selectedDefaultFolderId.value)       selectedDefaultFolderId.value = 0     }      const treatByCollab = () => {       if (selectedDefaultFolderId.value !== 0) {         emit('on-treat-by-collab', selectedDefaultFolderId.value)       }     }      const handleClose = () => {       selectedDefaultFolderId.value = 0       emit('popup-folder-select-close')     }      const enableCollabCTA = computed(() => {       return (         selectedDefaultFolderId.value !== 0 &&         props.folders &&         props.folders.getDefaultUploadFolderById(selectedDefaultFolderId.value)           ?.id       )     })      return {       enableCollabCTA,       isOpened,       categoryCode,       folderItemClick,       treatByClient,       treatByCollab,       handleClose,       selectedDefaultFolderId     }   } }) </script>","describe('NattoUploadTypePopup', () => {   describe('binding', () => {     beforeEach(() => {       foldersData = Folders.loaded([         {           id: 1122,           name: 'Comptabilité',           parent: { id: 0 },           children: [],           properties: { tracingName: 'Accounting' },           permissions: []         },         {           id: 1233,           name: 'Gestion Sociale',           parent: { id: 0 },           children: [],           properties: {},           permissions: []         }       ])       wrapper = createWrapper(foldersData, true)       jest.clearAllMocks()     })     describe('props', () => {       it('Should bind correctly the folders prop', () => {         expect(wrapper.props('folders').collection).toHaveLength(2)       })       it('Should bind correctly the modelValue prop', () => {         expect(wrapper.props('modelValue')).toBe(true)       })     })     describe('rendering', () => {       it('Should disable Collab CTA when there is no default folders', () => {         foldersData.getDefaultUploadFolderById = () => undefined         wrapper = createWrapper(foldersData, true)         const collabCtaWrapper = wrapper.find('.collab-cta')          expect(collabCtaWrapper.classes('nbtn-grey')).toBe(true)       })     })     describe('events', () => {       it('Should emit on-treat-by-client on nbtn-blue click ', async () => {         const folderWrapper: DOMWrapper<any>[] = wrapper.findAll('.folder-item')          expect(folderWrapper.length).toBe(2)         await folderWrapper[0].trigger('click')          const ElDialogWrapper = wrapper.findComponent(NattoDialog)         const bntnBlueWrapper = ElDialogWrapper.findAllComponents(ElButton)[0]          await bntnBlueWrapper.trigger('click')          expect(wrapper.emitted('on-treat-by-client')).toBeTruthy()         expect(wrapper.emitted()['on-treat-by-client'][0]).toHaveLength(1)         expect(wrapper.emitted()['on-treat-by-client'][0]).toContain(1122)       })       it('Should not emit on-treat-by-collab on nbtn-grey click ', async () => {         const ElDialogWrapper = wrapper.findComponent(NattoDialog)         const bntnBlueWrapper = ElDialogWrapper.findAllComponents(ElButton)[1]          await bntnBlueWrapper.trigger('click')          expect(wrapper.emitted('on-treat-by-collab')).toBeFalsy()       })       it('Should emit on-treat-by-collab on nbtn-complete click ', async () => {         const ElDialogWrapper = wrapper.findComponent(NattoDialog)         const bntnBlueWrapper = ElDialogWrapper.findAllComponents(ElButton)[1]          const folderWrapper: DOMWrapper<any>[] = wrapper.findAll('.folder-item')          expect(folderWrapper.length).toBe(2)         await folderWrapper[0].trigger('click')          await bntnBlueWrapper.trigger('click')          expect(wrapper.emitted('on-treat-by-collab')).toBeTruthy()         expect(wrapper.emitted()['on-treat-by-collab'][0]).toHaveLength(1)         expect(wrapper.emitted()['on-treat-by-collab'][0]).toContain(1122)       })       it('Should emit popup-folder-select-close on modal close event', async () => {         const ElDialogWrapper = wrapper.findComponent(NattoDialog)          await ElDialogWrapper.vm.$emit('close')         expect(wrapper.emitted('popup-folder-select-close')).toBeTruthy()       })        it('Should change classes on click folder event', async () => {         const folderWrapper: DOMWrapper<any>[] = wrapper.findAll('.folder-item')          expect(folderWrapper.length).toBe(2)          expect(folderWrapper[0].classes()).toHaveLength(1)         expect(folderWrapper[0].classes()[0]).toStrictEqual('folder-item')         expect(folderWrapper[1].classes()).toHaveLength(1)         expect(folderWrapper[1].classes()[0]).toStrictEqual('folder-item')          await folderWrapper[0].trigger('click')          expect(folderWrapper[0].classes()).toHaveLength(2)         expect(folderWrapper[0].classes()[0]).toStrictEqual('folder-item')         expect(folderWrapper[0].classes()[1]).toStrictEqual('selected')         expect(folderWrapper[1].classes()).toHaveLength(1)         expect(folderWrapper[1].classes()[0]).toStrictEqual('folder-item')       })        it('should emit tracking event on click on folder', async () => {         const folderWrappers = findFolders(wrapper)          const firstFolder = folderWrappers[0]          await firstFolder.trigger('click')          expect(trackEventFactory).toHaveBeenCalledWith(           'updm-select-tree-folder',           'Accounting'         )       })     })   }) }) "
"<template>   <el-dialog     v-model=""isOpened""     :close-on-click-modal=""!loading""     :close-on-press-escape=""!loading""     :show-close=""!loading""     @close=""clickHandle('cancel')""     append-to-body     custom-class=""natto-dialog-container""   >     <template #title class=""natto-dialog-title"">       <span :class=""'title-' + popupType"">{{ title }}</span>     </template>      <p class=""description"">{{ description }}</p>     <template #footer class=""natto-dialog-footer"">       <el-button         :loading=""loading""         class=""btn btn-cancel""         @click=""clickHandle('cancel')""         >Annuler</el-button       >        <el-button         :loading=""loading""         :class=""'btn btn-' + popupType""         @click=""clickHandle('confirm')""         >Continuer</el-button       >     </template>     <natto-collapse-transition>       <span class=""error-message"" v-if=""errorMessage"">{{ errorMessage }}</span>     </natto-collapse-transition>   </el-dialog> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useVModel from '@/Common/hooks' import NattoCollapseTransition from '@/Common/components/Transitions/NattoCollapseTransition.vue'  export default defineComponent({   name: 'NattoDialogPopup',   components: { NattoCollapseTransition },   props: {     modelValue: Boolean,     title: {       type: String,       required: true     },     description: {       type: String,       required: true     },     popupType: {       type: String,       required: true,       validator(value: string) {         return ['error'].includes(value)       }     },     loading: {       type: Boolean     },     errorMessage: String   },   emits: ['confirm-clicked', 'cancel-clicked'],   setup(props, { emit }) {     const isOpened = useVModel(props)      const clickHandle = (type: string) => {       const eventType = (type + '-clicked') as         | 'confirm-clicked'         | 'cancel-clicked'        emit(eventType)     }      return {       clickHandle,       isOpened     }   } }) </script>","describe('NattoDialogPopup', () => {   describe('bindings with ElDialog', () => {     it('should bind props correctly', () => {       wrapper = createWrapper(         true,         'Hello World !',         ""i'am a big description"",         'error',         true       )        const elDialogWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(ElDialog)        expect(elDialogWrapper.attributes('close-on-click-modal')).toBe('false')       expect(elDialogWrapper.attributes('close-on-press-escape')).toBe('false')       expect(elDialogWrapper.attributes('show-close')).toBe('false')     })   })   describe('bindings with ElButton', () => {     it('should bind props correctly', () => {       wrapper = createWrapper(         true,         'Hello World !',         ""i'am a big description"",         'error',         true       )        const elButtonWrappers: VueWrapper<ComponentPublicInstance>[] =         wrapper.findAllComponents(ElButton)        expect(elButtonWrappers[0].attributes('loading')).toBe('true')       expect(elButtonWrappers[1].attributes('loading')).toBe('true')     })   })   describe('bindings', () => {     describe('events', () => {       it(""Should fire 'confirm-clicked' when confirm button is clicked"", () => {         wrapper = createWrapper(           true,           'Hello World !',           ""i'am a big description"",           'error'         )          const elButtonWrappers: VueWrapper<any>[] =           wrapper.findAllComponents(ElButton)          elButtonWrappers[1].trigger('click')         expect(wrapper.emitted('confirm-clicked')).toBeTruthy()         expect(wrapper.emitted('confirm-clicked')).toHaveLength(1)       })        it(""Should fire 'cancel-clicked' when cancel button is clicked"", () => {         wrapper = createWrapper(           true,           'Hello World !',           ""i'am a big description"",           'error'         )          const elButtonWrappers: VueWrapper<any>[] =           wrapper.findAllComponents(ElButton)          elButtonWrappers[0].trigger('click')         expect(wrapper.emitted('cancel-clicked')).toBeTruthy()         expect(wrapper.emitted('cancel-clicked')).toHaveLength(1)       })        it(""Should fire 'cancel-clicked' when user click outside"", () => {         wrapper = createWrapper(           true,           'Hello World !',           ""i'am a big description"",           'error'         )          const elDialogWrapper: VueWrapper<any> = wrapper.findComponent(ElDialog)          elDialogWrapper.trigger('close')         expect(wrapper.emitted('cancel-clicked')).toBeTruthy()         expect(wrapper.emitted('cancel-clicked')).toHaveLength(1)       })     })   })   describe('rendering', () => {     describe('props', () => {       it('Should add error class and display title and descriptions when props are sent.', () => {         wrapper = createWrapper(           true,           'Hello World !',           ""i'am a big description"",           'error'         )          const elButtonWrappers: VueWrapper<any>[] =           wrapper.findAllComponents(ElButton)          expect(elButtonWrappers.length).toBe(2)         expect(elButtonWrappers[0].text()).toBe('Annuler')         expect(elButtonWrappers[1].text()).toBe('Continuer')         expect(elButtonWrappers[1].classes('btn-error')).toBeTruthy()          const pWrappers: DOMWrapper<any> = wrapper.find('p')          expect(pWrappers.text()).toBe(""i'am a big description"")          const spanWrappers: DOMWrapper<any> = wrapper.find('span')          expect(spanWrappers.classes('title-error')).toBeTruthy()         expect(spanWrappers.text()).toBe('Hello World !')       })     })   })   describe('events', () => {}) }) "
"<template>   <modal-two-columns v-model=""isOpened"">     <template #modal-header>       <div class=""header-container"">         <div class=""main-section"">           <p class=""main-text"">             <span class=""highlighted"">De nouveaux</span>             fichiers vont être déposés           </p>         </div>       </div>     </template>     <template #modal-subheader>       <div class=""info-section"">         <p>           Il vous est possible de choisir votre dossier de destination et ainsi           rendre votre GED plus harmonieuse         </p>       </div>     </template>     <template #modal-leftpanel-title>Vos fichiers</template>     <template #modal-leftpanel-content>       <upload-file-list         :files=""files""         :selectedFileIndex=""selectedFileIndex""         @display-file=""$emit('display-file', $event)""       />     </template>     <template #modal-rightpanel-title>       <span         v-if=""files[selectedFileIndex ? selectedFileIndex : 0]?.error()""         class=""fileSelectedError""       >         {{ $t('ged.upload.uploadModal.error') }}</span       >       <span         class=""fileSelectedError""         v-else-if=""files[selectedFileIndex ? selectedFileIndex : 0]?.canceled()""       >         {{ $t('ged.upload.uploadModal.cancelError') }}       </span>       <span v-else> {{ $t('ged.upload.uploadModal.success') }} </span>     </template>     <template #modal-rightpanel-content>       <div class=""right-content-container"">         <upload-file-infos           :triggerUploadAllFiles=""triggerUploadAllFiles""           :selected-folder-to-upload=""selectedFolderToUpload""           :disabledCategories=""disableCategoryChange""           :file=""files[selectedFileIndex]""           :canUpload=""canUpload""           @update:selectedFolderToUpload=""             $emit('change-selected-folderId', $event)           ""         />       </div>     </template>     <template #actions>       <div class=""actions-container"">         <div class=""secondary-cta-action"">           <secondary-cta-button             v-show=""displaySecondaryButton""             :folderName=""secondaryCtaFolderName""             @click=""$emit('secondary-click')""           />         </div>         <document-primary-cta           :disabled=""disablePrimaryButton""           :action=""primaryCtaAction""           @close=""$emit('on-modal-close')""           @validate=""$emit('validate')""         />       </div>     </template>   </modal-two-columns> </template>  <script lang=""ts""> import { defineComponent, PropType, computed } from 'vue' import ModalTwoColumns from '@/Common/components/Modals/ModalTwoColumns.vue' import DocumentPrimaryCta from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Content/Buttons/DocumentPrimaryCta.vue' import SecondaryCtaButton from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Content/Buttons/SecondaryCtaButton.vue' import UploadFileList from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Content/UploadFileList.vue' import UploadFileInfos from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Content/UploadFileInfos.vue' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import useVModel from '@/Common/hooks' import { useStore } from 'vuex' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers'  export default defineComponent({   name: 'NattoUploadModal',   components: {     ModalTwoColumns,     DocumentPrimaryCta,     SecondaryCtaButton,     UploadFileList,     UploadFileInfos   },   props: {     selectedFileIndex: Number,     primaryCtaAction: String,     secondaryCtaFolderName: {       type: String,       default: ''     },     files: {       type: Array as PropType<FileUpload[]>,       required: true     },     modelValue: {       type: Boolean,       default: false     },     selectedFolderToUpload: Number,     disabledCategories: Boolean,     triggerUploadAllFiles: {       type: Boolean,       default: false     }   },   emits: [     'display-file',     'category-selected',     'validate',     'on-modal-close',     'secondary-click',     'change-selected-folderId'   ],   setup(props) {     const store = useStore()      const { folders } = useSearchStoreHelpers()     const { hasPermissionToUploadFile } = useUploadStoreHelpers()     const isOpened = useVModel(props)      let canUpload = computed(() =>       hasPermissionToUploadFile(store, props.selectedFolderToUpload ?? 0)     )      return {       folders: folders(store),       disableCategoryChange: computed(         () =>           props.disabledCategories ||           !props.files[props.selectedFileIndex ?? 0]?.ready()       ),       displaySecondaryButton: computed(() => {         if (canUpload.value) {           return (             props.secondaryCtaFolderName.length > 0 &&             props.files[props.selectedFileIndex ?? 0]?.ready()           )         }          return false       }),       disablePrimaryButton: computed(() => {         if (canUpload.value) {           if (props.selectedFolderToUpload === 0) {             return true           } else if (             (props.primaryCtaAction === 'finish' &&               !props.files.some((f: FileUpload) => f?.ready())) ||             (props.primaryCtaAction !== 'finish' &&               props.files[props.selectedFileIndex ?? 0]?.ready())           ) {             return false           } else {             return true           }         }          return true       }),       isOpened,       canUpload     }   } }) </script>","describe('natto-upload-modal', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('props', () => {       describe('modal-two-columns', () => {         it('should pass modelValue props', () => {           const ModalTwoColumnsWrapper: VueWrapper<any> =             wrapper.findComponent(ModalTwoColumns)            expect(ModalTwoColumnsWrapper.props('modelValue')).toBe(true)         })       })       describe('upload-file-list', () => {         it('shoud pass files props', () => {           const uploadFileListWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileList)            expect(uploadFileListWrapper.props('files')).toStrictEqual(filesMock)         })         it('shoud pass selectedFileIndex props', () => {           const uploadFileListWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileList)            expect(uploadFileListWrapper.props('selectedFileIndex')).toBe(1)         })       })       describe('upload-file-infos', () => {         it('should pass selectedFolderToUpload props', () => {           const uploadFileinfosWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileInfos)            expect(uploadFileinfosWrapper.props('selectedFolderToUpload')).toBe(             1234           )         })         it('should pass disabledCategories props', () => {           const uploadFileinfosWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileInfos)            expect(uploadFileinfosWrapper.props('disabledCategories')).toBe(false)         })          it('should pass file props', () => {           const uploadFileinfosWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileInfos)            expect(uploadFileinfosWrapper.props('file')).toStrictEqual(             filesMock[1]           )         })          describe('events', () => {           it('should emit update:selectedFolderToUpload when UpdateFileInfos emits update:selectedFolderToUpload', async () => {             const uploadFileInfosWrapper: UploadFileInfoTypeWrapper =               wrapper.findComponent(UploadFileInfos)              await uploadFileInfosWrapper.vm.$emit(               'update:selectedFolderToUpload',               27             )              expect(wrapper.emitted('change-selected-folderId')).toBeTruthy()             expect(wrapper.emitted('change-selected-folderId')).toStrictEqual([               [27]             ])           })         })       })       describe('secondary-cta-button', () => {         it('should pass folderName props', () => {           const secondaryCtaButtonWrapper: VueWrapper<any> =             wrapper.findComponent(SecondaryCtaButton)            expect(secondaryCtaButtonWrapper.props('folderName')).toBe('Achats')         })         it('should pass vshow props', () => {           wrapper = createWrapper({             secondaryCtaFolderName: ''           })            const secondaryCtaButtonWrapper: VueWrapper<any> =             wrapper.findComponent(SecondaryCtaButton)            expect(             (secondaryCtaButtonWrapper.element as HTMLElement).style.display           ).toBe('none')         })       })       describe('document-primary-cta', () => {         it('should pass disabled props', () => {           wrapper = createWrapper(             {},             createFileStoreMock({ hasPermissionToUploadFile: false })           )            const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })         it('should pass action props', () => {           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('action')).toBe('validateNext')         })          it('Should be disabled when selected file upload is UPLOADING and cta action validateNext', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.UPLOADING             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.UPLOADING             )           ]            const wrapper = createWrapper({             files: filesMock,             selectedFolderToUpload: 123           })           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })         it('Should be disabled when selected file upload is UPLOADED and cta action validateNext', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.UPLOADED             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.UPLOADING             )           ]            const wrapper = createWrapper({             files: filesMock           })           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })          it('Should be disabled when selected file upload is ERROR and cta action validateNext', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.ERROR             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.UPLOADING             )           ]            const wrapper = createWrapper({             files: filesMock           })           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })         it('Should be disabled when selected file upload is PENDING and cta action validateNext', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.PENDING             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.UPLOADING             )           ]            const wrapper = createWrapper({             files: filesMock           })           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })         it('Should be disabled when there is not an upload file permission', () => {           const wrapper = createWrapper(             {},             createFileStoreMock({ hasPermissionToUploadFile: false })           )           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(true)         })         it('Should not be disabled when there is  an upload file permission', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             )           ]            const updatedFolderData = foldersData.collection[0]            updatedFolderData.permissions.push(             constants.CAN_UPLOAD_FILES as PermissionsNames           )           const wrapper = createWrapper({             selectedFolderToUpload: 123,             files: filesMock           })           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(false)         })         it('Should not be disabled when selected file upload is TO_UPLOAD and cta action validateNext', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.UPLOADING             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.UPLOADING             )           ]            foldersData.collection[0].permissions.push(             constants.CAN_UPLOAD_FILES as PermissionsNames           )           const wrapper = createWrapper(             {               selectedFileIndex: 0,               files: filesMock             },             createFileStoreMock({ hasPermissionToUploadFile: true })           )           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(false)         })         it('Should not be disabled when cta action is finish and all files upload are finish', () => {           const filesMock = [             new FileUpload(               new File([''], 'file1.txt', { type: 'text/html' }),               StateUpload.UPLOADED             ),             new FileUpload(               new File([''], 'file2.txt', { type: 'text/html' }),               StateUpload.UPLOADING             ),             new FileUpload(               new File([''], 'file3.txt', { type: 'text/html' }),               StateUpload.ERROR             )           ]            const wrapper = createWrapper(             {               primaryCtaAction: 'finish',               files: filesMock             },             createFileStoreMock({ hasPermissionToUploadFile: true })           )           const documentPrimaryCtaWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentPrimaryCta)            expect(documentPrimaryCtaWrapper.props('disabled')).toBe(false)         })       })     })     describe('events', () => {       describe('upload-file-list', () => {         it('Should trigger display-file when upload-file-list fire display-file event', () => {           const uploadFileListWrapper: VueWrapper<any> =             wrapper.findComponent(UploadFileList)            uploadFileListWrapper.vm.$emit('display-file', 9)            expect(wrapper.emitted('display-file')).toBeTruthy()           expect(wrapper.emitted('display-file')).toStrictEqual([[9]])         })       })        it('Should trigger on-modal-close when document-primary-cta fire close event', () => {         const documentPrimaryCtaWrapper: VueWrapper<any> =           wrapper.findComponent(DocumentPrimaryCta)          documentPrimaryCtaWrapper.vm.$emit('close')          expect(wrapper.emitted('on-modal-close')).toBeTruthy()       })       it('Should trigger validate when document-primary-cta fire validate event', () => {         const documentPrimaryCtaWrapper: VueWrapper<any> =           wrapper.findComponent(DocumentPrimaryCta)          documentPrimaryCtaWrapper.vm.$emit('validate')          expect(wrapper.emitted('validate')).toBeTruthy()       })     })   }) }) "
"<template>   <div class=""breadcrumb-container"">     <MpBreadcrumb       :breadcrumb-items=""breadcrumbs""       :ellipsed=""ellipsed""       @breadcrumb-click=""breadcrumbClicked""     />   </div> </template>  <script lang=""ts""> import { defineComponent, PropType } from 'vue' import { BreadcrumbItem } from '@/Common/types/common' import useBreadcrumbHelpers from '@/Common/hooks/useBreadcrumbHelpers'  export default defineComponent({   name: 'NattoBreadcrumb',   props: {     breadcrumbs: {       type: Array as PropType<BreadcrumbItem[]>,       required: true     },     disabledBreadcrumbs: Boolean,     ellipsed: Boolean   },   emits: ['breadcrumb-click'],    setup(props) {     const { handleClickOnBreadcrumb } = useBreadcrumbHelpers()      const breadcrumbClicked = (id: number) => {       if (props.disabledBreadcrumbs) {         return       }        handleClickOnBreadcrumb({ id, breadcrumbs: props.breadcrumbs })     }      return {       breadcrumbClicked     }   } }) </script>","describe('NattoBreadcrumb', () => {   describe('bindings with MpBreadcrumb', () => {     describe('props', () => {       const wrapper = createWrapper()       const mpBreadcrumbWrapper = findMpBreadcrumbWrapper(wrapper)        expect(mpBreadcrumbWrapper.props('breadcrumbItems')).toStrictEqual([         { id: 1, text: 'Compta' },         { id: 2, text: 'Achats' },         { id: 3, text: 'Janvier' }       ])       expect(mpBreadcrumbWrapper.props('ellipsed')).toStrictEqual(false)     })     describe('events', () => {       it('Should not fire event breadcrumb-click when disabled', async () => {         const wrapper = createWrapper({           ...defaultProps,           disabledBreadcrumbs: true         })         const mpBreadcrumbWrapper = findMpBreadcrumbWrapper(wrapper)          await mpBreadcrumbWrapper.vm.$emit('breadcrumb-click')          expect(wrapper.emitted()['breadcrumb-click']).toStrictEqual(undefined)       })     })   }) }) "
"<template>   <el-tooltip     :disabled=""disabled""     :placement=""placement""     :content=""content""     effect=""dark""     :visible-arrow=""false""   >     <slot />     <template v-if=""!content"" #content>       <slot name=""content"" />     </template>   </el-tooltip> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoTooltip',    emits: ['click'],    props: {     disabled: Boolean,     placement: {       type: String,       default: 'left'     },     content: String   } }) </script>","describe('NattoTooltip', () => {   beforeEach(() => {     wrapper = createWrapper()     elTooltipWrapper = findElTooltip(wrapper)   })   describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       expect(elTooltipWrapper.attributes('disabled')).toBe('false')       expect(elTooltipWrapper.attributes('placement')).toBe('right')       expect(elTooltipWrapper.attributes('content')).toBe('columbo')     })      describe('rendering', () => {       it('should render the default slot', () => {         wrapper = createWrapper({           defaultSlot: '<div>columbo</div>'         })          expect(wrapper.text()).toContain('columbo')       })       it('should not render the content slot if the content prop is set', () => {         wrapper = createWrapper({           props: {             content: 'test'           },           contentSlot: 'je ne dois pas apparaitre'         })          expect(wrapper.text()).not.toContain('je ne dois pas apparaitre')       })       it('should render the content slot if the content prop is not set', () => {         wrapper = createWrapper({           props: {             content: ''           },           contentSlot: 'je dois apparaitre'         })          expect(wrapper.text()).toContain('je dois apparaitre')       })     })   }) }) "
"<template>   <MpTitle class=""natto-header"">     <template #subHeader>       <slot name=""subHeader"" />     </template>     <template #default>       <slot name=""cta"" />     </template>   </MpTitle> </template>  <script> import { defineComponent } from 'vue' export default defineComponent({   name: 'NattoHeader' }) </script>","describe('NattoHeader', () => {   describe('rendering', () => {     it('should fill the slots', () => {       console.log(wrapper.text())       expect(wrapper.text()).toContain('Je suis le subHeader')       expect(wrapper.text()).toContain('Je suis les CTAs')     })   }) }) "
"<template>   <div :class=""$attrs.class"" class=""natto-upload-box-container"">     <div class=""upload-box-main"">       <natto-drop-zone :disabled=""disabled"" @files-changes=""onFilesChange"">         <div           class=""upload-box-inner""           @click=""!disabled ? $refs.uploadInput.click() : false""         >           <input             type=""file""             ref=""uploadInput""             class=""uploadInput""             style=""display: none""             @change=""handleDragZoneClick""             multiple           />           <div class=""upload-box-icon-zone"">             <upload-box-icon v-if=""!disabled"" />             <wait-icon v-else />           </div>           <div class=""upload-box-content-zone"">             <div class=""title"">{{ boxInnerText.mainText.text }}</div>             <div class=""subText"">{{ boxInnerText.subText }}</div>           </div>         </div>       </natto-drop-zone>     </div>   </div> </template>  <script lang=""ts""> import UploadBoxIcon from '@/Common/components/Icons/UploadBoxIcon.vue' import WaitIcon from '@/Common/components/Icons/WaitIcon.vue' import NattoDropZone from '@/Common/components/Upload/NattoDropZone.vue' import { computed, defineComponent, PropType, ref } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'NattoUploadBox',   components: { UploadBoxIcon, WaitIcon, NattoDropZone },   emits: ['on-files-change'],   props: {     supportedTypes: {       type: Array as PropType<string[]>,       required: true     },     disabled: {       type: Boolean,       default: false     }   },   setup(props, { emit }) {     const { tc } = useTranslation()     const uploadInput = ref(null as any)     const authorizedTypes = computed(() =>       props.supportedTypes.reduce((accumulator, currentValue) =>         accumulator.concat(', ', currentValue)       )     )     const onFilesChange = (files: File[]) => {       emit('on-files-change', files)       if (uploadInput.value?.value) {         uploadInput.value.value = ''       }     }      return {       uploadInput,       onFilesChange: (data: File[]) => {         onFilesChange(data)       },       handleDragZoneClick: (event: any) => {         onFilesChange(Array.from(event.target.files))       },       boxInnerText: computed(() => {         return !props.disabled           ? {               mainText: {                 text: tc('ged.dataManipulation.upload.box.uploadBox.title')               },               subText:                 tc('ged.dataManipulation.upload.box.uploadBox.subText') +                 authorizedTypes.value             }           : {               mainText: {                 text: tc(                   'ged.dataManipulation.upload.box.uploadBox.disabled.title'                 )               },               subText: tc(                 'ged.dataManipulation.upload.box.uploadBox.disabled.subtitle'               )             }       }),       authorizedTypes     }   } }) </script>","describe('NattoUploadBox', () => {   beforeEach(() => {     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })     wrapper = createWrapper()     NattoDropZoneWrapper = wrapper.findComponent(NattoDropZone)   })   describe('binding', () => {     describe('props', () => {       const cases = [         {           prop: 'supportedTypes',           expectedValue: ['ext1', 'ext2']         },         {           prop: 'disabled',           expectedValue: false         }       ]        test.each(cases)('Test binding own props', ({ prop, expectedValue }) => {         expect(wrapper.props(prop)).toEqual(expectedValue)       })       describe('NattoDropZone', () => {         const cases = [           {             prop: 'disabled',             expectedValue: false           }         ]          test.each(cases)(           'Test binding with NattoDropZone',           ({ prop, expectedValue }) => {             expect(NattoDropZoneWrapper.props(prop)).toEqual(expectedValue)           }         )       })     })     describe('events', () => {       describe('NattoUploadBox', () => {         it('Should emit on-files-change on files-changes', async () => {           NattoDropZoneWrapper.vm.$emit('files-changes', [             new File([''], 'File 1')           ])           expect(wrapper.emitted('on-files-change')).toHaveLength(1)           expect(wrapper.emitted('on-files-change')).toEqual([             [[new File([''], 'File 1')]]           ])         })       })       describe('input', () => {         it('Should emit on-files-change when change event fired one or multiple time', async () => {           const InputFileWrapper = wrapper.find('.uploadInput')            InputFileWrapper.trigger('change')           expect(wrapper.emitted('on-files-change')).toHaveLength(1)           InputFileWrapper.trigger('change')           expect(wrapper.emitted('on-files-change')).toHaveLength(2)         })       })     })     describe('rendering', () => {       describe('enabled state', () => {         it('Should have the proper ui specs: Icon', () => {           const NattoUploadBoxWrapper = wrapper.findComponent(UploadBoxIcon)            expect(NattoUploadBoxWrapper.exists()).toBeTruthy()         })       })       describe('disabled state', () => {         it('Should have the proper ui specs: Icon', () => {           wrapper = createWrapper({             supportedTypes: ['ext1', 'ext2'],             disabled: true           })           const NattoUploadBoxWrapper = wrapper.findComponent(WaitIcon)            expect(NattoUploadBoxWrapper.exists()).toBeTruthy()         })       })     })   }) }) "
"<template>   <div class=""upload-dropdown-container"">     <div class=""upload-btn"" @click=""showModal = !showModal"">       <div class=""upload-icon""></div>     </div>     <div class=""upload-btn-dropdown"" v-show=""showModal"">       <el-row>         <el-col :span=""24"">           <div class=""dropdown-footer"">             <natto-upload-btn               :isDrag=""false""               :targetInput=""'.dropdown-upload-btn input[type=file]'""               :wrapperClassName=""'dropdown-upload-btn'""               :disabled=""disabled""               @on-files-change=""onFilesChange""             >               <template #content>                 <mp-button                   size=""small""                   btn-type=""primary""                   :class=""disabled ? 'disabled-btn' : ''""                   >{{ dropdownButtonText }}</mp-button                 ></template               >               <template #buttonSubText>                 {{ dropdownFooterText }}               </template>             </natto-upload-btn>           </div></el-col         >       </el-row>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoUploadBtn from '@/Common/components/Upload/Buttons/NattoUploadBtn.vue' import { ref } from 'vue'  export default defineComponent({   name: 'NattoUploadDropDown',   components: { NattoUploadBtn },   emits: ['on-files-change'],   props: {     dropdownFooterText: {       type: String,       default: 'ou pouvez déposer directement dans la fenétre'     },     dropdownButtonText: {       type: String,       default: 'Ajouter depuis mon ordinateur'     },     disabled: {       type: Boolean,       default: false     },     closeDropDown: Boolean   },   setup(props, { emit }) {     const showModal = ref(false)      return {       showModal,       onFilesChange: (data: File[]) => {         showModal.value = false         emit('on-files-change', data)       }     }   } }) </script>","describe('natto-upload-dropdown', () => {   describe('events', () => {     it('Should emit on-change-files event on NattoUploadBtn click', async () => {       const wrapper = createWrapper()       const NattoUploadBtnWrapper = wrapper.findComponent(NattoUploadBtn)       await NattoUploadBtnWrapper.vm.$emit('on-files-change')       expect(wrapper.emitted('on-files-change')).toBeTruthy()     })   })   describe('binding', () => {     it('isDrag shoud be false', () => {       const wrapper = createWrapper()       const NattoUploadBtnWrapper: VueWrapper<any> =         wrapper.findComponent(NattoUploadBtn)        expect(NattoUploadBtnWrapper.vm.isDrag).toEqual(false)     })     it('target input should be .natto-upload-box input[type=file]', () => {       const wrapper = createWrapper()       const NattoUploadBtnWrapper: VueWrapper<any> =         wrapper.findComponent(NattoUploadBtn)        expect(NattoUploadBtnWrapper.vm.targetInput).toEqual(         '.dropdown-upload-btn input[type=file]'       )     })   }) }) "
"<template>   <div class=""natto-upload-files-btn-container"" v-if=""showUploadBtn"">     <natto-upload-btn       :isDrag=""false""       targetInput="".dropdown-upload-btn input[type=file]""       wrapperClassName=""dropdown-upload-btn""       :disabled=""btnDisabled""       @on-files-change=""onFilesChange""     >       <template #content>         <MpButton size=""small"" type=""primary"" :disabled=""btnDisabled"">           <natto-icon :elementName=""icon"" />           <span class=""btn-text"">{{ buttoninnerText }}</span>         </MpButton>       </template>     </natto-upload-btn>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import NattoIcon from '@/Common/components/Icons/NattoIcon.vue' import NattoUploadBtn from '@/Common/components/Upload/Buttons/NattoUploadBtn.vue'  export default defineComponent({   name: 'NattoUploadFilesBtn',   components: { NattoUploadBtn, NattoIcon },   emits: ['on-files-change'],   props: {     icon: {       type: String,       default: 'plus'     },     buttoninnerText: {       type: String,       default: 'Ajouter des documents'     },     disabled: {       type: Boolean,       default: false     },     canUploadFiles: Boolean,     hasAccessDs: Boolean,     isMainViewBtn: {       type: Boolean,       default: false     }   },   setup(props, { emit }) {     const btnDisabled = computed(() => {       return props.isMainViewBtn         ? props.disabled         : props.disabled || !props.canUploadFiles || !props.hasAccessDs     })      return {       btnDisabled,       showUploadBtn: computed(() => {         if (props.isMainViewBtn) {           return props.hasAccessDs         }          return true       }),       onFilesChange: (data: File[]) => {         if (btnDisabled.value == false) {           emit('on-files-change', data)         }       }     }   } }) </script>","describe('NattoUploadFilesBtn', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     it('Should pass prop disabled correctly to natto-upload-btn', () => {       const NattoUploadBtnWrapper = wrapper.findComponent(NattoUploadBtn)        expect(wrapper.props('disabled')).toBe(         NattoUploadBtnWrapper.props('disabled')       )     })   })   describe('rendring', () => {     it('Should display the correct button text', () => {       const NattoUploadBtnWrapper = wrapper.findComponent(NattoUploadBtn)       const innerText = NattoUploadBtnWrapper.find('.btn-text')        expect(innerText.text()).toBe(wrapper.props('buttoninnerText'))     })     describe('In arbo view', () => {       const disabledCases = [         {           disabled: true,           canUploadFiles: true,           hasAccessDs: true,           isMainViewBtn: false,           expectedValue: true         },         {           disabled: false,           canUploadFiles: false,           hasAccessDs: true,           isMainViewBtn: false,           expectedValue: true         },         {           disabled: false,           canUploadFiles: true,           hasAccessDs: false,           isMainViewBtn: false,           expectedValue: true         }       ]        test.each(disabledCases)(         'disabled cases',         ({           disabled,           canUploadFiles,           hasAccessDs,           isMainViewBtn,           expectedValue         }) => {           // Given props are set           wrapper = createWrapper({             icon: 'icon-value',             buttoninnerText: 'btn inner text',             disabled,             canUploadFiles,             hasAccessDs,             isMainViewBtn           })           const btnWrapper = wrapper.findComponent(MpButton)            expect(btnWrapper.props('disabled')).toBe(expectedValue)         }       )     })     it('Should be hidden when hasAccessDs is false', () => {       wrapper = createWrapper({         icon: 'icon-value',         buttoninnerText: 'btn inner text',         disabled: false,         canUploadFiles: true,         hasAccessDs: false,         isMainViewBtn: true       })       const NattoUploadBtnWrapper = wrapper.findComponent(NattoUploadBtn)        expect(NattoUploadBtnWrapper.exists()).toBe(false)     })   })   describe('events', () => {     it('should emit on-files-change on natto-upload-btn files change event', async () => {       const NattoUploadBtnWrapper = await wrapper.findComponent(NattoUploadBtn)        NattoUploadBtnWrapper.vm.$emit('on-files-change')        expect(wrapper.emitted('on-files-change')).toBeTruthy()     })   }) }) "
"<template>   <el-upload     action=""""     :drag=""isDrag""     :class=""wrapperClassName""     :http-request=""emitFilesEvent""     :on-change=""change""     :file-list=""fileList""     :show-file-list=""false""     :disabled=""disabled""     multiple   >     <slot name=""content""></slot>     <div class=""el-upload__text"">       <slot name=""buttonSubText""></slot>     </div>   </el-upload> </template>  <script> import { defineComponent } from 'vue' import uploadMixin from '@/Common/mixins/natto-upload'  export default defineComponent({   name: 'NattoUploadBtn',   mixins: [uploadMixin],   emits: ['on-files-change'],   props: {     isDrag: {       type: Boolean,       required: true     },     targetInput: {       type: String,       required: true     },     wrapperClassName: {       type: String     },     disabled: {       type: Boolean,       default: false     }   },   mounted() {     this.className = this.targetInput   } }) </script>","describe('natto-upload-btn', () => {   describe('binding', () => {     it('shoud have the same httpRequest property', () => {       const wrapper = createWrapper()       const ElUploadWrapper: VueWrapper<any> = wrapper.findComponent(ElUpload)        expect(ElUploadWrapper.vm.httpRequest).toBe(wrapper.vm.emitFilesEvent)     })     it('shoud have the same fileList property', () => {       const wrapper = createWrapper()       const ElUploadWrapper: VueWrapper<any> = wrapper.findComponent(ElUpload)        expect(ElUploadWrapper.vm.fileList).toBe(wrapper.vm.fileList)     })     it('shoud have showFileList as false', () => {       const wrapper = createWrapper()       const ElUploadWrapper: VueWrapper<any> = wrapper.findComponent(ElUpload)        expect(ElUploadWrapper.vm.showFileList).toEqual(false)     })   }) }) "
"<template>   <div     v-for=""item in folders""     :key=""item.id""     :class=""$attrs.class""     class=""folder-item-container""   >     <div       :class=""disabled ? 'folder-item-disabled' : ''""       class=""folderItem""       @click=""handleClick(item.id)""     >       <div class=""item-content"">         <div class=""item-content__name__icon""><folder-icon /></div>         <div class=""item-content__name__text"">{{ item.name }}</div>         <div class=""item-content__actions"">           <slot name=""actions"" :folder=""item"" />         </div>       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, PropType, ref, watch } from 'vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import useArrayHelpers from '@/Common/hooks/useArrayHelpers' import FolderIcon from '@/Common/components/Icons/FolderIcon.vue'  export default defineComponent({   name: 'NattoFoldersBrowser',   components: { FolderIcon },   props: {     folders: {       type: Array as PropType<Folder[]>,       required: true     },     height: {       type: Number,       default: 160     },     disabled: Boolean   },   emits: ['browser-folder-selected'],   setup(props, { emit }) {     const { sortArrayByAlphabeticalOrder } = useArrayHelpers()      const foldersAlphabeticallySorted = ref(       sortArrayByAlphabeticalOrder(props.folders, 'name')     )      const handleClick = (folderId: number) => {       emit('browser-folder-selected', folderId)     }      watch(       () => props.folders,       () => {         foldersAlphabeticallySorted.value = sortArrayByAlphabeticalOrder(           props.folders,           'name'         )       }     )      return {       handleClick,       foldersAlphabeticallySorted     }   } }) </script>","describe('natto-folders-browser', () => {   beforeEach(() => {     wrapper = createWrapper(FoldersData.collection, 160, true, false)   })    describe('rendering', () => {     it('Should display folders in alphabetical order', () => {       const items = wrapper.findAll('.item-content__name__text')        expect(items[0].text()).toBe('A classer')       expect(items[1].text()).toBe('Achats')       expect(items[2].text()).toBe('Autres')       expect(items[3].text()).toBe('Banque')       expect(items[4].text()).toBe('Ventes')     })     it('Should rerender folders if folders prop change', async () => {       await wrapper.setProps({         folders: [           new Folder({             id: 9999,             name: 'Ventes',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           }),           new Folder({             id: 1001,             name: 'KPMG',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           })         ]       })        const items = wrapper.findAll('.item-content__name__text')        expect(items[0].text()).toBe('KPMG')       expect(items[1].text()).toBe('Ventes')     })     it('Should have the class folder-item-disabled when disabled is true', () => {       const folderItemWrapper = wrapper.find('.folder-item-disabled')        expect(folderItemWrapper.exists).toBeTruthy()     })   })   describe('binding', () => {     it('Should have a correct folders binding', () => {       expect(wrapper.vm.folders.length).toEqual(FoldersData.collection.length)     })     it('Should have the correct height value', () => {       expect(wrapper.vm.height).toEqual(160)     })   })   describe('events', () => {     it('Should emit browser-folder-selected event with correct payload', async () => {       const folderItemWrapper = wrapper.find('.folderItem')        await folderItemWrapper.trigger('click')       expect(wrapper.emitted('browser-folder-selected')).toBeTruthy()       expect(wrapper.emitted()['browser-folder-selected']).toHaveLength(1)     })   }) }) "
"<template>   <ElTree     class=""natto-tree""     v-bind=""$attrs""     :expand-on-click-node=""false""     :empty-text=""$t('ged.common.loading')""   >     <template #default=""{ node, data }"">       <slot name=""item"" :node=""node"" :data=""data"" />     </template>   </ElTree> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export interface NodeTree {   label: string   children: any }  export default defineComponent({   name: 'NattoTree' }) </script>","describe('NattoTree', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with ElTree', () => {     describe('rendering', () => {       it('should render the item and pass the props', () => {         expect(wrapper.find('#test').exists()).toBe(true)       })     })   }) }) "
"<template>   <div class=""natto-category-button"">     <el-button       :icon=""icon""       :class=""classes + ' nto-btn'""       @click=""click""       :disabled=""disabled""     >       {{ label }}</el-button     >   </div> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' export default defineComponent({   name: 'NattoCategoryButton',   props: {     label: {       type: String     },     active: {       type: Boolean,       default: false     },     containsChildren: {       type: Boolean,       default: false     },     disabled: {       type: Boolean,       default: false     }   },   emits: ['click-button'],    setup(props, { emit }) {     const click = () => emit('click-button')      return {       click,       icon: computed(() =>         props.active           ? 'el-icon-close'           : props.containsChildren           ? 'el-icon-plus'           : ''       ),       classes: computed(() => (props.active ? 'nto-btn-active' : ''))     }   } }) </script>","describe('NattoCategoryButton', () => {   beforeEach(() => {     jest.clearAllMocks()     wrapper = createWrapper('test me')   })   describe('bindings', () => {     describe('props', () => {       it('Should add close icon and active class when active props is true and whatever the value of containsChildren props is.', () => {         wrapper = createWrapper('test me', true)         let elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.text()).toStrictEqual('test me')         expect(elButtonWrapper.classes()).toHaveLength(2)         expect(elButtonWrapper.classes('nto-btn')).toBe(true)         expect(elButtonWrapper.classes('nto-btn-active')).toBe(true)         expect(elButtonWrapper.attributes('icon')).toBeTruthy()         expect(elButtonWrapper.attributes('icon')).toBe('el-icon-close')          wrapper = createWrapper('test me', true, true)         elButtonWrapper = wrapper.findComponent(ElButton)         expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.text()).toStrictEqual('test me')         expect(elButtonWrapper.classes()).toHaveLength(2)         expect(elButtonWrapper.classes('nto-btn')).toBe(true)         expect(elButtonWrapper.classes('nto-btn-active')).toBe(true)         expect(elButtonWrapper.attributes('icon')).toBeTruthy()         expect(elButtonWrapper.attributes('icon')).toBe('el-icon-close')       })        it('Should add plus icon when containsChildren props is true and active is false.', () => {         wrapper = createWrapper('test me', false, true)         const elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.text()).toStrictEqual('test me')         expect(elButtonWrapper.classes()).toHaveLength(1)         expect(elButtonWrapper.classes('nto-btn')).toBe(true)         expect(elButtonWrapper.attributes('icon')).toBeTruthy()         expect(elButtonWrapper.attributes('icon')).toBe('el-icon-plus')       })       it('Should not add icon when containsChildren props is false and active is false.', () => {         wrapper = createWrapper('test me', false, false)         const elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.text()).toStrictEqual('test me')         expect(elButtonWrapper.classes()).toHaveLength(1)         expect(elButtonWrapper.classes('nto-btn')).toBe(true)         expect(elButtonWrapper.attributes('icon')).toBeFalsy()       })     })      describe('events', () => {       it('Should fire click-button event when button is clicked', () => {         wrapper = createWrapper('test me', false, true)         const elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          elButtonWrapper.trigger('click')         expect(wrapper.emitted()['click-button'].length).toBe(1)         expect(wrapper.emitted()['click-button']).toBeTruthy()       })     })   })   describe('rendering', () => {     describe('props', () => {       it('Should display the label props', () => {         wrapper = createWrapper('test me', false, false)         const elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.text()).toStrictEqual('test me')         expect(elButtonWrapper.classes()).toHaveLength(1)         expect(elButtonWrapper.classes('nto-btn')).toBe(true)         expect(elButtonWrapper.attributes('icon')).toBeFalsy()       })        it('Should disable the button when disabled props true', () => {         wrapper = createWrapper('test me', false, false, true)         const elButtonWrapper: VueWrapper<any> = wrapper.findComponent(ElButton)          expect(elButtonWrapper).toBeTruthy()         expect(elButtonWrapper.attributes('disabled')).toBeTruthy()       })     })   }) }) "
"<template>   <div class=""refresh-btn"" @click=""onClick"">     <i class=""el-icon-refresh-left""></i>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' export default defineComponent({   name: 'NattoRefreshBtn',   props: {},    emits: ['refresh'],   setup(props, { emit }) {     return {       onClick() {         emit('refresh')       }     }   } }) </script>","describe('natto-refresh-btn', () => {   describe('events', () => {     it('Should emit refresh event on click', async () => {       const wrapper = mount(NattoRefreshBtn)       const div = wrapper.find('.refresh-btn')       await div.trigger('click')       expect(wrapper.emitted('refresh')).toBeTruthy()     })   }) }) "
"<template>   <div     class=""natto-primary-cta""     @click=""onClick""     :class=""disabled ? 'disabled-btn' : ''""   >     <span class=""btn-text"">{{ btnText }}</span>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' export default defineComponent({   name: 'NattoPrimaryCta',   props: {     disabled: {       type: Boolean,       default: false     },     action: {       type: String,       default: 'validateNext'     }   },    emits: ['validate', 'close'],   setup(props, { emit }) {     return {       btnText: computed(() => {         switch (props.action) {           case 'validateNext':             return 'Valider et suivant'           case 'validate':             return 'Valider'           case 'finish':             return 'Fermer'           default:             return ''         }       }),       onClick() {         if (!props.disabled) {           switch (props.action) {             case 'validateNext':               emit('validate')               break             case 'validate':               emit('validate')               break             case 'finish':               emit('close')               break           }         }       }     }   } }) </script>","describe('natto-primary-cta', () => {   describe('binding', () => {     describe('Valider et suivant', () => {       const wrapper = createWrapper('validateNext', false)       const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')       const buttonText: DOMWrapper<any> = wrapper.find('.btn-text')        it('Should have the appropriate button label', () => {         expect(buttonText.text()).toEqual('Valider et suivant')       })        it('Should emit validate event', async () => {         await button.trigger('click')         expect(wrapper.emitted('validate')).toBeTruthy()       })       describe('Diabled Button', () => {         const wrapper = createWrapper('validateNext', true)         const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')          it('Should be disbaled', () => {           expect(button.classes().find((x) => '.disabled-btn')).toBeTruthy()         })         it('Should not emit any events', async () => {           await button.trigger('click')           expect(wrapper.emitted('validate')).toBeFalsy()         })       })     })     describe('Valider', () => {       const wrapper = createWrapper('validate', false)       const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')       const buttonText: DOMWrapper<any> = wrapper.find('.btn-text')        it('Should have the appropriate button label', () => {         expect(buttonText.text()).toEqual('Valider')       })        it('Should emit validate event', async () => {         await button.trigger('click')         expect(wrapper.emitted('validate')).toBeTruthy()       })       describe('Diabled Button', () => {         const wrapper = createWrapper('validate', true)         const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')          it('Should be disbaled', () => {           expect(button.classes().find((x) => '.disabled-btn')).toBeTruthy()         })         it('Should not emit any events', async () => {           await button.trigger('click')           expect(wrapper.emitted('validate')).toBeFalsy()         })       })     })     describe('Fermer', () => {       const wrapper = createWrapper('finish', false)       const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')       const buttonText: DOMWrapper<any> = wrapper.find('.btn-text')        it('Should have the appropriate button label', () => {         expect(buttonText.text()).toEqual('Fermer')       })        it('Should emit validate event', async () => {         await button.trigger('click')         expect(wrapper.emitted('close')).toBeTruthy()       })       describe('Diabled Button', () => {         const wrapper = createWrapper('finish', true)         const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')          it('Should be disbaled', () => {           expect(button.classes().find((x) => '.disabled-btn')).toBeTruthy()         })         it('Should not emit any events', async () => {           await button.trigger('click')           expect(wrapper.emitted('close')).toBeFalsy()         })       })     })   }) }) "
"<template>   <el-button     :loading=""loading""     :disabled=""disabled""     :type=""type""     :native-type=""nativeType""   >     <slot />   </el-button> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoButton',    props: {     nativeType: String,     type: String,     loading: Boolean,     disabled: Boolean   } }) </script>","describe('NattoButton', () => {   beforeEach(() => {     wrapper = createWrapper()     elButtonWrapper = findElButton(wrapper)   })    describe('bindings with ElButton', () => {     test('props bindings', () => {       expect(elButtonWrapper.attributes('native-type')).toBe('button')       expect(elButtonWrapper.attributes('type')).toBe('button')       expect(elButtonWrapper.attributes('disabled')).toBe('false')       expect(elButtonWrapper.attributes('loading')).toBe('false')     })   }) }) "
"<template>   <div class=""natto-table__header""><slot /></div> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'NattoTableHeader' }) </script>","describe('NattoTableHeader', () => {   describe('rendering', () => {     it('should have a bold text if the mouse is over the text', async () => {       wrapper = createWrapper()        expect(wrapper.text()).toContain('default slot')     })   }) }) "
"<template>   <div class=""browse-doc__header"">     <div class=""browse-doc__header-type"">       <natto-checkbox         :model-value=""areAllSelected""         @change=""$emit('select-all')""       />     </div>     <div class=""browse-doc__header-name"" @click=""sort('name')"">       <document-name-header         :value=""$t('ged.common.table.headers.documentName')""       />       <div v-if=""displayNameSort"" class=""filter-icon"" :class=""filterClass"">         <arrow-down-icon />       </div>     </div>     <div class=""browse-doc__header-date"" @click=""sort('updated')"">       <document-creation-date-header         :value=""$t('ged.common.table.headers.date')""       />       <div v-if=""displayDateSort"" class=""filter-icon"" :class=""filterClass"">         <arrow-down-icon />       </div>     </div>     <div class=""browse-doc__header-action"">       <document-action-header />     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue'  import DocumentNameHeader from '@/modules/Search/components/DocumentsTable/DocumentsTableHeaders/DocumentNameHeader.vue' import DocumentCreationDateHeader from '@/modules/Search/components/DocumentsTable/DocumentsTableHeaders/DocumentCreationDateHeader.vue' import DocumentActionHeader from '@/modules/Search/components/DocumentsTable/DocumentsTableHeaders/DocumentActionHeader.vue' import ArrowDownIcon from '@/Common/components/Icons/ArrowDownIcon.vue' import SortOptions from '@/Common/models/List/SortOptions' import DocumentsSortOptions from '@/modules/Search/models/Documents/Query/DocumentsSortOptions' import NattoCheckbox from '@/Common/components/Checkboxes/NattoCheckbox.vue'  export default defineComponent({   name: 'NattoTableCustomHeader',   props: {     sortOptions: SortOptions,     areAllSelected: Boolean   },   emits: ['sort-arbo-table'],   components: {     NattoCheckbox,     DocumentActionHeader,     DocumentCreationDateHeader,     DocumentNameHeader,     ArrowDownIcon   },   setup(props, { emit }) {     return {       displayNameSort: computed(         () =>           props.sortOptions?.sortBy == 'name' &&           props.sortOptions?.sortDirection       ),       displayDateSort: computed(         () =>           props.sortOptions?.sortBy == 'updated' &&           props.sortOptions?.sortDirection       ),       filterClass: computed(() => {         return props.sortOptions?.sortDirection == 'ascending'           ? 'filter-icon-asc'           : 'filter-icon-desc'       }),       sort: (field: string) => {         if (field === props.sortOptions?.sortBy) {           emit(             'sort-arbo-table',             new DocumentsSortOptions({               sortBy: field,               sortDirection:                 props.sortOptions?.sortDirection === 'ascending'                   ? 'descending'                   : props.sortOptions?.sortDirection === 'descending'                   ? null                   : 'ascending'             })           )         } else {           emit(             'sort-arbo-table',             new DocumentsSortOptions({               sortBy: field,               sortDirection: 'ascending'             })           )         }       }     }   } }) </script>","describe('NattoTableCustomHeader', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoCheckboxWrapper = findNattoCheckbox(wrapper)   })   describe('bindings with NattoCheckbox', () => {     test('static props', () => {       expect(nattoCheckboxWrapper.attributes()).toStrictEqual({         'model-value': 'false'       })     })     describe('events', () => {       it('should emit select-all when NattoCheckbox emits change', async () => {         await nattoCheckboxWrapper.vm.$emit('change')          expect(wrapper.emitted('select-all')).toHaveLength(1)       })     })   })   describe('binding', () => {     describe('props', () => {       it('Should bind correctly prop sortOptions', () => {         expect(wrapper.props('sortOptions')).toEqual(defaultProps.sortOptions)       })     })     describe('rendering', () => {       describe('Should calculate displayNameSort correctly', () => {         const cases = [           {             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             }),             expectedClass: '.filter-icon-asc',             expectedValue: true           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'descending'             }),             expectedClass: '.filter-icon-desc',             expectedValue: true           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: null             }),             expectedClass: '.filter-icon-asc',             expectedValue: false           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: null             }),             expectedClass: '.filter-icon-desc',             expectedValue: false           }         ]          test.each(cases)(           'Test Computing',           ({ sortOptions, expectedClass, expectedValue }) => {             wrapper = createWrapper({               sortOptions: sortOptions             })             const IconWrapper = wrapper.find(expectedClass)              expect(IconWrapper.exists()).toBe(expectedValue)           }         )       })        describe('Should calculate displayDateSort correctly', () => {         const cases = [           {             sortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'ascending'             }),             expectedClass: '.filter-icon-asc',             expectedValue: true           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'descending'             }),             expectedClass: '.filter-icon-desc',             expectedValue: true           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: null             }),             expectedClass: '.filter-icon-asc',             expectedValue: false           },           {             sortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: null             }),             expectedClass: '.filter-icon-desc',             expectedValue: false           }         ]          test.each(cases)(           'Test Computing',           ({ sortOptions, expectedClass, expectedValue }) => {             wrapper = createWrapper({               sortOptions: sortOptions             })             const IconWrapper = wrapper.find(expectedClass)              expect(IconWrapper.exists()).toBe(expectedValue)           }         )       })     })     describe('events', () => {       describe('It should emit sort-arbo-table corretly , Name', () => {         const cases = [           {             elementToClick: '.browse-doc__header-name',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'descending'             })           },           {             elementToClick: '.browse-doc__header-name',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'descending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: null             })           }         ]          test.each(cases)(           'Test sort by name',           async ({             elementToClick,             currentSortOptions,             expectedSortDirection           }) => {             wrapper = createWrapper({               sortOptions: currentSortOptions             })             const IconWrapper = wrapper.find(elementToClick)              await IconWrapper.trigger('click')             expect(wrapper.emitted('sort-arbo-table')).toHaveLength(1)             expect(wrapper.emitted('sort-arbo-table')).toStrictEqual([               [expectedSortDirection]             ])           }         )       })       describe('It should emit sort-arbo-table corretly , Updated', () => {         const cases = [           {             elementToClick: '.browse-doc__header-date',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'ascending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'descending'             })           },           {             elementToClick: '.browse-doc__header-date',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'descending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: null             })           }         ]          test.each(cases)(           'Test sort by creation',           async ({             elementToClick,             currentSortOptions,             expectedSortDirection           }) => {             wrapper = createWrapper({               sortOptions: currentSortOptions             })             const IconWrapper = wrapper.find(elementToClick)              await IconWrapper.trigger('click')             expect(wrapper.emitted('sort-arbo-table')).toHaveLength(1)             expect(wrapper.emitted('sort-arbo-table')).toStrictEqual([               [expectedSortDirection]             ])           }         )       })       describe('It should set default sortDirection while changing sortBy', () => {         const cases = [           {             elementToClick: '.browse-doc__header-date',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'ascending'             })           },           {             elementToClick: '.browse-doc__header-name',             currentSortOptions: new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'descending'             }),             expectedSortDirection: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             })           }         ]          test.each(cases)(           'Toggle between sort by name and creation',           async ({             elementToClick,             currentSortOptions,             expectedSortDirection           }) => {             wrapper = createWrapper({               sortOptions: currentSortOptions             })             const IconWrapper = wrapper.find(elementToClick)              await IconWrapper.trigger('click')             expect(wrapper.emitted('sort-arbo-table')).toHaveLength(1)             expect(wrapper.emitted('sort-arbo-table')).toStrictEqual([               [expectedSortDirection]             ])           }         )       })     })   }) }) "
"<template>   <natto-table-custom-header     v-if=""hideHeader""     :areAllSelected=""areAllSelected""     :sort-options=""sortOptions""     @sort-arbo-table=""propagateSortEvent""     @select-all=""$emit('select-all')""   />   <div     ref=""nattoTableContainerRef""     class=""natto-table--scrollable natto-scrollbar""   >     <slot name=""prepend-table"" />     <MpTable       ref=""mpTableRef""       v-infinite-scroll=""emitOnScrollToBottom""       :infinite-scroll-disabled=""infiniteScrollDisabled""       v-loading=""loading""       class=""natto-table""       :is-selection=""isSelection""       :highlight-row-on-click=""highlightRowOnClick""       selection-width=""10%""       :cell-class-name=""cellClassName""       :row-class-name=""rowClassName""       :show-header=""!hideHeader""       :data=""tableData""       @row-click=""handleRowClick""       @selection-change=""selectionChangeHandler""     >       <template #empty>         <div id=""default-message"" v-if=""!loading"">Aucun document</div>       </template>       <slot />     </MpTable>   </div>   <slot name=""append-table"" />   <natto-pagination     v-show=""displayPagination""     class=""natto-table__pagination""     :items-total=""itemsTotal""     :page-size=""itemsPerPage""     :pageNumber=""pageNumber""     @page-opened=""handlePageOpened""   /> </template>  <script lang=""ts""> import { computed, defineComponent, PropType, ref } from 'vue' import NattoTableCustomHeader from '@/Common/components/Table/NattoTableCustomHeader.vue' import NattoPagination from '@/Common/components/Paging/NattoPagination.vue' import DocumentsSortOptions from '@/modules/Search/models/Documents/Query/DocumentsSortOptions'  export type ElementPlusTablePayload = {   row: any   rowIndex: number }  export default defineComponent({   name: 'NattoTable',   components: { NattoPagination, NattoTableCustomHeader },   props: {     sortOptions: {       type: DocumentsSortOptions     },     tableData: {       type: Array,       required: true     },     itemsTotal: {       type: Number,       default: 0     },     itemsPerPage: {       type: Number,       default: 10     },     pageNumber: {       type: Number,       default: 1     },     loading: Boolean,     hideHeader: Boolean,     paginated: Boolean,     infiniteScrollFinished: Boolean,     areAllSelected: Boolean,     cellClassName: {       type: Function as PropType<         (elementPayload: {           row?: unknown           column?: unknown           rowIndex?: number           columnIndex?: number         }) => string       >,       default: () => ''     },     rowClassName: {       type: Function,       default: undefined     },     isSelection: Boolean,     highlightRowOnClick: Boolean   },   emits: [     'page-opened',     'on-scroll-to-bottom',     'sort-arbo-table',     'row-clicked',     'selection-change',     'select-all'   ],    setup(props, { emit }) {     const mpTableRef = ref(null as any)     const nattoTableContainerRef = ref(document.createElement('div'))      const clearSelection = () => {       mpTableRef?.value?.ElTableInstance?.clearSelection()       mpTableRef?.value?.handleSelectionChange([])     }      const selectRow = (documentId: string) => {       mpTableRef?.value?.handleRowClick({ id: documentId })     }      const toggleAll = () => {       mpTableRef?.value?.ElTableInstance?.toggleAllSelection()     }      return {       clearSelection,       selectRow,       mpTableRef,       toggleAll,       displayPagination: computed(() => {         return !props.loading && props.paginated       }),       emitOnScrollToBottom: () => {         if (!props.paginated) {           emit('on-scroll-to-bottom')         }       },       propagateSortEvent: (data: DocumentsSortOptions) => {         emit('sort-arbo-table', data)       },       infiniteScrollDisabled: computed(         () => props.infiniteScrollFinished || props.loading       ),       handleRowClick: (row: ElementPlusTablePayload) => {         emit('row-clicked', row)       },       selectionChangeHandler: (documentIds: string[]) => {         emit('selection-change', documentIds)       },       handlePageOpened: (page: number) => {         emit('page-opened', page)         nattoTableContainerRef.value.scrollTo({           top: 0         })       },       nattoTableContainerRef     }   } }) </script>","describe('NattoTable', () => {   beforeEach(() => {     wrapper = createWrapper()     mpTableWrapper = findMpTableWrapper(wrapper)   })    describe('bindings', () => {     describe('MpTable binding', () => {       describe('mpTable methods', () => {         it('should call clearSelection of ElTable when clearSelection is called', async () => {           mpTableWrapper.vm.ElTableInstance.clearSelection = jest.fn()           mpTableWrapper.vm.handleSelectionChange = jest.fn()            wrapper.vm.clearSelection()            expect(             mpTableWrapper.vm.ElTableInstance.clearSelection           ).toHaveBeenCalled()           expect(mpTableWrapper.vm.handleSelectionChange).toHaveBeenCalledWith(             []           )         })         it('should call handleRowClick when selectRow is called', async () => {           mpTableWrapper.vm.handleRowClick = jest.fn()            wrapper.vm.selectRow('19')            expect(mpTableWrapper.vm.handleRowClick).toHaveBeenCalledWith({             id: '19'           })         })         it('should call toggleAll when toggleAll is called', () => {           mpTableWrapper.vm.ElTableInstance.toggleAllSelection = jest.fn()            wrapper.vm.toggleAll()            expect(             mpTableWrapper.vm.ElTableInstance.toggleAllSelection           ).toHaveBeenCalled()         })       })       it('props binding', () => {         const cellClassName = jest.fn(() => 'test')         const rowClassName = jest.fn(() => 'test')          wrapper = createWrapper({           tableData: [{ value: 'test', label: 'Test' }],           loading: true,           hideHeader: true,           infiniteScrollFinished: true,           rowClassName,           cellClassName,           isSelection: true,           highlightRowOnClick: true         })          const mpTableWrapper: VueWrapper<any> = findMpTableWrapper(wrapper)          expect(mpTableWrapper.attributes('show-header')).toBe('false')         expect(mpTableWrapper.props('data')).toStrictEqual([           { value: 'test', label: 'Test' }         ])         expect(mpTableWrapper.props('cellClassName')).toBe(cellClassName)         expect(mpTableWrapper.props('rowClassName')).toBe(rowClassName)         expect(mpTableWrapper.props('isSelection')).toBe(true)         expect(mpTableWrapper.props('highlightRowOnClick')).toBe(true)         expect(mpTableWrapper.attributes('infinite-scroll-disabled')).toBe(           'true'         )       })        const disabledCases = [         {           infiniteScrollFinished: false,           loading: false,           expectedDisabled: false         },         {           infiniteScrollFinished: false,           loading: true,           expectedDisabled: true         },         {           infiniteScrollFinished: true,           loading: false,           expectedDisabled: true         },         {           infiniteScrollFinished: true,           loading: true,           expectedDisabled: true         }       ]        test.each(disabledCases)(         'infinite scroll must be disabled if loading or no more result',         ({ infiniteScrollFinished, loading, expectedDisabled }) => {           wrapper = createWrapper({             tableData: [{ value: 'test', label: 'Test' }],             loading,             infiniteScrollFinished           })            const elTableWrapper: VueWrapper<any> = findMpTableWrapper(wrapper)            expect(elTableWrapper.attributes('infinite-scroll-disabled')).toBe(             `${expectedDisabled}`           )         }       )        describe('events', () => {         it('should emit on-scroll-to-bottom on mounted', () => {           expect(wrapper.emitted('on-scroll-to-bottom')).toBeTruthy()         })         it.each([           { received: 'row-click', emitted: 'row-clicked' },           { received: 'selection-change', emitted: 'selection-change' }         ])(           'should emit row-clicked when MpTable emit row-click',           async ({ received, emitted }) => {             await mpTableWrapper.vm.$emit(received)              expect(wrapper.emitted(emitted))           }         )       })     })     describe('NattoPagination binding', () => {       describe('rendering', () => {         const displayCases = [           { paginated: false, loading: false, nattoPaginationExists: false },           { paginated: false, loading: true, nattoPaginationExists: false },           { paginated: true, loading: false, nattoPaginationExists: true },           { paginated: true, loading: true, nattoPaginationExists: false }         ]          test.each(displayCases)(           'if paginated: $paginated ,then NattoPagination exists: $nattoPaginationExists',           ({ paginated, loading, nattoPaginationExists }) => {             wrapper = createWrapper({               tableData: [],               paginated,               loading             })              const nattoPagination: DOMWrapper<HTMLDivElement> = wrapper.find(               '.natto-table__pagination'             )              expect(nattoPagination.element.style.display !== 'none').toBe(               nattoPaginationExists             )           }         )       })       describe('props', () => {         it('props binding', () => {           wrapper = createWrapper({             tableData: [],             paginated: true,             itemsTotal: 520,             itemsPerPage: 10,             pageNumber: 52           })            const nattoPaginationWrapper = findNattoPaginationWrapper(wrapper)            expect(nattoPaginationWrapper.vm.itemsTotal).toBe(520)           expect(nattoPaginationWrapper.vm.pageSize).toBe(10)           expect(nattoPaginationWrapper.vm.pageNumber).toBe(52)         })       })       describe('events', () => {         it('should emit page-opened when NattoPagination emit page-opened and scrollToTop', async () => {           wrapper = createWrapper({             tableData: [],             paginated: true           })           wrapper.vm.nattoTableContainerRef.scrollTo = jest.fn()            const nattoPaginationWrapper: NattoPaginationWrapper =             findNattoPaginationWrapper(wrapper)            await nattoPaginationWrapper.vm.$emit('page-opened', 4)            expect(wrapper.emitted('page-opened')).toBeTruthy()           expect(wrapper.emitted('page-opened')).toStrictEqual([[4]])           expect(             wrapper.vm.nattoTableContainerRef.scrollTo           ).toHaveBeenCalledWith({             top: 0           })         })       })     })     describe('NattoTableCustomHeader binding', () => {       describe('props', () => {         it('Should bind sortOptions Correctly', () => {           wrapper = createWrapper({             ...defaultProps,             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             }),             areAllSelected: true,             hideHeader: true           })           expect(findNattoTableCustomHeaderWrapper(wrapper).props()).toEqual({             sortOptions: new DocumentsSortOptions({               sortBy: 'name',               sortDirection: 'ascending'             }),             areAllSelected: true           })         })       })       describe('rendering', () => {         const displayCases = [           { hideHeader: false, nattoTableCustomHeaderExists: false },           { hideHeader: true, nattoTableCustomHeaderExists: true }         ]          test.each(displayCases)(           'if hideHeader: $hideHeader ,then NattoTableCustomHeader exists: $nattoTableCustomHeaderExists',           ({ hideHeader, nattoTableCustomHeaderExists }) => {             wrapper = createWrapper({               tableData: [],               hideHeader             })              expect(findNattoTableCustomHeaderWrapper(wrapper).exists()).toBe(               nattoTableCustomHeaderExists             )           }         )       })       describe('events', () => {         it('Should emit sort-arbo-table on sort-arbo-table', async () => {           wrapper = createWrapper({             ...defaultProps,             hideHeader: true           })           await findNattoTableCustomHeaderWrapper(wrapper).vm.$emit(             'sort-arbo-table',             new DocumentsSortOptions({               sortBy: 'updated',               sortDirection: 'ascending'             })           )            expect(wrapper.emitted('sort-arbo-table')).toHaveLength(1)           expect(wrapper.emitted('sort-arbo-table')).toStrictEqual([             [               new DocumentsSortOptions({                 sortBy: 'updated',                 sortDirection: 'ascending'               })             ]           ])         })         it('should emit select-all when NattoTableCustomHeader emit select-all', async () => {           wrapper = createWrapper({             ...defaultProps,             hideHeader: true           })           await findNattoTableCustomHeaderWrapper(wrapper).vm.$emit(             'select-all'           )            expect(wrapper.emitted('select-all')).toHaveLength(1)           expect(wrapper.emitted('select-all')).toBeTruthy()         })       })     })      describe('empty slot binding', () => {       describe('rendering', () => {         const displayCases = [           { loading: true, displayDefaultMessages: false },           { loading: false, displayDefaultMessages: true }         ]          test.each(displayCases)(           'if loading: $loading ,then default messages exists: $displayDefaultMessages',           ({ loading, displayDefaultMessages }) => {             wrapper = createWrapper({               ...defaultProps,               loading             })              expect(wrapper.find('#default-message').exists()).toBe(               displayDefaultMessages             )           }         )       })     })   }) }) "
"<template>   <natto-dialog-popup     v-model=""isDeletefileModalConfirmationOpened""     :title=""title""     :description=""description""     :loading=""loading""     popup-type=""error""     @confirm-clicked=""dispatchDeletefile""     @cancel-clicked=""handleCancelClick""   /> </template>  <script lang=""ts""> import { computed, defineComponent, ref, PropType } from 'vue' import NattoDialogPopup from '@/Common/components/Modals/NattoDialogPopup.vue' import useVModel from '@/Common/hooks' import useDeleteFileHelpers from '@/modules/DataManipulation/Delete/DeleteFile/store/helpers' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'DeleteFileModalConfirmation',   components: { NattoDialogPopup },   props: {     modelValue: {       type: Boolean,       required: true     },     documentIds: {       type: Array as PropType<string[]>,       required: true     },     isSynchronizedDocument: {       type: Boolean     }   },   emits: ['delete-file-confirmed'],   setup(props, { emit }) {     const store = useStore()     const { deleteFiles } = useDeleteFileHelpers(store)     const { fetchDocuments } = useSearchStoreHelpers()      const isDeletefileModalConfirmationOpened = useVModel(props)      const { tc } = useTranslation()      const getTranslation = (translationKey: string) =>       tc(translationKey, props.documentIds.length, {         fileCount: props.documentIds.length       })      const state = {       title: computed(() =>         getTranslation('ged.dataManipulation.delete.modal.title')       ),       description: computed(() =>         props.isSynchronizedDocument && props.documentIds.length === 1           ? getTranslation(               'ged.dataManipulation.delete.modal.descriptionSyncStatus'             )           : getTranslation(               'ged.dataManipulation.delete.modal.descriptionSimple'             )       ),       loading: ref(false)     }      const dispatchDeletefile = async () => {       trackEventFactory(analyticsCode['adv-delete-file'])       emit('delete-file-confirmed')       state.loading.value = true       await deleteFiles(props.documentIds)       await fetchDocuments(store)       isDeletefileModalConfirmationOpened.value = false       state.loading.value = false     }      const handleCancelClick = () => {       isDeletefileModalConfirmationOpened.value = false     }      return {       loading: state.loading,       isDeletefileModalConfirmationOpened,       title: state.title,       description: state.description,       dispatchDeletefile,       handleCancelClick     }   } }) </script>","describe('DeleteFileModalConfirmation', () => {   beforeEach(() => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()   })    describe('bindings with NattoDialogPopup', () => {     describe('props bindings', () => {       test('static props', () => {         wrapper = createWrapper()         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          expect(nattoDialogPopupWrapper.props('modelValue')).toBe(true)         expect(nattoDialogPopupWrapper.props('popupType')).toBe('error')       })        it.each([         {           documentIds: ['19', '27'],           isSynchronizedDocument: false,           description:             'ged.dataManipulation.delete.modal.descriptionSimple with 2'         },         {           documentIds: ['19', '27'],           isSynchronizedDocument: true,           description:             'ged.dataManipulation.delete.modal.descriptionSimple with 2'         },         {           documentIds: ['19'],           isSynchronizedDocument: false,           description:             'ged.dataManipulation.delete.modal.descriptionSimple with 1'         },         {           documentIds: ['19'],           isSynchronizedDocument: true,           description:             'ged.dataManipulation.delete.modal.descriptionSyncStatus with 1'         }       ])(         'should render the right description if the doc is sync or not',         ({ isSynchronizedDocument, documentIds, description }) => {           wrapper = createWrapper({             ...defaultProps,             isSynchronizedDocument,             documentIds           })           const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)            expect(nattoDialogPopupWrapper.props('description')).toBe(description)         }       )     })      describe('events bindings', () => {       it('should dispatch deleteFileByModal with fileId when NattoDialogPopup emit confirm-clicked', async () => {         // When NattoDialogPopup emit confirm-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('confirm-clicked')          await wrapper.vm.$nextTick()          expect(wrapper.emitted('delete-file-confirmed')).toHaveLength(1)          // Then DeleteFileModalConfirmation should dispatch deleteFileByModal         expect(storeMock.dispatch).toHaveBeenNthCalledWith(           1,           deleteFileModule('deleteFiles'),           ['4521']         )         expect(storeMock.dispatch).toHaveBeenNthCalledWith(           2,           searchModule('fetchDocuments')         )         expect(trackEventFactory).toBeCalledWith('adv-delete-file')       })       it('should close the modal when cancel button is clicked', async () => {         // When NattoDialogPopup emit cancel-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('cancel-clicked')          // Then the modal must be closed         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])       })     })   }) }) "
"<template>   <natto-dialog-popup     v-model=""isDeleteFolderModalConfirmationOpened""     :title=""title""     :description=""description""     popup-type=""error""     @confirm-clicked=""dispatchDeleteFolder""     @cancel-clicked=""handleCancelClick""     :loading=""isFolderDeleting()""     :error-message=""errorMessage""   /> </template>  <script lang=""ts""> import { computed, defineComponent, ref } from 'vue' import NattoDialogPopup from '@/Common/components/Modals/NattoDialogPopup.vue' import useVModel from '@/Common/hooks' import constants from '@/Common/constants' import useDeleteFolderHelpers from '@/modules/DataManipulation/Delete/DeleteFolder/store/helpers' import { useStore } from 'vuex' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode'  export default defineComponent({   name: 'DeleteFolderModalConfirmation',   components: { NattoDialogPopup },   props: {     modelValue: {       type: Boolean,       required: true     },     folderId: {       type: Number,       required: true     },     folderName: {       type: String,       required: true     }   },    setup(props) {     const store = useStore()     const { deleteFolderByModal, isFolderDeleting } =       useDeleteFolderHelpers(store)      const isDeleteFolderModalConfirmationOpened = useVModel(props)     const errorMessage = ref('')      const state = {       title: constants.messages.folders.delete.modal.title,       description: computed(() =>         constants.messages.folders.delete.modal.description(props.folderName)       )     }      const dispatchDeleteFolder = async () => {       try {         trackEventFactory(analyticsCode['adv-delete-file'])         await deleteFolderByModal(props.folderId)         isDeleteFolderModalConfirmationOpened.value = false       } catch (error) {         errorMessage.value = constants.messages.folders.delete.error       }     }      const handleCancelClick = () => {       isDeleteFolderModalConfirmationOpened.value = false       errorMessage.value = ''     }      return {       isDeleteFolderModalConfirmationOpened,       title: state.title,       description: state.description,       dispatchDeleteFolder,       handleCancelClick,       isFolderDeleting,       errorMessage     }   } }) </script>","describe('DeleteFolderModalConfirmation', () => {   beforeEach(() => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()   })    describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)        expect(nattoDialogPopupWrapper.props('modelValue')).toBe(true)       expect(nattoDialogPopupWrapper.props('title')).toBe(         'Êtes-vous sûr de vouloir supprimer ce dossier ?'       )       expect(nattoDialogPopupWrapper.props('popupType')).toBe('error')       expect(nattoDialogPopupWrapper.props('description')).toBe(         'Si vous cliquez sur ""Continuer"", tous les fichiers et sous dossiers à partir du dossier ""home"" seront supprimés et envoyés à la corbeille.'       )     })     describe('events bindings', () => {       it('should dispatch deleteFolderByModal with folderId when NattoDialogPopup emit confirm-clicked and close the modal', async () => {         // When NattoDialogPopup emit confirm-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('confirm-clicked')         await wrapper.vm.$nextTick()          expect(trackEventFactory).toBeCalledWith('adv-delete-file')         // Then DeleteFolderModalConfirmation should dispatch deleteFolderByModal         expect(storeMock.dispatch).toHaveBeenCalledWith(           deleteFoldersModule('deleteFolderByModal'),           4521         )         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toEqual([[false]])       })       it('should set error message and let the modal opened if error is catch when dispatch deleteFolderByModal', async () => {         // Given deleteFolderByModal return an error         storeMock = createDeleteFolderStoreMocked()         storeMock.dispatch = jest.fn(() => Promise.reject('Error'))          wrapper = createWrapper(defaultProps, storeMock)          // When NattoDialogPopup emit confirm-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('confirm-clicked')         await wrapper.vm.$nextTick()          expect(trackEventFactory).toBeCalledWith('adv-delete-file')         // Then DeleteFolderModalConfirmation should dispatch deleteFolderByModal         expect(storeMock.dispatch).toHaveBeenCalledWith(           deleteFoldersModule('deleteFolderByModal'),           4521         )         expect(wrapper.emitted('update:modelValue')).toBeFalsy()       })       it('should close the modal when cancel button is clicked', async () => {         // When NattoDialogPopup emit cancel-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('cancel-clicked')          // Then the modal must be closed         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])       })     })   }) }) "
"<template>   <mp-card class=""mail-to-ged-card"" @click=""$emit('open-mail-to-ged')"">     <mp-icon name=""send""></mp-icon>     <span class=""card-text"">{{       $tc('ged.dataManipulation.mailtoged.cardText')     }}</span>     <mp-icon name=""arrow-right""></mp-icon>   </mp-card> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'MailToGedCard',   emits: ['open-mail-to-ged'] }) </script>","describe('MailToGedCard', () => {   it('When click on mpcard emit evnet', () => {     const wrapper = createWrapper()      wrapper.find('mp-card').trigger('click')     expect(wrapper.emitted()['open-mail-to-ged']).toBeTruthy()   }) }) "
"<template>   <el-dialog     v-model=""isOpened""     :show-close=""true""     append-to-body     custom-class=""mailToGed-dialog-container""   >     <template #title class=""natto-dialog-title"">       <span class=""title-mailToGed"">{{         $tc('ged.dataManipulation.mailToGed.Modal.title')       }}</span>       <span class=""description-mailToGedd"">{{         $tc('ged.dataManipulation.mailToGed.Modal.description')       }}</span>     </template>     <loading-icon class=""mail-to-ged-loading"" v-if=""mailToGedInfos.isLoading"" />     <mail-to-ged-line       v-else       v-for=""(item, index) in mailToGedInfos.items""       :key=""index""       :folderName=""item.label""       :folderEmail=""item.emailAddress""       :class=""index < mailToGedInfos.items.length - 1 ? 'spacer' : ''""     />     <template #footer class=""mailToGed-dialog-footer"">       <div         class=""more-info""         @click=""$emit('more-info', mailToGedInfos.moreInformationLink)""       />       <mp-button         class=""close-modal-btn""         size=""small""         btn-type=""primary""         @click=""closeModal""       >         {{ $tc('ged.dataManipulation.mailToGed.Modal.buttons.close') }}       </mp-button>     </template>   </el-dialog> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import MailToGedLine from '@/modules/DataManipulation/MailToGed/components/Elements/MailToGedLine.vue' import useVModel from '@/Common/hooks' import { MailToGedInformations } from '@/modules/DataManipulation/MailToGed/models/MailToGedInformations' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue'  export default defineComponent({   name: 'MailToGedModal',   emits: ['more-info', 'close'],   components: {     MailToGedLine,     LoadingIcon   },   props: {     mailToGedInfos: MailToGedInformations   },   setup(props, { emit }) {     const isOpened = useVModel(props)      return {       isOpened,       closeModal: () => emit('close')     }   } }) </script>","describe('MailToGedLine', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('binding with MailToGedLine', () => {       describe('props', () => {         const cases = [           {             prop: 'folderName',             expectedValue: defaultProps.mailToGedInfos.items[0].label           },           {             prop: 'folderEmail',             expectedValue: defaultProps.mailToGedInfos.items[0].emailAddress           }         ]          test.each(cases)('Test binding props', ({ prop, expectedValue }) => {           const MailToGedLineWrapper = wrapper.findComponent(MailToGedLine)            expect(MailToGedLineWrapper.props(prop)).toEqual(expectedValue)         })       })     })     describe('events', () => {       it('Should emit more-info on more info link click', async () => {         const MoreInfoLinkWrapper = wrapper.find('.more-info')          await MoreInfoLinkWrapper.trigger('click')          await wrapper.vm.$nextTick()          expect(wrapper.emitted('more-info')).toHaveLength(1)         expect(wrapper.emitted('more-info')).toStrictEqual([           [defaultProps.mailToGedInfos.moreInformationLink]         ])       })       it('Should emit close event on close btn cllick', async () => {         const CloseBtnWrapper = wrapper.find('.close-modal-btn')          await CloseBtnWrapper.trigger('click')          await wrapper.vm.$nextTick()          expect(wrapper.emitted('close')).toBeTruthy()       })     })     describe('rendering', () => {       const cases = [         {           element: '.title-mailToGed',           expectedValue: 'ged.dataManipulation.mailToGed.Modal.title'         },         {           element: '.description-mailToGedd',           expectedValue: 'ged.dataManipulation.mailToGed.Modal.description'         },         {           element: '.close-modal-btn',           expectedValue: 'ged.dataManipulation.mailToGed.Modal.buttons.close'         }       ]        test.each(cases)(         'Test content rendering',         ({ element, expectedValue }) => {           const ElementWrapper = wrapper.find(element)            expect(ElementWrapper.text()).toContain(expectedValue)         }       )     })   }) }) "
"<template>   <div class=""mailToGed-element-container"">     <div class=""icon-zone"">       <mp-icon name=""documents""></mp-icon>     </div>     <div class=""content-zone"">       <span class=""folderName"">{{ folderName }}</span>       <span class=""folder-email"">{{ folderEmail }}</span>     </div>     <div class=""actions-zone"">       <mp-button         type=""primary""         class=""copy-address-btn""         size=""small""         btn-type=""primary""         @click=""copy""       >         {{ emailCopyText }}       </mp-button>       <a :href=""emailLink"">         <mp-button           class=""send-email-btn""           size=""small""           btn-type=""primary""           @click=""sendEmail""         >           {{ $tc('ged.dataManipulation.mailToGed.Modal.buttons.sendEmail') }}         </mp-button>       </a>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, ref, computed } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'MailToGedLine',   props: {     folderName: String,     folderEmail: String   },   setup(props) {     const copied = ref(false)     const { t } = useTranslation()      return {       copied,       emailCopyText: computed(() =>         copied.value           ? t('ged.dataManipulation.mailToGed.Modal.buttons.addressCopied')           : t('ged.dataManipulation.mailToGed.Modal.buttons.copyAddress')       ),       emailLink: computed(() => 'mailto:' + props.folderEmail),       copy: async () => {         await navigator.clipboard.writeText(props.folderEmail ?? '')         copied.value = true         setTimeout(() => {           copied.value = false         }, 500)       }     }   } }) </script>","describe('MailToGedLine', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('props', () => {       it('Should bind correctly , folderName', () => {         expect(wrapper.props('folderName')).toEqual(defaultProps.folderName)       })       it('Should bind correctly , folderEmail', () => {         expect(wrapper.props('folderEmail')).toEqual(defaultProps.folderEmail)       })     })     describe('rendering', () => {       describe('should render the right text', () => {         const cases = [           {             button: '.copy-address-btn',             expectedValue:               'ged.dataManipulation.mailToGed.Modal.buttons.copyAddress'           },           {             button: '.send-email-btn',             expectedValue:               'ged.dataManipulation.mailToGed.Modal.buttons.sendEmail'           }         ]          test.each(cases)('Test button text', ({ button, expectedValue }) => {           const ButtonWrapper = wrapper.find(button)            expect(ButtonWrapper.text()).toContain(expectedValue)         })       })     })     describe('events', () => {       it('Should copy value to clipboard when user click copy button', async () => {         let copiedText = ''          jest.useFakeTimers()         jest.spyOn(global, 'setTimeout')          Object.assign(navigator, {           clipboard: {             writeText: (x: string) => {               copiedText = x             }           }         })         jest.spyOn(navigator.clipboard, 'writeText')          const copyAddressButton = wrapper.find('.copy-address-btn')          expect(copyAddressButton.text()).toBe(           'ged.dataManipulation.mailToGed.Modal.buttons.copyAddress'         )         copyAddressButton.trigger('click')          await flushPromises()         expect(copiedText).toBe('email')         expect(navigator.clipboard.writeText).toBeCalledTimes(1)         expect(setTimeout).toBeCalledTimes(1)         expect(setTimeout).toBeCalledWith(expect.any(Function), 500)         expect(copyAddressButton.text()).toBe(           'ged.dataManipulation.mailToGed.Modal.buttons.addressCopied'         )         jest.runAllTimers()         await flushPromises()         expect(copyAddressButton.text()).toBe(           'ged.dataManipulation.mailToGed.Modal.buttons.copyAddress'         )       })     })   }) }) "
"<template>   <div class=""failed-container"">     <div class=""icon-zone""><warning-icon /></div>     <div class=""main-content-zone"">       <p class=""description"">Import fini</p>       <p class=""sub-description"">{{ description }}</p>     </div>     <div class=""actions-zone"">       <mp-button         class=""open-upload-modal-cta""         size=""small""         btn-type=""primary""         @click=""openModal""       >         {{ labelBtn }}       </mp-button>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import WarningIcon from '@/Common/components/Icons/WarningIcon.vue' import { useTranslation } from '@/Common/hooks/useTranslation' export default defineComponent({   name: 'FailedUploadPopup',   emits: ['openUploadModal'],   components: {     WarningIcon   },   props: {     canceled: Number,     errored: Number,     successed: Number   },   setup(props, { emit }) {     const { tc } = useTranslation()      const isPlural = (count: number | undefined) => {       return (count ?? 0) > 1 ? 's' : ''     }     // 1 fichier déposé, 2 fichiers en erreur, 6 fichiers abandonnés     let descriptions: string[] = []      if (props.successed !== 0)       descriptions.push(         `${props.successed} fichier${isPlural(           props.successed         )} déposé${isPlural(props.successed)} correctement`       )     if (props.errored !== 0)       descriptions.push(         `${props.errored} fichier${isPlural(props.errored)} en erreur`       )      if (props.canceled !== 0)       descriptions.push(         `${props.canceled} fichier${isPlural(           props.canceled         )} abandonné${isPlural(props.canceled)}`       )      let description = descriptions[0]      if (descriptions.length === 3) {       description = description.concat(', ', descriptions[1])     }      if (descriptions.length !== 1) {       description = description.concat(         ' et ',         descriptions[descriptions.length - 1]       )     }      const labelBtn = computed(() =>       tc('ged.dataManipulation.upload.notification.failUploadPopup.btn')     )      return {       openModal: () => emit('openUploadModal'),       labelBtn,       description     }   } }) </script>","describe('FailedUploadPopup', () => {   beforeEach(() => {     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('rendering', () => {     it('When all values > 0(plural) should display correct message', async () => {       const wrapper = createWrapper({ canceled: 9, errored: 5, successed: 10 })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe(         '10 fichiers déposés correctement, 5 fichiers en erreur et 9 fichiers abandonnés'       )     })      it('When all values == 1 (singular) should display correct message', async () => {       const wrapper = createWrapper({         canceled: 1,         errored: 1,         successed: 1       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe(         '1 fichier déposé correctement, 1 fichier en erreur et 1 fichier abandonné'       )     })      it('When canceled==0 should not display cancel messages', async () => {       const wrapper = createWrapper({         canceled: 0,         errored: 5,         successed: 10       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe(         '10 fichiers déposés correctement et 5 fichiers en erreur'       )     })      it('When errored==0 should not display errored messages', async () => {       const wrapper = createWrapper({         canceled: 9,         errored: 0,         successed: 10       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe(         '10 fichiers déposés correctement et 9 fichiers abandonnés'       )     })      it('When successed==0 should not display successed messages', async () => {       const wrapper = createWrapper({         canceled: 9,         errored: 5,         successed: 0       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe(         '5 fichiers en erreur et 9 fichiers abandonnés'       )     })      it('When only one value should display correct message', async () => {       const wrapper = createWrapper({         canceled: 9,         errored: 0,         successed: 0       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe('9 fichiers abandonnés')     })   })   describe('events', () => {     it('Should trigger openUploadModal event ', async () => {       const wrapper = createWrapper({         canceled: 9,         errored: 5,         successed: 10       })       const btn = wrapper.find('.open-upload-modal-cta')        await btn.trigger('click')       expect(wrapper.emitted('openUploadModal')).toBeTruthy()     })   }) }) "
"<template>   <in-progress-upload-popup     :loading=""loading""     v-if=""displayInProgress""     :total=""total""     :running=""treated""   />   <success-upload-popup v-else-if=""displaySuccess"" :successed=""successed"" />   <failed-upload-popup     v-else     :canceled=""canceled""     :errored=""errored""     :successed=""successed""   /> </template>  <script lang=""ts""> import { defineComponent, computed, PropType, watch } from 'vue' import InProgressUploadPopup from '@/modules/DataManipulation/Upload/components/Notification/InProgressUploadPopup.vue' import SuccessUploadPopup from '@/modules/DataManipulation/Upload/components/Notification/SuccessUploadPopup.vue' import FailedUploadPopup from '@/modules/DataManipulation/Upload/components/Notification/FailedUploadPopup.vue' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload'  export default defineComponent({   name: 'MainUploadPopup',   props: {     loading: Boolean,     duration: Number,     files: Array as PropType<FileUpload[]>   },   components: {     InProgressUploadPopup,     SuccessUploadPopup,     FailedUploadPopup   },   setup(props, { emit }) {     watch(       () => props.files,       () => {         if (props.files?.every((f) => f.uploaded())) {           setTimeout(() => {             emit('close')           }, props.duration)         }       },       {         deep: true       }     )      return {       displayInProgress: computed(() =>         props.files?.some((f) => f.running() || f.pending())       ),       cancelUploadHandler: () => emit('cancelUpload'),       displaySuccess: computed(() => props.files?.every((f) => f.uploaded())),       total: computed(() => props.files?.length),       treated: computed(() => props.files?.filter((f) => f.finished()).length),       canceled: computed(() => props.files?.filter((f) => f.canceled()).length),       errored: computed(() => props.files?.filter((f) => f.error()).length),       successed: computed(() => props.files?.filter((f) => f.uploaded()).length)     }   } }) </script>","describe('InProgressUploadPopup', () => {   describe('binding', () => {     it('Should bind correct values and display in-progress when files are running and loading true', () => {       const wrapper = createWrapper({         loading: true,         duration: 1000,         files: filesProgressCase       })       const inProgressUploadPopupWrapper = wrapper.findComponent(         InProgressUploadPopup       )        expect(inProgressUploadPopupWrapper.props('total')).toBe(3)       expect(inProgressUploadPopupWrapper.props('running')).toBe(1)       expect(inProgressUploadPopupWrapper.props('loading')).toBe(true)     })      it('Should bind correct values and display success popup', () => {       const wrapper = createWrapper({         loading: true,         duration: 1000,         files: filesSuccessCase       })       const successUploadPopupWrapper =         wrapper.findComponent(SuccessUploadPopup)        expect(successUploadPopupWrapper.props('successed')).toBe(3)     })      it('Should bind correct values and display failed popup', () => {       const wrapper = createWrapper({         loading: true,         duration: 1000,         files: filesFailedCase       })       const failedUploadPopupWrapper = wrapper.findComponent(FailedUploadPopup)        expect(failedUploadPopupWrapper.props('errored')).toBe(1)       expect(failedUploadPopupWrapper.props('canceled')).toBe(1)       expect(failedUploadPopupWrapper.props('successed')).toBe(1)     })      it('Should run function after duration when all files uploaded', async () => {       jest.useFakeTimers()       const duration = 1000       const wrapper = createWrapper({         loading: true,         duration: duration,         files: filesProgressCase       })        wrapper.setProps({ files: filesSuccessCase })       await wrapper.vm.$nextTick()        expect(setTimeout).toHaveBeenLastCalledWith(         expect.any(Function),         duration       )     })   }) }) "
"<template>   <div class=""success-container"">     <div class=""icon-zone""><i class=""el-icon-check""></i></div>     <div class=""main-content-zone"">       <p class=""description"">Import fini</p>       <p class=""sub-description"">{{ subDescription }}</p>     </div>     <div class=""actions-zone"">       <i class=""el-icon-circle-close close-icon"" @click=""closeHandler""></i>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' export default defineComponent({   name: 'SuccessUploadPopup',   props: {     successed: Number   },   setup(props, { emit }) {     const isPlural = (count: number | undefined, char: string) => {       return (count ?? 0) > 1 ? char : ''     }      return {       subDescription: `${props.successed} nouveau${isPlural(         props.successed,         'x'       )} fichier${isPlural(props.successed, 's')} déposé${isPlural(         props.successed,         's'       )} correctement`,       closeHandler: () => emit('close')     }   } }) </script>","describe('SuccessUploadPopup', () => {   describe('binding', () => {     it('Should fire close event when button is clicked', () => {       const wrapper = createWrapper({ successed: 10 })       const iWrapper = wrapper.find('.close-icon')        iWrapper.trigger('click')       expect(wrapper.emitted('close')).toBeTruthy()       expect(wrapper.emitted('close')).toHaveLength(1)     })   })   describe('rendering', () => {     it('When successed value > 0 (plural) should display correct message', async () => {       const wrapper = createWrapper({ successed: 10 })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe('10 nouveaux fichiers déposés correctement')     })      it('When successed value == 1 (singular) should display correct message', async () => {       const wrapper = createWrapper({         successed: 1       })       const pWrapper = wrapper.find('.sub-description')        expect(pWrapper.text()).toBe('1 nouveau fichier déposé correctement')     })   }) }) "
"<template>   <div class=""folder-info-box-container"">     <div class=""text-part-1"">       <p>{{ canUploaddescription }}</p>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import constants from '@/Common/constants'  export default defineComponent({   name: 'FolderInfoBox',   components: {},   props: {     canUpload: {       type: Boolean,       required: true     },     folderName: { type: String, required: true },     folderDescription: { type: String, required: true }   },   setup(props) {     return {       constants,       canUploaddescription: computed(() => {         return `${           props.canUpload             ? constants.CAN_ADD_FILE_DESCRIPTION             : constants.CAN_NOT_ADD_FILE_DESCRIPTION         } ${props.folderName ?? ''}. ${props.folderDescription ?? ''}`       })     }   } }) </script>","describe('FolderInfoBox', () => {   describe('binding', () => {     it('Should bind properties correctly', () => {       const wrapper = createWrapper(         data.folderName,         data.canUpload,         data.folderDescription       )        expect(wrapper.props('folderName')).toEqual(data.folderName)       expect(wrapper.props('canUpload')).toEqual(data.canUpload)       expect(wrapper.props('folderDescription')).toEqual(data.folderDescription)     })   })   describe('rendering', () => {     it('should display can upload file description when permission is granted ', () => {       const wrapper = createWrapper(         data.folderName,         data.canUpload,         data.folderDescription       )       const descriptionWrapper = wrapper.find('.text-part-1 > p')       expect(descriptionWrapper.text()).toStrictEqual(         `${constants.CAN_ADD_FILE_DESCRIPTION} ${data.folderName}. ${data.folderDescription}`       )     })     it('should display can not upload file description when permission is not granted ', () => {       const wrapper = createWrapper(         data.folderName,         false,         data.folderDescription       )       const descriptionWrapper = wrapper.find('.text-part-1 > p')       expect(descriptionWrapper.text()).toStrictEqual(         `${constants.CAN_NOT_ADD_FILE_DESCRIPTION} ${data.folderName}. ${data.folderDescription}`       )     })   }) }) "
"<template>   <div class=""in-progress-container"">     <div class=""icon-zone""><document-icon :src=""UploadWidgetSvg"" /></div>     <div class=""main-content-zone"">       <p class=""description"">         Import en cours - <span class=""primary"">{{ running }}/{{ total }}</span>       </p>       <progress :max=""total"" :value=""running""></progress>     </div>     <div class=""actions-zone"">       <loading-icon v-if=""loading"" />        <input         v-else         type=""button""         class=""cancel-action""         value=""Annuler""         @click=""cancelHandler""       />     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DocumentIcon from '@/Common/components/Icons/DocumentIcon.vue' import UploadWidgetSvg from '@/assets/Icons/UploadWidget.svg' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue'  export default defineComponent({   name: 'InProgressUploadPopup',   components: {     LoadingIcon,     DocumentIcon   },   props: {     total: Number,     running: Number,     loading: Boolean   },   setup(props, { emit }) {     return {       cancelHandler: () => emit('cancelUpload'),       UploadWidgetSvg     }   } }) </script>","describe('InProgressUploadPopup', () => {   describe('binding', () => {     it('Should fire cancel event when cancel button is clicked', () => {       const wrapper = createWrapper({ loading: false, total: 10, running: 5 })       const iWrapper = wrapper.find('.cancel-action')        iWrapper.trigger('click')       expect(wrapper.emitted('cancelUpload')).toBeTruthy()       expect(wrapper.emitted('cancelUpload')).toHaveLength(1)     })   })   describe('rendering', () => {     it('Should display loader when loading is true', () => {       const wrapper = createWrapper({ loading: true, total: 10, running: 5 })        expect(wrapper.findComponent(LoadingIcon)).toBeTruthy()     })     it('Should display correct messages', async () => {       const wrapper = createWrapper({ loading: false, total: 10, running: 5 })       const pWrapper = wrapper.find('.description')        expect(pWrapper.text()).toBe('Import en cours - 5/10')     })      it('Should display correct progress bar level', async () => {       const wrapper = createWrapper({ loading: false, total: 10, running: 5 })       const progressWrapper = wrapper.find('progress')        expect(progressWrapper.attributes('max')).toBe('10')       expect(progressWrapper.attributes('value')).toBe('5')     })   }) }) "
"<template>   <natto-dialog-popup     :title=""title""     :description=""description""     :popup-type=""popupType""     :modelValue=""isOpened""     @confirm-clicked=""eventHandle('confirm-clicked')""     @cancel-clicked=""eventHandle('cancel-clicked')""   /> </template>  <script lang=""ts""> import NattoDialogPopup from '@/Common/components/Modals/NattoDialogPopup.vue' import { defineComponent } from 'vue' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'MessagePopup',   components: {     NattoDialogPopup   },   props: {     title: {       type: String     },     description: {       type: String     },     popupType: {       type: String     }   },   emits: ['confirm-clicked', 'cancel-clicked'],   setup(props, { emit }) {     const isOpened = useVModel(props)      const eventHandle = (type: string) => {       const eventType = type as 'confirm-clicked' | 'cancel-clicked'        emit(eventType)     }      return {       isOpened,       eventHandle     }   } }) </script>","describe('MessagePopup', () => {   describe('bindings', () => {     describe('props', () => {       it('Should pass title props without changes', () => {         const wrapper = createWrapper(           ""I'am a title"",           ""I'am a description"",           'error'         )         const nattoDialogPopupWrapper: VueWrapper<any> =           wrapper.findComponent(NattoDialogPopup)          expect(nattoDialogPopupWrapper.props().title).toBe(""I'am a title"")       })        it('Should pass description props without changes', () => {         const wrapper = createWrapper(           ""I'am a title"",           ""I'am a description"",           'error'         )         const nattoDialogPopupWrapper: VueWrapper<any> =           wrapper.findComponent(NattoDialogPopup)          expect(nattoDialogPopupWrapper.props().description).toBe(           ""I'am a description""         )       })        it('Should pass popupType props without changes', () => {         const wrapper = createWrapper(           ""I'am a title"",           ""I'am a description"",           'error'         )         const nattoDialogPopupWrapper: VueWrapper<any> =           wrapper.findComponent(NattoDialogPopup)          expect(nattoDialogPopupWrapper.props().popupType).toBe('error')       })     })   })   describe('events', () => {     it(""Should fire 'cancel-clicked' when cancel button is clicked"", () => {       const wrapper = createWrapper(         ""I'am a title"",         ""I'am a description"",         'error'       )       const nattoDialogPopupWrapper: VueWrapper<any> =         wrapper.findComponent(NattoDialogPopup)        nattoDialogPopupWrapper.vm.$emit('cancel-clicked')        expect(wrapper.emitted('cancel-clicked')).toBeTruthy()       expect(wrapper.emitted('cancel-clicked')).toHaveLength(1)     })      it(""Should fire 'confirm-clicked' when confirm button is clicked"", () => {       const wrapper = createWrapper(         ""I'am a title"",         ""I'am a description"",         'error'       )       const nattoDialogPopupWrapper: VueWrapper<any> =         wrapper.findComponent(NattoDialogPopup)        nattoDialogPopupWrapper.vm.$emit('confirm-clicked')        expect(wrapper.emitted('confirm-clicked')).toBeTruthy()       expect(wrapper.emitted('confirm-clicked')).toHaveLength(1)     })   }) }) "
"<template>   <natto-upload-type-popup     v-model=""isOpened""     :folders=""folders""     @popup-folder-select-close=""handleClose""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useVModel from '@/Common/hooks' import NattoUploadTypePopup from '@/Common/components/Modals/NattoUploadTypePopup.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders'  export default defineComponent({   name: 'WhoUploadModal',   components: {     NattoUploadTypePopup   },   props: {     modelValue: Boolean,     folders: {       type: Folders,       required: true     }   },   emits: ['popup-folder-select-close', 'update:modelValue'],   setup(props, { emit }) {     const isOpened = useVModel(props)      const handleClose = () => {       emit('popup-folder-select-close')     }      return { isOpened, handleClose }   } }) </script>","describe('WhoUploadModal', () => {   describe('binding', () => {     beforeEach(() => {       wrapper = wrapper = createWrapper(         Folders.loaded([           {             id: 1122,             name: 'Comptabilité',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           },           {             id: 1233,             name: 'Gestion Sociale',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           }         ]),         true       )     })     describe('props', () => {       it('Should bind correctly the folders prop', () => {         const NattoUploadTypePopupWrapper =           wrapper.findComponent(NattoUploadTypePopup)          expect(NattoUploadTypePopupWrapper.props('folders')).toStrictEqual(           wrapper.vm.folders         )       })       it('Should bind correctly the modelValue prop', () => {         const NattoUploadTypePopupWrapper =           wrapper.findComponent(NattoUploadTypePopup)          expect(NattoUploadTypePopupWrapper.props('modelValue')).toEqual(           wrapper.vm.modelValue         )       })     })   })   describe('events', () => {     it('Should emit popup-folder-select-close when NattoUploadTypePopup emit popup-folder-select-close', async () => {       const NattoUploadTypePopupWrapper =         wrapper.findComponent(NattoUploadTypePopup)        await NattoUploadTypePopupWrapper.vm.$emit('popup-folder-select-close')       expect(wrapper.emitted('popup-folder-select-close')).toBeTruthy()     })   }) }) "
"<template>   <natto-upload-modal     v-model=""isDocumentUploadModalOpened""     :triggerUploadAllFiles=""triggerUploadAllFiles""     :secondaryCtaFolderName=""secondaryCtaFolderName""     :selectedFileIndex=""selectedFileIndex""     :primaryCtaAction=""modalNextAction""     :selectedFolderToUpload=""selectedFolder""     :files=""files""     :disabledCategories=""disabledCategories""     @display-file=""displayFileHandler""     @validate=""validateHandler""     @on-modal-close=""handleModalClose""     @secondary-click=""allFileSameFolderHandler""     @change-selected-folderId=""dispatchSetSelectedFolderToUpload""   /> </template>  <script lang=""ts""> import { defineComponent, ref, computed, watch } from 'vue' import NattoUploadModal from '@/Common/components/Modals/NattoUploadModal.vue' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import useVModel from '@/Common/hooks' import { useStore } from 'vuex' import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import useUploadFilesMethod from '@/modules/DataManipulation/Upload/hooks/uploadFilesMethod'  export default defineComponent({   name: 'DocumentsUploadModal',   components: {     NattoUploadModal   },   props: {     disabledCategories: {       type: Boolean,       default: false     },     modelValue: {       type: Boolean,       required: true     },     triggerUploadAllFiles: {       type: Boolean,       default: false     }   },   setup(props, { emit }) {     const store = useStore()      const isDocumentUploadModalOpened = useVModel(props)     let selectedFileIndex = ref(0)      const { setSelectedFolderToUpload, selectedFolderToUpload, getFiles } =       useUploadStoreHelpers()      const { uploadAllFilesInSameFolder, uploadOneFile } = useUploadFilesMethod()      const { folders, searchFolderId } = useSearchStoreHelpers()      watch(isDocumentUploadModalOpened, (newVal) => {       if (newVal) {         if (getFiles(store).value.length > 0) {           trackEventFactory(             analyticsCode['updm-select-destination-file-upload'],             getFiles(store).value.length           )         }          for (let index = 0; index < getFiles(store).value.length; index++) {           trackEventFactory(             analyticsCode['updm-select-destination-file-format'],             getFiles(store).value[index].getFileExtension()           )         }       }     })      const allFileSameFolderHandler = async () => {       trackEventFactory(         analyticsCode['updm-select-destination-file-validate-all']       )        const setSelectedFileIndexToLastFile = () => {         selectedFileIndex.value = getFiles(store).value.length - 1       }        await uploadAllFilesInSameFolder(setSelectedFileIndexToLastFile)     }      const validateHandler = async () => {       trackEventFactory(         analyticsCode['updm-select-destination-file-validate-one']       )        await uploadOneFile(selectedFileIndex.value)        if (selectedFileIndex.value < getFiles(store).value.length - 1) {         selectedFileIndex.value++       }     }      const displayFileHandler = (index: number) => {       selectedFileIndex.value = index       if (getFiles(store).value[index].destination) {         setSelectedFolderToUpload(           store,           getFiles(store).value[index]?.destination ?? 0         )       }     }      const handleModalClose = async () => {       selectedFileIndex.value = 0       emit('reset')     }      watch(       () => props.triggerUploadAllFiles,       () => {         if (props.triggerUploadAllFiles) {           allFileSameFolderHandler()         }       }     )      watch(       searchFolderId(store),       (value) => {         setSelectedFolderToUpload(store, value)       },       { immediate: true }     )      return {       default: 'Destination du fichier selectionné',       selectedFileIndex,       secondaryCtaFolderName: computed(         () =>           folders(store).value.getFolderById(             selectedFolderToUpload(store).value           )?.name ?? ''       ),       isDocumentUploadModalOpened,       validateHandler,       handleModalClose,       displayFileHandler,       selectedFolder: computed(         () =>           getFiles(store).value[selectedFileIndex.value]?.destination ??           selectedFolderToUpload(store).value       ),       allFileSameFolderHandler,       files: getFiles(store),       modalNextAction: computed(() => {         if (getFiles(store).value.some((f: FileUpload) => f?.ready())) {           if (selectedFileIndex.value < getFiles(store).value.length - 1) {             return 'validateNext'           } else {             return 'validate'           }         } else {           return 'finish'         }       }),       dispatchSetSelectedFolderToUpload: (         newselectedFolderToUpload: number       ) => {         trackEventFactory(           analyticsCode['updm-select-destination-file-level'],           folders(store).value.getFolderDeepLevel(newselectedFolderToUpload)         )          setSelectedFolderToUpload(store, newselectedFolderToUpload)       }     }   } }) </script>","describe('documents-upload-modal', () => {   beforeEach(() => {     storeMock.state.GED.DataManipulation.Upload.files = files     wrapper = createWrapper(false)     nattoUploadModalWrapper = findNattoUploadModal(wrapper)     storeMock.dispatch = jest.fn()   })    afterEach(() => {     jest.clearAllMocks()   })    describe('binding', () => {     describe('watch', () => {       it('When isDocumentUploadModalOpened changed should trace log if new value true', async () => {         await wrapper.setProps({ modelValue: true })         await wrapper.vm.$nextTick()          expect(trackEventFactory).toHaveBeenNthCalledWith(           1,           'updm-select-destination-file-upload',           4         )         expect(trackEventFactory).toHaveBeenNthCalledWith(           2,           'updm-select-destination-file-format',           'txt'         )         expect(trackEventFactory).toHaveBeenNthCalledWith(           3,           'updm-select-destination-file-format',           'txt'         )       })     })     describe('props', () => {       it('Should bind files value with child component', () => {         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('files')).toHaveLength(           wrapper.vm.files.length         )         expect(NattoUploadModalWrapper.props('files')).toStrictEqual(           wrapper.vm.files         )       })       it('Should init selectedFolderToUpload value with searchFolderId', async () => {         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('selectedFolderToUpload')).toEqual(           4521         )       })       it('primaryCtaAction Should be validateNext when there is some files ready and selected file is not last item', () => {         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('primaryCtaAction')).toEqual(           'validateNext'         )       })       it('primaryCtaAction Should be validate when there is some files ready and selected file is last item', () => {         storeMock.state.GED.DataManipulation.Upload.files = [           new FileUpload(             new File([''], 'file1.txt', { type: 'text/html' }),             StateUpload.TO_UPLOAD           )         ]          const wrapper = createWrapper(false)         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('primaryCtaAction')).toEqual(           'validate'         )       })       it('primaryCtaAction Should be finish when all files are not ready', () => {         storeMock.state.GED.DataManipulation.Upload.files = [           new FileUpload(             new File([''], 'file1.txt', { type: 'text/html' }),             StateUpload.UPLOADED           ),           new FileUpload(             new File([''], 'file2.txt', { type: 'text/html' }),             StateUpload.ERROR           ),           new FileUpload(             new File([''], 'file3.txt', { type: 'text/html' }),             StateUpload.UPLOADING           )         ]          const wrapper = createWrapper(false)         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('primaryCtaAction')).toEqual(           'finish'         )       })       it('Should bind disabledCategories value with child component', () => {         const NattoUploadModalWrapper = wrapper.findComponent(NattoUploadModal)          expect(NattoUploadModalWrapper.props('disabledCategories')).toEqual(           wrapper.vm.disabledCategories         )       })       describe('events', () => {         it('Should dispatch setSelectedFolderToUpload when change-selected-folderId is emitted', async () => {           await nattoUploadModalWrapper.vm.$emit('change-selected-folderId', 27)            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/DataManipulation/Upload/setSelectedFolderToUpload',             27           )         })         it('Should dispatch setSelectedFolderToUpload when searchFolderId changes', async () => {           storeMock.state.GED.Search.filters.folderId = 27            await wrapper.vm.$nextTick()            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/DataManipulation/Upload/setSelectedFolderToUpload',             27           )         })         it('Should dispatch setFileDestination action when validate event is emitted', async () => {           const NattoUploadModalWrapper =             wrapper.findComponent(NattoUploadModal)            await NattoUploadModalWrapper.vm.$emit('validate')            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/DataManipulation/Upload/setFileDestination',             { index: 0, destinationId: 4521 }           )         })         it('Should emit reset event when on-modal-close event is emitted', async () => {           const NattoUploadModalWrapper =             wrapper.findComponent(NattoUploadModal)            await NattoUploadModalWrapper.vm.$emit('on-modal-close')           expect(wrapper.emitted('reset')).toBeTruthy()         })         it('Should dispatch setFileState action when secondary-click event is emitted', async () => {           const NattoUploadModalWrapper =             wrapper.findComponent(NattoUploadModal)            await NattoUploadModalWrapper.vm.$emit('secondary-click')           // Should not send index 0 because status is uploading           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             'GED/DataManipulation/Upload/setFileDestination',             { destinationId: 4521, index: 1 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             'GED/DataManipulation/Upload/setFileState',             { error: undefined, fileState: 1, index: 1 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             3,             'GED/DataManipulation/Upload/setFileDestination',             { destinationId: 4521, index: 2 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             4,             'GED/DataManipulation/Upload/setFileState',             { error: undefined, fileState: 1, index: 2 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             5,             'GED/DataManipulation/Upload/setFileDestination',             { destinationId: 4521, index: 3 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             6,             'GED/DataManipulation/Upload/setFileState',             { error: undefined, fileState: 1, index: 3 }           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             7,             'GED/DataManipulation/Upload/uploadDocuments',             [1, 2, 3]           )           await flushPromises()           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             8,             'GED/Search/fetchDocuments'           )         })       })     })   }) }) "
"<template>   <div class=""file-item"" :class=""{ selected }"">     <document-upload-state-icon :status=""file.state"" class=""flex-item"" />     <filename-text :filename=""file.file.name"" class=""flex-item"" />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import FilenameText from '@/Common/components/Text/FilenameText.vue' import DocumentUploadStateIcon from '@/modules/Search/components/DocumentUploadStateIcon.vue' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload'  export default defineComponent({   name: 'UploadFileListItem',   components: {     FilenameText,     DocumentUploadStateIcon   },   props: {     file: {       type: FileUpload,       required: true     },     selected: Boolean   } }) </script>","describe('UploadFileListItem', () => {   describe('bindings', () => {     it('div should have 1 class when send selected false props', () => {       const wrapper = createWrapper(file, false)       const divWrapper: DOMWrapper<HTMLDivElement>[] = wrapper.findAll('div')        expect(divWrapper.length).toBe(1)       expect(divWrapper[0].classes()).toHaveLength(1)       expect(divWrapper[0].classes()[0]).toBe('file-item')     })      it('div class should contains 2 class when send selected true props', () => {       const wrapper = createWrapper(file, true)       const divWrapper: DOMWrapper<HTMLDivElement>[] = wrapper.findAll('div')        expect(divWrapper.length).toBe(1)       expect(divWrapper[0].classes()).toHaveLength(2)       expect(divWrapper[0].classes()[0]).toBe('file-item')       expect(divWrapper[0].classes()[1]).toBe('selected')     })   })   describe('rendering', () => {     describe('props', () => {       it('Should display FilenameText and DocumentUploadStateIcon when send file and selected props', () => {         const wrapper = createWrapper(file, false)         const textWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(FilenameText)         const icontWrappper: VueWrapper<any>[] = wrapper.findAllComponents(           DocumentUploadStateIcon         )          expect(textWrappper).toHaveLength(1)         expect(textWrappper[0].vm.filename).toEqual('Mock.zip')          expect(icontWrappper).toHaveLength(1)         expect(icontWrappper[0].vm.status).toEqual(StateUpload.UPLOADED)       })     })   }) }) "
"<template>   <el-scrollbar height=""384px"" always=""true"" native=""true"">     <upload-file-list-item       v-for=""(item, index) in files""       :key=""item.file.name""       :selected=""index === selectedFileIndex""       :file=""item""       @click=""fileItemClicked(index)""     />   </el-scrollbar> </template>  <script lang=""ts""> import { defineComponent, PropType } from 'vue' import UploadFileListItem from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Content/UploadFileListItem.vue' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload'  export default defineComponent({   name: 'UploadFileList',   components: {     UploadFileListItem   },   props: {     selectedFileIndex: {       type: Number,       default: 0     },     files: {       type: Array as PropType<FileUpload[]>,       required: true     }   },   emits: ['display-file'],    setup(props, { emit }) {     const fileItemClicked = (selectedFileIndex: number) => {       emit('display-file', selectedFileIndex)     }      return {       fileItemClicked     }   } }) </script>","describe('UploadFileList', () => {   describe('bindings', () => {     describe('events', () => {       it('Should fire display-file event and change fileSelected data when click event is fired', () => {         const wrapper = createWrapper(files)         const itemWrappper: VueWrapper<any> =           wrapper.findComponent(UploadFileListItem)          itemWrappper.vm.$emit('click', 27)         expect(wrapper.emitted()['display-file']).toBeTruthy()         expect(wrapper.emitted()['display-file']).toHaveLength(1)         expect(wrapper.emitted()['display-file'][0]).toStrictEqual([0])       })     })   })   describe('rendering', () => {     it('Should display item when send files props', async () => {       const wrapper = createWrapper(files)       const itemWrappper: VueWrapper<any>[] =         wrapper.findAllComponents(UploadFileListItem)        expect(itemWrappper).toHaveLength(2)       expect(itemWrappper[0].vm.file).toEqual(file)       expect(itemWrappper[0].vm.selected).toEqual(true)       expect(itemWrappper[1].vm.file).toEqual(file2)       expect(itemWrappper[1].vm.selected).toEqual(false)     })   }) }) "
"<template>   <div     class=""upload-breadcrumb-container""     :class=""disabledBreadcrumb ? 'upload-breadcrumb-disabled' : ''""   >     <div       v-show=""breadcrumbs?.length > 0 && !disabledBreadcrumb""       class=""upload-breadcrumb-element arrow-left-icon""       @click=""handleGoBack""     >       <arrow-left-icon />     </div>     <natto-breadcrumb       ellipsed       :disabledBreadcrumbs=""disabledBreadcrumb""       :breadcrumbs=""breadcrumbs""       @breadcrumb-click=""handleBreadcrumbFolderSelected""       class=""upload-breadcrumb-element""     />   </div> </template>  <script lang=""ts""> import { defineComponent, watch } from 'vue' import ArrowLeftIcon from '@/Common/components/Icons/ArrowLeftIcon.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import useBreadcrumbHelpers from '@/Common/hooks/useBreadcrumbHelpers' import NattoBreadcrumb from '@/Common/components/Breadcrumb/NattoBreadcrumb.vue' import { BreadcrumbItem } from '@/Common/types/common'  export default defineComponent({   name: 'UploadBreadcrumb',   components: {     NattoBreadcrumb,     ArrowLeftIcon   },   props: {     selectedFolderToUpload: Number,     disabledBreadcrumb: Boolean,     folders: {       type: Folders,       required: true     }   },   emits: ['update:selectedFolderToUpload'],   setup(props) {     const { state, goBack, selectBreadcrumb } = useBreadcrumbHelpers({       folders: props.folders,       selectedFolder: props.selectedFolderToUpload,       propName: 'selectedFolderToUpload'     })      state.breadcrumbs.unshift({ id: 0, text: 'GED' } as BreadcrumbItem)      const handleGoBack = () => {       if (props.disabledBreadcrumb) {         return       }       goBack()     }      const handleBreadcrumbFolderSelected = (id: number, emitEvent: boolean) => {       selectBreadcrumb(id, emitEvent)     }      watch([() => props.selectedFolderToUpload], () => {       handleBreadcrumbFolderSelected(props.selectedFolderToUpload ?? 0, false)     })      return {       handleBreadcrumbFolderSelected: (id: number) =>         handleBreadcrumbFolderSelected(id, true),       breadcrumbs: state.breadcrumbs,       handleGoBack     }   } }) </script>","describe('UploadBreadcrumb', () => {   beforeEach(() => {     nattoBreadcrumbWrapper = findNattoBreadcrumb(wrapper)   })   describe('rendering', () => {     const disabledCases = [       { disabledBreadcrumb: true, disabledClassExists: true },       { disabledBreadcrumb: false, disabledClassExists: false }     ]      it.each(disabledCases)(       `Should have/not have upload-breadcrumb-disabled when disabledBreadcrumbs is $disabledBreadcrumb`,       ({ disabledBreadcrumb, disabledClassExists }) => {         // Given disabledCrumbs is $disabledBreadcrumbs         wrapper = createWrapper({ ...defaultProps, disabledBreadcrumb })          // Then         const uploadBreadcrumbContainerWrapper: DOMWrapper<HTMLDivElement> =           wrapper.find('.upload-breadcrumb-container')          expect(           uploadBreadcrumbContainerWrapper             .classes()             .includes('upload-breadcrumb-disabled')         ).toBe(disabledClassExists)       }     )   })   describe('bindings with arrow-left-icon', () => {     it(       'When click on arrow-left-icon, ' +         'Then last breadcrumbItem must be removed and update:selectedFolderToUpload must be emitted with last breadcrumbItem.id as payload',       async () => {         // When click on arrow-left-icon         const arrowLeftIconWrapper: DOMWrapper<HTMLDivElement> =           wrapper.find('.arrow-left-icon')          await arrowLeftIconWrapper.trigger('click')          // Then         expect(nattoBreadcrumbWrapper.vm.breadcrumbs).toStrictEqual([           { id: 0, text: 'GED' },           { id: 1122, text: 'A classer' }         ])         expect(nattoBreadcrumbWrapper.vm.ellipsed).toStrictEqual(true)         expect(wrapper.emitted('update:selectedFolderToUpload'))       }     )   })   describe('click on breadcrumbItem', () => {     it('when selectedFolderToUpload prop changes, it must add the related breadcrumb item', async () => {       // Given selectedFolderToUpload is set to 0       wrapper = createWrapper()        // When selectedFolderToUpload is set to the folder 2705 (name: The grandson)       await wrapper.setProps({ selectedFolderToUpload: 2705 })        // Then a breadcrumbItem must be added with 2705 folder information       expect(wrapper.vm.breadcrumbs).toStrictEqual([         { id: 0, text: 'GED' },         { id: 1122, text: 'A classer' },         { id: 1001, text: 'The child' },         { id: 2705, text: 'The grandson' }       ])       expect(wrapper.emitted('update:selectedFolderToUpload')).toBeFalsy()     })   }) }) "
"<template>   <div class=""documents-folders-creation-container"">     <div class=""create-folder-button"" v-if=""!showForm"">       <natto-button @click=""$emit('on-folder-creation-cta-click')"">         <div class=""btn-container"">           <div class=""btn-icon"">             <natto-icon :elementName=""'folder-add'"" />           </div>           <div class=""btn-text"">Nouveau dossier</div>         </div>       </natto-button>     </div>     <div class=""form"">       <natto-create-folder-form         v-if=""showForm""         :showForm=""showForm""         :placeholder=""'Entrer un nom de dossier'""         :selectedFolderId=""selectedFolderId""         :creation-folder-error=""creationFolderError""         @create-folder-click=""$emit('on-create-folder', $event)""         @cancel-create-folder-click=""$emit('on-cancel-create-folder')""       />     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoButton from '@/Common/components/Buttons/NattoButton.vue' import NattoCreateFolderForm from '@/modules/DataManipulation/Create/CreateFolder/components/NattoCreateFolderForm.vue' import NattoIcon from '@/Common/components/Icons/NattoIcon.vue'  export default defineComponent({   name: 'DocumentsFoldersCreation',   emits: ['on-folder-creation-cta-click'],   props: {     showForm: Boolean,     selectedFolderId: Number,     disabled: Boolean,     creationFolderError: String   },   components: {     NattoButton,     NattoCreateFolderForm,     NattoIcon   } }) </script>","describe('documents-folders-creation', () => {   beforeEach(() => {     wrapper = createWrapper(1234, true, '')   })   describe('binding', () => {     describe('props', () => {       it('Should bind creationFolderError prop value correctly', () => {         wrapper = createWrapper(1234, true, 'error')          const NattoCreateFolderForWrapper = wrapper.findComponent(           NattoCreateFolderForm         )          expect(NattoCreateFolderForWrapper.vm.creationFolderError).toBe('error')       })       it('Should bind selectedFolderId prop value correctly', () => {         const NattoCreateFolderForWrapper = wrapper.findComponent(           NattoCreateFolderForm         )          expect(wrapper.props('selectedFolderId')).toBe(1234)         expect(wrapper.props('selectedFolderId')).toBe(           NattoCreateFolderForWrapper.props('selectedFolderId')         )       })       it('Should bind showForm prop value correctly', () => {         expect(wrapper.props('showForm')).toBe(true)       })     })     describe('events', () => {       it('Should emit on-folder-creation-cta-click when cta click', async () => {         wrapper = createWrapper(1234, false, '')         const NatooButtonWrapper = wrapper.findComponent(NattoButton)          await NatooButtonWrapper.trigger('click')         expect(wrapper.emitted('on-folder-creation-cta-click')).toBeTruthy()       })       describe('create-folder-click event', () => {         it('Should emit on-create-folder when  create-folder-click event is triggered', async () => {           const data = {             targetFolder: 1234,             folderName: 'hello'           }           const NattoCreateFolderForWrapper = wrapper.findComponent(             NattoCreateFolderForm           )            await NattoCreateFolderForWrapper.vm.$emit(             'create-folder-click',             data           )            expect(wrapper.emitted('on-create-folder')).toBeTruthy()         })         it('Should emit on-cancel-create-folder when cancel-create-folder-click event is triggered', async () => {           const NattoCreateFolderForWrapper = wrapper.findComponent(             NattoCreateFolderForm           )            await NattoCreateFolderForWrapper.vm.$emit(             'cancel-create-folder-click'           )           expect(wrapper.emitted('on-cancel-create-folder')).toBeTruthy()         })       })     })   })   describe('rendering', () => {     it('Should display create folder form when shoForm is true', () => {       expect(wrapper.findComponent(NattoCreateFolderForm).exists()).toBeTruthy()     })     it('Should not display create folder form when shoForm is false', () => {       wrapper = createWrapper(1234, false, '')       expect(wrapper.findComponent(NattoCreateFolderForm).exists()).toBeFalsy()     })   }) }) "
"<template>   <div class=""upload-infos-description"">     {{ description }}   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'UploadFileInfosDescription',    props: {     selectedFolderName: {       type: String,       required: true     }   },    setup(props) {     const { t } = useTranslation()      return {       description: t('ged.dataManipulation.create.file.collab.description', {         selectedFolderName: props.selectedFolderName       })     }   } }) </script>","describe('UploadFileInfosDescription', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('should render correct translation with parameter', () => {       expect(wrapper.text()).toContain(         'ged.dataManipulation.create.file.collab.description with {""selectedFolderName"":""Achat""}'       )     })   }) }) "
"<template>   <MpButton     class=""secondary-cta-btn""     size=""small""     btn-type=""default""     :disabled=""disabled""     @click=""$emit('click')""   >     {{ $t('ged.upload.uploadModal.uploadAll') }}{{ ` “${folderName}”` }}   </MpButton> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'SecondaryCtaButton',   props: {     folderName: {       type: String,       required: true     },     disabled: Boolean   },   emits: ['click'] }) </script>","describe('SecondaryCtaButton', () => {   describe('bindings', () => {     describe('props', () => {       it('Should pass label props when folderName props is passed', () => {         const wrapper = createWrapper('Achats')         const bWrapper: VueWrapper<any> = wrapper.findComponent(MpButton)          expect(bWrapper.text()).toStrictEqual(           'ged.upload.uploadModal.uploadAll “Achats”'         )         expect(bWrapper.props('disabled')).toBeFalsy()       })        it('Should pass disabled props when disabled props is passed', () => {         const wrapper = createWrapper('Achats', true)         const bWrapper: VueWrapper<any> = wrapper.findComponent(MpButton)          expect(bWrapper.props('disabled')).toBeTruthy()       })     })   })   describe('events', () => {     it(""Should fire 'clicked' when click-button is emitted"", () => {       const wrapper = createWrapper('Achats')       const bWrapper: VueWrapper<any> = wrapper.findComponent(MpButton)        bWrapper.trigger('click')        expect(wrapper.emitted()['click'].length).toBe(1)     })   }) }) "
"<template>   <natto-primary-cta :action=""action"" :disabled=""disabled"" /> </template>  <script lang=""ts""> import NattoPrimaryCta from '@/Common/components/Buttons/NattoPrimaryCta.vue' import { defineComponent } from 'vue' export default defineComponent({   name: 'DocumentPrimaryCta',   components: { NattoPrimaryCta },   props: {     disabled: Boolean,     action: String   } }) </script>","describe('document-primary-cta', () => {   describe('events', () => {     describe('validate', () => {       // it('Should emit validate event', async () => {       //   const wrapper = createWrapper('validateNext', false)       //   const button: DOMWrapper<any> = wrapper.find('.natto-primary-cta')       //   await button.trigger('click')       //   expect(wrapper.emitted('validate')).toBeTruthy()       // })     })   })   describe('binding', () => {     describe('validate', () => {       it('Should have teh same value ', () => {         const wrapper = createWrapper('validateNext', false)          expect(wrapper.vm.action).toEqual('validateNext')         expect(wrapper.vm.disabled).toEqual(false)       })     })   }) }) "
"<template>   <natto-folders-browser     :folders=""browserFolders""     :height=""height""     :disabled=""disabled""     @browser-folder-selected=""browse""   >     <template #actions>       <natto-icon element-name=""arrow-right"" />     </template>   </natto-folders-browser> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import NattoFoldersBrowser from '@/Common/components/Navigation/NattoFoldersBrowser.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import NattoIcon from '@/Common/components/Icons/NattoIcon.vue'  export default defineComponent({   name: 'UploadDocumentNavigator',   props: {     folders: {       type: Folders,       required: true     },     searchFolderId: {       type: Number,       required: true     },     height: Number,     disabled: { type: Boolean, default: false }   },   components: {     NattoIcon,     NattoFoldersBrowser   },   emits: ['update:searchFolderId'],    setup(props, { emit }) {     const browse = (event: Event) => {       if (props.disabled === false) {         emit('update:searchFolderId', event)       }     }     const browserFolders = computed(() => {       if (props.searchFolderId === 0) {         return props.folders.collection       }        return props.folders.getFolderById(props.searchFolderId)?.children     })      return {       browse,       browserFolders     }   } }) </script>","describe('UploadDocumentNavigator', () => {   beforeEach(() => {     wrapper = createWrapper(FoldersData, 1122, 160, false)   })   describe('binding', () => {     describe('props', () => {       it('Should have a correct folders binding', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('folders')).toHaveLength(1)       })       it('Should have the correct height value', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('height')).toEqual(160)       })       it('Should pass the correct disabled prop to child component', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('disabled')).toEqual(           wrapper.vm.disabled         )       })     })     describe('events', () => {       it('should fire update:searchFolderId when natto-folders-browser fire browser-folder-selected', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          NattoFoldersBrowserWrapper.vm.$emit('browser-folder-selected', 55)          expect(wrapper.emitted('update:searchFolderId')).toBeTruthy()         expect(wrapper.emitted()['update:searchFolderId'][0]).toStrictEqual([           55         ])       })       it('should not fire update:selectedFolderToUpload when natto-folders-browser fire browser-folder-selected and disabled is true', () => {         const wrapper = createWrapper(FoldersData, 1122, 160, true)         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          NattoFoldersBrowserWrapper.vm.$emit('browser-folder-selected', 55)          expect(wrapper.emitted('update:selectedFolderToUpload')).toBeFalsy()       })     })   }) }) "
"<template>   <natto-button     class=""save""     native-type=""submit""     :loading=""loading""     :disabled=""disabled""     >{{ $t('ged.dataManipulation.label.create') }}   </natto-button> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoButton from '@/Common/components/Buttons/NattoButton.vue'  export default defineComponent({   name: 'SaveButton',   components: { NattoButton },   props: {     loading: Boolean,     disabled: Boolean   } }) </script>","describe('SaveButton', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoButtonWrapper = findNattoButton(wrapper)   })    describe('bindings with NattoButton', () => {     test('props bindings', () => {       expect(nattoButtonWrapper.props('nativeType')).toBe('submit')       expect(nattoButtonWrapper.props('loading')).toBe(false)       expect(nattoButtonWrapper.props('disabled')).toBe(false)     })     it('should render the Create translation key', () => {       expect(wrapper.text()).toContain('ged.dataManipulation.label.create')     })   }) }) "
"<template>   <form     class=""natto-create-folder-form-container""     @submit.prevent=""triggerCreateFolder""   >     <div class=""create-folder-form"">       <mp-input         v-model=""input""         :placeholder=""placeholder""         class=""create-folder-input""       >         <template #prefix>           <folder-icon />         </template>       </mp-input>       <natto-error v-if=""errorMessage"" :error-message=""errorMessage"" />       <div class=""actions"">         <cancel-button @click=""triggerCancel"" :disabled=""isCreatingFolder"" />         <save-button :loading=""isCreatingFolder"" :disabled=""disabledButton"" />       </div>     </div>   </form> </template>  <script lang=""ts""> import { defineComponent, ref, computed } from 'vue' import { CreateFolderQuery } from '@/modules/Search/types' import useCreateFolderModule from '@/modules/DataManipulation/Create/CreateFolder/store/helpers' import { useStore } from 'vuex' import constants from '@/Common/constants' import useStringHelpers from '@/Common/hooks/useStringHelpers' import NattoError from '@/Common/components/Inputs/NattoError.vue' import CancelButton from '@/modules/DataManipulation/Create/CreateFolder/components/CancelButton.vue' import SaveButton from '@/modules/DataManipulation/Create/CreateFolder/components/SaveButton.vue' import FolderIcon from '@/Common/components/Icons/FolderIcon.vue'  export default defineComponent({   name: 'NattoCreateFolderForm',   emits: [     'create-folder-click',     'cancel-create-folder-click',     'invalid-folder-name'   ],   props: {     placeholder: String,     selectedFolderId: Number,     folderName: String,     canAddFolder: { type: Boolean, default: true },     creationFolderError: String   },   components: {     FolderIcon,     SaveButton,     CancelButton,     NattoError   },   setup(props, { emit }) {     const { validStringAlphanumericFrench } = useStringHelpers()     const store = useStore()     const { isCreatingFolder } = useCreateFolderModule(store)     const input = ref('')      const validInput = computed(() =>       validStringAlphanumericFrench(input.value)     )      const text = {       validationNameWarning:         constants.messages.folders.create.validationNameWarning     }      const errorMessage = computed(() => {       if (!validInput.value && input.value.length > 0) {         return text.validationNameWarning       } else if (props.creationFolderError) {         return props.creationFolderError       }        return ''     })      return {       text,       errorMessage,       disabledButton: computed(         () => !validInput.value || input.value.length === 0       ),       isCreatingFolder,       input,       triggerCancel: () => {         input.value = ''         emit('cancel-create-folder-click')       },       triggerCreateFolder: () => {         if (props.canAddFolder) {           const query = {             targetFolder: props.selectedFolderId,             folderName: input.value           } as CreateFolderQuery            if (query.folderName === '' && !query.folderName) {             emit('invalid-folder-name', query.folderName)           } else {             emit('create-folder-click', query)             input.value = ''           }         }       }     }   } }) </script>","describe('natto-create-folder-form', () => {   beforeEach(() => {     wrapper = createWrapper({       ...defaultProps,       placeholder: 'my placeholder',       selectedFolderId: 1234,       canAddFolder: true     })     mainStoreMock.dispatch = jest.fn()   })   describe('binding', () => {     describe('props', () => {       it('Should bind placeholder prop value correctly', () => {         expect(wrapper.props('placeholder')).toBe('my placeholder')       })       it('Should bind selectedFolderId prop value correctly', () => {         expect(wrapper.props('selectedFolderId')).toBe(1234)       })       it('Should bind canAddFolder prop value correctly', () => {         expect(wrapper.props('canAddFolder')).toBe(true)       })     })     describe('events', () => {       describe('create-folder-click event', () => {         it('Should emit create-folder-click when folder name is valid', async () => {           const data = [             {               targetFolder: 1234,               folderName: 'hello'             }           ]            wrapper.vm.input = 'hello'            const formWrapper = findFormWrapper(wrapper)            await formWrapper.trigger('submit')           await wrapper.vm.$nextTick()           expect(wrapper.emitted('create-folder-click')).toBeTruthy()            expect(wrapper.emitted()['create-folder-click'][0]).toEqual(data)         })         it('Should not  emit create-folder-click when folder name is notvalid', async () => {           const formWrapper = findFormWrapper(wrapper)            await formWrapper.trigger('submit')           await wrapper.vm.$nextTick()           expect(wrapper.emitted('create-folder-click')).toBeFalsy()         })         it('Should   emit invalid-folder-name when folder name is notvalid', async () => {           const formWrapper = findFormWrapper(wrapper)            await formWrapper.trigger('submit')           await wrapper.vm.$nextTick()           expect(wrapper.emitted('invalid-folder-name')).toBeTruthy()         })         it('Should  not  emit create-folder-click when canAddFolder is false', async () => {           wrapper = createWrapper(             {               ...defaultProps,               placeholder: 'my placeholder',               selectedFolderId: 1234,               canAddFolder: true             },             mainStoreMock,             createElButton('submit')           )            const btnWrapper = findSaveBtnWrapper(wrapper)            await btnWrapper.trigger('click')           await wrapper.vm.$nextTick()           expect(wrapper.emitted('invalid-folder-name')).toBeFalsy()         })         it('Should emit cancel-create-folder-click when cancel btn click', async () => {           const btnWrapper = findCancelBtnWrapper(wrapper)            await btnWrapper.trigger('click')            await wrapper.vm.$nextTick()           expect(wrapper.emitted('cancel-create-folder-click')).toBeTruthy()         })       })     })     describe('rendering', () => {       describe('save button', () => {         it('Should be disabled when folder creation in progress', () => {           wrapper = createWrapper(             {               ...defaultProps,               placeholder: 'my placeholder',               selectedFolderId: 1234,               canAddFolder: true             },             createFolderStoreMocked({ isCreatingFolder: true })           )           const buttonWrapper = findCancelBtnWrapper(wrapper)            expect(buttonWrapper.props('disabled')).toBe(true)         })         it('Should be loading when folder creation in progress', () => {           const storeMock = createFolderStoreMocked({ isCreatingFolder: true })            wrapper = createWrapper(             {               ...defaultProps,               placeholder: 'my placeholder',               selectedFolderId: 1234,               canAddFolder: true             },             storeMock           )           const buttonWrapper = findSaveBtnWrapper(wrapper)            expect(buttonWrapper.props('loading')).toBe(true)         })       })        describe('cancel button', () => {         it('Should be disabled when folder creation in progress', () => {           wrapper = createWrapper(             {               ...defaultProps,               placeholder: 'my placeholder',               selectedFolderId: 1234,               canAddFolder: true             },             createFolderStoreMocked({ isCreatingFolder: true })           )            const buttonWrapper = findCancelBtnWrapper(wrapper)            expect(buttonWrapper.props('disabled')).toBe(true)         })       })       describe('warning-text', () => {         it('Should be displayed if folder name not respecting text', async () => {           wrapper = createWrapper({             ...defaultProps,             placeholder: 'my placeholder',             selectedFolderId: 1234,             canAddFolder: true           })            const mpInputWrapper = findMpInputWrapper(wrapper)            mpInputWrapper.vm.$emit('update:modelValue', 'hello$ ^')           await wrapper.vm.$nextTick()           const warningTextWrapper = findWarningTextWrapper(wrapper)           const saveButtonWrapper = findSaveBtnWrapper(wrapper)            expect(warningTextWrapper.exists()).toBeTruthy()           expect(saveButtonWrapper.props('disabled')).toBe(true)         })          it('Should be not displayed if folder name not respecting text', async () => {           const mpInputWrapper = findMpInputWrapper(wrapper)            mpInputWrapper.vm.$emit('update:modelValue', 'hello')           await wrapper.vm.$nextTick()           const warningTextWrapper = findWarningTextWrapper(wrapper)           const saveButtonWrapper = findSaveBtnWrapper(wrapper)            expect(warningTextWrapper.exists()).toBeFalsy()           expect(saveButtonWrapper.props('disabled')).toBe(false)         })          it('Should bind error message if error message prop is defined', async () => {           wrapper = createWrapper(             {               ...defaultProps,               placeholder: 'my placeholder',               selectedFolderId: 1234,               canAddFolder: true,               creationFolderError: 'This folder already exists'             },             mainStoreMock           )            const warningTextWrapper = findWarningTextWrapper(wrapper)            expect(warningTextWrapper.exists()).toBe(true)           expect(warningTextWrapper.props('errorMessage')).toBe(             'This folder already exists'           )         })       })     })   }) }) "
"<template>   <natto-button class=""cancel"" :disabled=""disabled""     >{{ $t('ged.dataManipulation.label.cancel') }}   </natto-button> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoButton from '@/Common/components/Buttons/NattoButton.vue'  export default defineComponent({   name: 'CancelButton',   components: { NattoButton },   props: {     disabled: Boolean   } }) </script>","describe('CancelButton', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoButtonWrapper = findNattoButton(wrapper)   })    describe('bindings with NattoButton', () => {     test('props bindings', () => {       expect(nattoButtonWrapper.props('disabled')).toBe(false)     })     it('should render the Create translation key', () => {       expect(wrapper.text()).toContain('ged.dataManipulation.label.cancel')     })   }) }) "
"<template>   <div class=""document-tags"">     <treated-tag v-if=""isTreated"" />     <new-tag v-if=""isNew"" />     <document-certify-tag       v-if=""hasSubscribedToVault""       class=""document-tags__certified""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import TreatedTag from '@/modules/Search/components/Tags/TreatedTag.vue' import DocumentCertifyTag from '@/modules/Search/components/Tags/DocumentCertifyTag.vue' import NewTag from '@/modules/Search/components/Tags/NewTag.vue'  export default defineComponent({   name: 'DocumentTags',   components: { NewTag, DocumentCertifyTag, TreatedTag },   props: {     hasSubscribedToVault: Boolean,     isTreated: Boolean,     isNew: Boolean   } }) </script>","describe('DocumentTags', () => {   beforeEach(() => {     wrapper = createWrapper()     certifyTagWrapper = findCertifyTag(wrapper)     treatedTagWrapper = findTreatedTag(wrapper)     newTagWrapper = findNewTag(wrapper)   })    describe('bindings with tags', () => {     describe('rendering', () => {       it.each([         { hasSubscribedToVault: false, certifyTagExists: false },         { hasSubscribedToVault: true, certifyTagExists: true }       ])(         'should render certify tag if hasSubscribedToVault is true',         ({ hasSubscribedToVault, certifyTagExists }) => {           wrapper = createWrapper({ ...defaultProps, hasSubscribedToVault })            certifyTagWrapper = findCertifyTag(wrapper)            expect(certifyTagWrapper.exists()).toBe(certifyTagExists)         }       )       it.each([         { isTreated: false, treatedTagExists: false },         { isTreated: true, treatedTagExists: true }       ])(         'should render treated tag if isTreated is true',         ({ isTreated, treatedTagExists }) => {           wrapper = createWrapper({ ...defaultProps, isTreated })            treatedTagWrapper = findTreatedTag(wrapper)            expect(treatedTagWrapper.exists()).toBe(treatedTagExists)         }       )       it.each([         { isNew: false, newTagExists: false },         { isNew: true, newTagExists: true }       ])(         'should render new tag if isNew is true',         ({ isNew, newTagExists }) => {           wrapper = createWrapper({ ...defaultProps, isNew })            newTagWrapper = findNewTag(wrapper)            expect(newTagWrapper.exists()).toBe(newTagExists)         }       )     })   }) }) "
"<template>   <div class=""arbo-header__container"">     <div class=""arbo-header__prepend"">       <chevron-left-icon         class=""arbo-header__back""         name=""arrow-left""         @click=""$emit('back-click')""       />       <natto-divider class=""arbo-header__separator"" />     </div>     <natto-header class=""arbo-header"" :title=""arboHeaderTitle"">       <template #subHeader>         <natto-breadcrumb           :breadcrumbs=""breadcrumbs""           @breadcrumb-click=""handleBrowserFolderSelected""         />       </template>       <template #cta>         <documents-create-folder-button           :disabled=""!canAddFolder""           @click=""openCreateFolderModal""         />         <div class=""create-folder-icon-container"">           <documents-upload-btn             :disabled=""disabledUpload""             :canUploadFiles=""canUploadFiles""             :hasAccessDs=""hasAccessDs""             @on-files-change=""$emit('upload-triggered', $event)""           />         </div>       </template>     </natto-header>   </div>    <create-folder-modal     v-model=""isCreateFolderModalOpened""     :selectedFolderId=""searchFolderId""   /> </template>  <script lang=""ts""> import { defineComponent, watch, ref, computed } from 'vue' import useBreadcrumbHelpers from '@/Common/hooks/useBreadcrumbHelpers' import NattoBreadcrumb from '@/Common/components/Breadcrumb/NattoBreadcrumb.vue' import DocumentsUploadBtn from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Activators/DocumentsUploadBtn.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import DocumentsCreateFolderButton from '@/modules/Search/components/Buttons/DocumentsCreateFolderButton.vue' import CreateFolderModal from '@/modules/Search/components/Modals/CreateFolderModal.vue' import useCreateFolderModule from '@/modules/DataManipulation/Create/CreateFolder/store/helpers' import { useStore } from 'vuex' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import NattoHeader from '@/Common/components/Header/NattoHeader.vue' import ChevronLeftIcon from '@/Common/components/Icons/ChevronLeftIcon.vue' import NattoDivider from '@/Common/components/Dividers/NattoDivider.vue'  export default defineComponent({   name: 'ArboHeader',   components: {     NattoDivider,     ChevronLeftIcon,     NattoHeader,     NattoBreadcrumb,     DocumentsUploadBtn,     DocumentsCreateFolderButton,     CreateFolderModal   },    props: {     folders: {       type: Folders,       required: true     },     disabledUpload: {       type: Boolean,       default: false     },     searchFolderId: {       type: Number,       required: true     },     canUploadFiles: Boolean,     hasAccessDs: Boolean,     isMainViewBtn: Boolean   },   emits: [     'breadcrumb-click',     'back-click',     'upload-triggered',     'update:searchFolderId',     'open-create-folder'   ],   setup(props) {     const store = useStore()      const isCreateFolderModalOpened = ref(false)     const { hasPermissionToAddFolder } = useCreateFolderModule(store)      const { state, selectBreadcrumb } = useBreadcrumbHelpers({       folders: props.folders,       selectedFolder: props.searchFolderId,       propName: 'searchFolderId'     })      const handleBrowserFolderSelected = (id: number, emitEvent: boolean) => {       selectBreadcrumb(id, emitEvent)     }      watch([() => props.searchFolderId], () => {       handleBrowserFolderSelected(props.searchFolderId, false)       trackEventFactory(         analyticsCode['adv-beadcrumb-click'],         state.breadcrumbs.length       )     })      const canAddFolder = computed(() =>       hasPermissionToAddFolder(props.searchFolderId)     )      const arboHeaderTitle = computed(() =>       state.breadcrumbs.length > 0         ? state.breadcrumbs[state.breadcrumbs.length - 1].text         : ''     )      return {       canAddFolder,       handleBrowserFolderSelected: (id: number) =>         handleBrowserFolderSelected(id, true),       breadcrumbs: state.breadcrumbs,       isCreateFolderModalOpened,       arboHeaderTitle,       openCreateFolderModal: () => {         if (canAddFolder.value) {           trackEventFactory(analyticsCode['adv-add-folder-cta'])           isCreateFolderModalOpened.value = true         }       }     }   } }) </script>","describe('ArboHeader', () => {   beforeEach(() => {     wrapper = createWrapper({       folders: FoldersData,       disabledUpload: true,       searchFolderId: 1122,       canUploadFiles: true,       hasAccessDs: true,       isMainViewBtn: true     })   })   describe('bindings with CreateFolderModal', () => {     it('props', () => {       createFolderModalWrapper = findCreateFolderModal(wrapper)        expect(createFolderModalWrapper.props('selectedFolderId')).toBe(1122)       expect(createFolderModalWrapper.props('modelValue')).toBe(false)     })   })   describe('bindings', () => {     describe('props', () => {       describe('natto-breadcrumb', () => {         it('should pass breadcrumbs props', () => {           const nattoBreadcrumWrapper: VueWrapper<any> =             wrapper.findComponent(NattoBreadcrumb)            expect(nattoBreadcrumWrapper.props('breadcrumbs')).toStrictEqual([             {               id: 1122,               text: 'A classer'             }           ])         })       })       describe('documents-upload-btn', () => {         it('should pass disabled props', () => {           const documentsUploadBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsUploadBtn)            expect(documentsUploadBtnWrapper.props('disabled')).toBe(true)         })         it('should pass canUploadFiles props', () => {           const documentsUploadBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsUploadBtn)            expect(documentsUploadBtnWrapper.props('canUploadFiles')).toBe(             wrapper.props('canUploadFiles')           )         })         it('should pass hasAccessDs props', () => {           const documentsUploadBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsUploadBtn)            expect(documentsUploadBtnWrapper.props('hasAccessDs')).toBe(             wrapper.props('hasAccessDs')           )         })         it('should pass isMainViewBtn props', () => {           const documentsUploadBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsUploadBtn)            expect(documentsUploadBtnWrapper.props('isMainViewBtn')).toBe(             wrapper.props('isMainViewBtn')           )         })       })       describe('documents-create-folder-button', () => {         it('should pass !canAddFolder computed', () => {           const DocCreateFolderBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsCreateFolderButton)            expect(DocCreateFolderBtnWrapper.props('disabled')).toBeTruthy()         })       })     })      describe('events', () => {       it('Should fire back-click event when click header-back-icon icon', async () => {         const iWrapper = wrapper.findComponent(ChevronLeftIcon)          await iWrapper.vm.$emit('click')          expect(wrapper.emitted()['back-click']).toBeTruthy()         expect(wrapper.emitted()['back-click']).toHaveLength(1)         expect(wrapper.emitted()['back-click'][0]).toStrictEqual([])       })        describe('documents-upload-btn', () => {         it('Should emit breadcrumb-click when breadcrumb-click fired', () => {           const breadcrumbWrapper: VueWrapper<any> =             wrapper.findComponent(NattoBreadcrumb)            breadcrumbWrapper.vm.$emit('breadcrumb-click', 1)            expect(wrapper.emitted()['update:searchFolderId']).toBeTruthy()           expect(wrapper.emitted()['update:searchFolderId']).toHaveLength(1)           expect(wrapper.emitted()['update:searchFolderId'][0]).toStrictEqual([             1           ])         })          it('Should emit upload-triggered when on-files-change fired', () => {           const uploadbWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsUploadBtn)            const content = 'mock content'           const data = new Blob([content], { type: 'application/zip' })           const arrayOfBlob = new Array<Blob>()            arrayOfBlob.push(data)           const mockZip = new File(arrayOfBlob, 'Mock.zip')           const mockZip2 = new File(arrayOfBlob, 'Mock2.zip')           const files = new Array<File>()            files.push(mockZip)           files.push(mockZip2)            uploadbWrapper.vm.$emit('on-files-change', files)            expect(wrapper.emitted()['upload-triggered']).toBeTruthy()           expect(wrapper.emitted()['upload-triggered']).toHaveLength(1)           expect(wrapper.emitted()['upload-triggered'][0]).toStrictEqual([             files           ])         })          it('Should not open modal when DocumentsCreateFolderButton emit click and not canAddFolder', async () => {           const DocCreateFolderBtnWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentsCreateFolderButton)            const ModalWrapper: CreateFolderModalTypeWrapper =             wrapper.findComponent(CreateFolderModal)            await DocCreateFolderBtnWrapper.vm.$emit('click')            expect(ModalWrapper.props().modelValue).toBe(false)         })       })     })   })   describe('rendering', () => {     it('Should display last item send breadcrumbs props', () => {       const nattoHeaderWrapper = wrapper.findComponent(NattoHeader)        expect(nattoHeaderWrapper.attributes('title')).toBe('A classer')     })   }) }) "
"<template>   <natto-header :title=""$t('ged.title')"" :subtitle=""$t('ged.subTitle')"">     <template #cta>       <documents-upload-btn         :disabled=""disabled""         :hasAccessDs=""hasAccessDs""         :isMainViewBtn=""isMainViewBtn""         @on-files-change=""$emit('upload-triggered', $event)""       />     </template>   </natto-header> </template>  <script> import NattoHeader from '@/Common/components/Header/NattoHeader' import DocumentsUploadBtn from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Activators/DocumentsUploadBtn.vue'  export default {   name: 'MainHeader',   emits: ['upload-triggered'],   props: {     disabled: Boolean,     hasAccessDs: Boolean,     isMainViewBtn: Boolean   },   components: { NattoHeader, DocumentsUploadBtn } } </script>","describe('MainHeader', () => {   describe('bindings', () => {     describe('props', () => {       it('should bind the title to the NattoHeader title prop', () => {         // Given the title is equal to 'Mes Documents'         wrapper = createWrapper(false, true, true)          // Then NattoHeader should have 'Mes Documents' as title prop         const NattoHeaderWrapper = findNattoHeader(wrapper)          expect(NattoHeaderWrapper.attributes().title).toBe('ged.title')       })       it('should bind the subtitle to the NattoHeader subtitle prop', () => {         // Given the subtitle is equal to 'l'activité de votre GED'         wrapper = createWrapper(false, true, true)          // Then NattoHeader should have 'l'activité de votre GED' as subtitle prop         const NattoHeaderWrapper = findNattoHeader(wrapper)          expect(NattoHeaderWrapper.attributes().subtitle).toBe('ged.subTitle')       })     })   })   describe('bindings with documents-upload-btn', () => {     it('Should pass correct disabled to child component', () => {       const DocumentsUploadBtnWrapper =         wrapper.findComponent(DocumentsUploadBtn)        expect(wrapper.props('disabled')).toBe(         DocumentsUploadBtnWrapper.props('disabled')       )     })     it('Should pass correct hasAccessDs to child component', () => {       const DocumentsUploadBtnWrapper =         wrapper.findComponent(DocumentsUploadBtn)        expect(wrapper.props('hasAccessDs')).toBe(         DocumentsUploadBtnWrapper.props('hasAccessDs')       )     })     it('Should pass correct isMainViewBtn to child component', () => {       const DocumentsUploadBtnWrapper =         wrapper.findComponent(DocumentsUploadBtn)        expect(wrapper.props('isMainViewBtn')).toBe(         DocumentsUploadBtnWrapper.props('isMainViewBtn')       )     })   })   describe('events', () => {     it('Should emit upload-triggered when on-files-change fired', () => {       const uploadbWrapper: VueWrapper<any> =         wrapper.findComponent(DocumentsUploadBtn)        const content = 'mock content'       const data = new Blob([content], { type: 'application/zip' })       const arrayOfBlob = new Array<Blob>()        arrayOfBlob.push(data)       const mockZip = new File(arrayOfBlob, 'Mock.zip')       const mockZip2 = new File(arrayOfBlob, 'Mock2.zip')       const files = new Array<File>()        files.push(mockZip)       files.push(mockZip2)        uploadbWrapper.vm.$emit('on-files-change', files)        expect(wrapper.emitted()['upload-triggered']).toBeTruthy()       expect(wrapper.emitted()['upload-triggered']).toHaveLength(1)       expect(wrapper.emitted()['upload-triggered'][0]).toStrictEqual([files])     })   }) }) "
"<template>   <div class=""basic-layout"">     <div class=""basic-layout__header"">       <slot name=""header""></slot>     </div>     <div class=""basic-layout__content"">       <slot name=""content""></slot>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'BasicLayout' }) </script>","describe('BasicLayout', () => {   describe('rendering', () => {     it('Should render header slot', () => {       const wrapper = createWrapper(         '<div>header slot</div>',         '<div> content slot</div>'       )       const pWrapper: DOMWrapper<any> = wrapper.find('.basic-layout__header')        expect(pWrapper.text()).toBe('header slot')     })      it('Should render content slot', () => {       const wrapper = createWrapper(         '<div>header slot</div>',         '<div>content slot</div>'       )       const pWrapper: DOMWrapper<any> = wrapper.find('.basic-layout__content')        expect(pWrapper.text()).toBe('content slot')     })   }) }) "
"<template>   <basic-layout class=""main-view-layout"">     <template #header>       <main-header         :disabled=""disabled""         :hasAccessDs=""hasAccessDs""         :isMainViewBtn=""isMainViewBtn""         @upload-triggered=""$emit('upload-triggered', $event)""       />     </template>     <template #content>       <div class=""main-view-content"">         <div class=""listview"">           <slot name=""list-view"" />         </div>         <div class=""dragfile"">           <slot name=""dragfile"" />         </div>         <div class=""category"">           <slot name=""category"" />         </div>       </div>     </template>   </basic-layout> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import MainHeader from '@/modules/Search/components/Headers/MainHeader.vue' import BasicLayout from '@/modules/Search/components/Layouts/BasicLayout.vue'  export default defineComponent({   name: 'MainViewLayout',   emits: ['upload-triggered'],   props: {     disabled: Boolean,     hasAccessDs: Boolean,     isMainViewBtn: Boolean   },   components: {     BasicLayout,     MainHeader   } }) </script>","describe('MainViewLayout', () => {   describe('rendering', () => {     it('When Category slots exist should display the conntent', () => {       const wrapper = createWrapper(         '<div id=""searchme"">nice div</div>',         '',         true,         true,         false       )       const categorySlotWrapper: DOMWrapper<any> = wrapper.find('#searchme')        expect(categorySlotWrapper.text()).toBe('nice div')     })      it('When DragFile slots exist should display the conntent', () => {       const wrapper = createWrapper(         '',         '<div id=""searchmeDragFile"">nice div dragfile</div>',         true,         true,         false       )       const dragFileSlot: DOMWrapper<any> = wrapper.find('#searchmeDragFile')        expect(dragFileSlot.text()).toBe('nice div dragfile')     })   })   describe('MainHeader bindings', () => {     it('Should pass the correct disabled prop to child component ', () => {       const wrapper = createWrapper(         '',         '<div id=""searchmeDragFile"">nice div dragfile</div>',         true,         true,         false       )       const MainHeaderWrapper = wrapper.findComponent(MainHeader)        expect(wrapper.props('disabled')).toBe(         MainHeaderWrapper.props('disabled')       )     })     it('Should pass the correct hasAccessDs prop to child component ', () => {       const wrapper = createWrapper(         '',         '<div id=""searchmeDragFile"">nice div dragfile</div>',         true,         true,         false       )       const MainHeaderWrapper = wrapper.findComponent(MainHeader)        expect(wrapper.props('hasAccessDs')).toBe(         MainHeaderWrapper.props('hasAccessDs')       )     })     it('Should pass the correct isMainViewBtn prop to child component ', () => {       const wrapper = createWrapper(         '',         '<div id=""searchmeDragFile"">nice div dragfile</div>',         true,         true,         false       )       const MainHeaderWrapper = wrapper.findComponent(MainHeader)        expect(wrapper.props('isMainViewBtn')).toBe(         MainHeaderWrapper.props('isMainViewBtn')       )     })     describe('events', () => {       it('Should emit upload-triggered when on-files-change fired', () => {         const wrapper = createWrapper(           '',           '<div id=""searchmeDragFile"">nice div dragfile</div>',           true,           true,           false         )          const mainHeaderWrapper = wrapper.findComponent(MainHeader)          const content = 'mock content'         const data = new Blob([content], { type: 'application/zip' })         const arrayOfBlob = new Array<Blob>()          arrayOfBlob.push(data)         const mockZip = new File(arrayOfBlob, 'Mock.zip')         const mockZip2 = new File(arrayOfBlob, 'Mock2.zip')         const files = new Array<File>()          files.push(mockZip)         files.push(mockZip2)          mainHeaderWrapper.vm.$emit('upload-triggered', files)          expect(wrapper.emitted()['upload-triggered']).toBeTruthy()         expect(wrapper.emitted()['upload-triggered']).toHaveLength(1)         expect(wrapper.emitted()['upload-triggered'][0]).toStrictEqual([files])       })     })   }) }) "
"<template>   <div     class=""documents-filters__search-bar""     :class=""{ 'documents-filters__search-bar--active': displayAdvancedSearch }""   >     <documents-search-input v-model=""searchInput"" />     <open-filter-button       :active-filters-count=""activeFiltersCount""       :display-advanced-search=""displayAdvancedSearch""       @click=""handleOpenFiltersButtonClick""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DocumentsSearchInput from '@/modules/Search/components/Filters/DocumentsSearchInput.vue' import OpenFilterButton from '@/modules/Search/components/Filters/Buttons/OpenFilterButton.vue' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'DocumentsSearchBar',   components: { OpenFilterButton, DocumentsSearchInput },    props: {     activeFiltersCount: Number,     displayAdvancedSearch: Boolean,     search: String   },    emits: ['update:search', 'open-filters-button-clicked'],    setup(props, { emit }) {     const searchInput = useVModel(props, 'search')      const handleOpenFiltersButtonClick = () => {       emit('open-filters-button-clicked')     }      return {       handleOpenFiltersButtonClick,       searchInput     }   } }) </script>","describe('DocumentsSearchBar', () => {   beforeEach(() => {     wrapper = createWrapper()     documentsSearchInputWrapper = findDocumentsSearchInput(wrapper)     openFiltersButtonWrapper = findOpenFiltersButton(wrapper)   })    describe('rendering', () => {     it('should set documents-filters__search-bar--active class when displayAdvancedSearch', () => {       wrapper = createWrapper({ displayAdvancedSearch: true, search: '' })        expect(wrapper.classes()).toContain(         'documents-filters__search-bar--active'       )     })   })    describe('bindings with DocumentsSearchInput', () => {     test('props bindings', () => {       wrapper = createWrapper({ ...defaultProps, search: 'test' })        expect(findDocumentsSearchInput(wrapper).vm.modelValue).toBe('test')     })     it('should emit update:search when DocumentsSearchInput emit update:modelValue', async () => {       // When DocumentsSearchInput emit update:modelValue       await documentsSearchInputWrapper.vm.$emit(         'update:modelValue',         'bisrepetita'       )        // Then DocumentsSearchBar Should emit update:search with same payload       expect(wrapper.emitted('update:search')).toHaveLength(1)       expect(wrapper.emitted('update:search')).toEqual([['bisrepetita']])     })   })    describe('bindings with OpenFiltersButton', () => {     test('props bindings', () => {       wrapper = createWrapper({ ...defaultProps, activeFiltersCount: 1 })        expect(findOpenFiltersButton(wrapper).vm.activeFiltersCount).toBe(1)     })     it('should emit open-filters-button-clicked when OpenFiltersButton emit click', async () => {       // When OpenFiltersButton emit click       await openFiltersButtonWrapper.vm.$emit('click')        // Then DocumentsSearchBar Should emit open-filters-button-clicked       expect(wrapper.emitted('open-filters-button-clicked')).toHaveLength(1)     })   }) }) "
"<template>   <natto-input     class=""documents-filters__search-input""     v-model=""searchInput""     :placeholder=""$t('ged.search.input.placeholder')""     :debounceTime=""500""     clearable     @clear=""handleClear""   >     <template #prefix>       <div class=""documents-filters__search-input__icon"">         <mp-icon name=""search"" />       </div>     </template>   </natto-input> </template>  <script lang=""ts""> import NattoInput from '@/Common/components/Inputs/NattoInput.vue' import { defineComponent } from 'vue' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'DocumentsSearchInput',   components: {     NattoInput   },   props: {     modelValue: {       type: String,       required: true     }   },    emits: ['update:modelValue'],    setup(props) {     const searchInput = useVModel(props)      const handleClear = () => {       searchInput.value = ''     }      return {       searchInput,       handleClear     }   } }) </script>","describe('DocumentsSearchInput', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoInputWrapper = findNattoInput(wrapper)   })    describe('bindings with NattoInput', () => {     test('props bindings', () => {       wrapper = createWrapper({ modelValue: 'test' })        expect(findNattoInput(wrapper).props()).toStrictEqual({         clearable: true,         debounceTime: 500,         disabled: false,         modelValue: 'test',         placeholder: 'ged.search.input.placeholder'       })     })     describe('events bindings', () => {       it('should emit update:modelValue when NattoInput emits update:modelValue', async () => {         // When NattoInput emits update:modelValue         await nattoInputWrapper.vm.$emit('update:modelValue', 'test')          // Then DocumentsSearchInput should emit update:modelValue         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toEqual([['test']])       })       it('should emit update:modelValue when NattoInput emits clear', async () => {         // When NattoInput emits update:modelValue         await nattoInputWrapper.vm.$emit('clear')          // Then DocumentsSearchInput should emit update:modelValue with an empty string         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toEqual([['']])       })     })     describe('rendering', () => {       it('should render a search icon in the NattoInput prefix slot', () => {         expect(findMpIcon(wrapper).props('name')).toBe('search')       })     })   }) }) "
"<template>   <section class=""document-search-filters"">     <documents-search-bar       v-model:search=""searchValue""       :active-filters-count=""activeFiltersCount""       :display-advanced-search=""displayAdvancedSearch""       @open-filters-button-clicked=""toggleFilters""     />     <natto-collapse-transition>       <advanced-search-options         v-show=""displayAdvancedSearch""         v-model:period=""filters.period""         v-model:certified=""filters.certified""         class=""advanced-search-options""         @search-clicked=""handleChangeFilters""         @reset-filters-clicked=""handleReset""       />     </natto-collapse-transition>   </section> </template>  <script lang=""ts""> import { defineComponent, ref } from 'vue' import AdvancedSearchOptions from '@/modules/Search/components/Filters/AdvancedSearchOptions/AdvancedSearchOptions.vue' import DocumentsSearchBar from '@/modules/Search/components/Filters/DocumentsSearchBar.vue' import NattoCollapseTransition from '@/Common/components/Transitions/NattoCollapseTransition.vue' import useVModel from '@/Common/hooks' import DocumentsFilters from '@/modules/Search/models/Documents/Query/DocumentsFilters'  export default defineComponent({   name: 'DocumentsSearchFilters',   components: {     NattoCollapseTransition,     DocumentsSearchBar,     AdvancedSearchOptions   },   props: {     search: String,     activeFiltersCount: Number   },    emits: ['update:search', 'change-filters', 'reset-filters'],    setup(props, { emit }) {     const displayAdvancedSearch = ref(false)      const filters = ref(new DocumentsFilters())      const handleChangeFilters = async () => {       emit('change-filters', filters.value)     }      const handleReset = async () => {       filters.value = new DocumentsFilters()       emit('reset-filters')     }      const searchValue = useVModel(props, 'search')      const toggleFilters = () => {       displayAdvancedSearch.value = !displayAdvancedSearch.value     }      return {       displayAdvancedSearch,       handleChangeFilters,       searchValue,       filters,       toggleFilters,       handleReset     }   } }) </script>","describe('DocumentsSearchFilters', () => {   beforeEach(() => {     wrapper = createWrapper()     documentsSearchBarWrapper = findDocumentsSearchBar(wrapper)     advancedSearchOptionsWrapper = findAdvancedSearchOptionsWrapper(wrapper)   })    describe('bindings with DocumentsSearchBar', () => {     test('props bindings', () => {       wrapper = createWrapper({ search: 'test', activeFiltersCount: 1 })        documentsSearchBarWrapper = findDocumentsSearchBar(wrapper)       expect(documentsSearchBarWrapper.vm.search).toEqual('test')       expect(documentsSearchBarWrapper.vm.activeFiltersCount).toEqual(1)       expect(documentsSearchBarWrapper.vm.displayAdvancedSearch).toEqual(false)     })     it('should emit update:search when DocumentsSearchBar emits update:modelValue', async () => {       // When DocumentsSearchBar emits update:search       await documentsSearchBarWrapper.vm.$emit('update:search', 'ma recherche')        // Then DocumentsSearchFilters should emit update:search with 'ma recherche' as payload       expect(wrapper.emitted('update:search')).toHaveLength(1)       expect(wrapper.emitted('update:search')).toEqual([['ma recherche']])     })     it('should toggle the advanced filters option when DocumentsSearchBar emits open-filters-button-clicked', async () => {       // When DocumentsSearchBar emits open-filters-button-clicked       await documentsSearchBarWrapper.vm.$emit('open-filters-button-clicked')        // Then the advanced search options (close at init) must be displayed       const advancedSearchOptionsElement =         findAdvancedSearchOptionsElement(wrapper)        expect(advancedSearchOptionsElement.isVisible()).toBe(true)       expect(documentsSearchBarWrapper.vm.displayAdvancedSearch).toBe(true)     })   })   describe('bindings with AdvancedSearchOptions', () => {     it('should emit change-filters when AdvancedSearchOptions emit search-filters', () => {       // Given the period is setted       advancedSearchOptionsWrapper.vm.$emit(         'update:period',         new Period({ startDate: '2022-05-19', endDate: '2022-05-27' })       )       // And set the certified also       advancedSearchOptionsWrapper.vm.$emit('update:certified', true)       // When AdvancedSearchOptions emit search-filters       advancedSearchOptionsWrapper.vm.$emit('search-clicked')        // Then AdvancedSearhOptions should emit change-filters       expect(wrapper.emitted('change-filters')).toHaveLength(1)       expect(wrapper.emitted('change-filters')).toEqual([         [           new DocumentsFilters({             search: '',             period: new Period({               startDate: '2022-05-19',               endDate: '2022-05-27'             }),             certified: true,             findInChildFolders: false,             folderId: 0           })         ]       ])     })     it('should emit reset-filters when AdvancedSearchOptions emit reset-search-filters', () => {       // Given the period is setted       advancedSearchOptionsWrapper.vm.$emit(         'update:period',         new Period({ startDate: '2022-05-19', endDate: '2022-05-27' })       )       // And set the certified also       advancedSearchOptionsWrapper.vm.$emit('update:certified', true)       // When AdvancedSearchOptions emit reset-filters-clicked       advancedSearchOptionsWrapper.vm.$emit('reset-filters-clicked')        // Then AdvancedSearhOptions should emit reset-filters       expect(wrapper.emitted('reset-filters')).toHaveLength(1)       expect(advancedSearchOptionsWrapper.props('certified')).toBe('all')       expect(advancedSearchOptionsWrapper.props('period')).toStrictEqual(         new Period()       )     })   }) }) "
"<template>   <info-bar     :nb-documents=""nbDocumentsInAllFolders""     title=""Résultats dans toute la GED""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import InfoBar from '@/modules/Search/components/Filters/InfoBars/InfoBar.vue'  export default defineComponent({   name: 'DocumentsInAllFoldersBar',   components: { InfoBar },   props: {     nbDocumentsInAllFolders: {       type: Number,       required: true     }   } }) </script>","describe('DocumentsInAllFoldersBar', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('bindings with InfoBar', () => {     it('should bind the props', () => {       const infoBarWrapper = findInfoBar(wrapper)        expect(infoBarWrapper.vm.displayArrow).toBe(true)       expect(infoBarWrapper.vm.title).toBe('Résultats dans toute la GED')       expect(infoBarWrapper.vm.nbDocuments).toBe(75246)     })   }) }) "
"<template>   <div     class=""collaps-container""     :style=""{ cursor: displayArrow ? 'pointer' : 'auto' }""     @click=""handleClick""   >     <span class=""collaps-nb-elements"">{{ nbDocumentsDisplayed }}</span>     <span class=""collaps-title""> {{ title }}</span>     <div class=""spacer"" />     <arrow-right-icon class=""arrow"" v-if=""displayArrow"" />   </div> </template>  <script lang=""ts""> import { computed, ComputedRef, defineComponent, inject } from 'vue' import ArrowRightIcon from '@/Common/components/Icons/ArrowRightIcon.vue'  export default defineComponent({   name: 'InfoBar',   components: {     ArrowRightIcon   },   props: {     nbDocuments: {       type: Number,       required: true     },     title: {       type: String,       required: true     },     displayArrow: {       type: Boolean,       default: true     }   },   emits: ['click'],    setup(props, { emit }) {     const documentsLoading: ComputedRef<boolean> =       inject('documentsLoading') ?? computed(() => false)      const handleClick = () => {       emit('click')     }      const nbDocumentsDisplayed = computed(() => {       return documentsLoading.value ? 0 : props.nbDocuments     })      return {       handleClick,       nbDocumentsDisplayed     }   } }) </script>","describe('InfoBar', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('Should display number and text when send props', () => {       const spanWrapper: DOMWrapper<HTMLSpanElement>[] = wrapper.findAll('span')        expect(spanWrapper.length).toBe(2)       expect(spanWrapper[0].text()).toBe('3')       expect(spanWrapper[1].text()).toBe('azerty')     })     it('Should display 0 results when documents loading', () => {       // Given Documents are loading       wrapper = createWrapper({         documentsLoading: computed(() => true)       })        // Then I should see 0 results       expect(findDocumentsNumberSpan(wrapper).text()).toBe('0')     })     describe('displayArrow', () => {       const displayArrowCases = [         { displayArrow: false, expected: false },         { displayArrow: true, expected: true }       ]        test.each(displayArrowCases)(         'Should have display set $expected at arrow when displayArrow is $displayArrow',         ({ displayArrow, expected }) => {           // Given displayArrow is set at false           wrapper = createWrapper({ ...defaultProps, displayArrow })            // Then the arrow must be displayed           const arrowRightIcon: DOMWrapper<HTMLImageElement> =             wrapper.find('.arrow')            expect(arrowRightIcon.exists()).toBe(expected)         }       )     })   })   describe('events', () => {     it('Should fire click event when click on div', () => {       const divWrapper: DOMWrapper<HTMLDivElement>[] = wrapper.findAll('div')        expect(divWrapper.length).toBe(2)       divWrapper[0].trigger('click')        expect(wrapper.emitted()['click']).toBeTruthy()       expect(wrapper.emitted()['click']).toHaveLength(1)     })   }) }) "
"<template>   <search-date-picker :title=""$t('ged.common.from')"" /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import SearchDatePicker from '@/modules/Search/components/Filters/AdvancedSearchOptions/SearchDatePicker.vue'  export default defineComponent({   name: 'StartDatePicker',   components: { SearchDatePicker } }) </script>","describe('StartDatePicker', () => {   beforeEach(() => {     wrapper = createWrapper()     searchDatePickerWrapper = findSearchDatePicker(wrapper)   })    describe('bindings with SearchDatePicker', () => {     describe('props', () => {       test('static props', () => {         expect(searchDatePickerWrapper.attributes()).toStrictEqual({           title: 'ged.common.from'         })       })     })   }) }) "
"<template>   <div class=""period-selector__inputs__date-picker"">     <div class=""period-selector__inputs__date-picker-title"">{{ title }}</div>     <natto-date-picker       v-model=""date""       :lockafter=""lockAfter""       :lockbefore=""lockBefore""       :placeholder=""placeholder""       format=""DD-MM-YYYY""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoDatePicker from '@/Common/components/Dates/NattoDatePicker.vue' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'SearchDatePicker',   components: { NattoDatePicker },   props: {     modelValue: {       type: String,       required: true     },     lockAfter: String,     lockBefore: String,     placeholder: String,     title: String   },    emits: ['update:modelValue'],    setup(props) {     const date = useVModel(props)      return {       date     }   } }) </script>","describe('SearchDatePicker', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoDatePickerWrapper = findNattoDatePicker(wrapper)   })    describe('bindings with NattoDatePicker', () => {     test('props bindings', () => {       expect(nattoDatePickerWrapper.attributes()).toStrictEqual({         lockafter: '2022-05-19',         lockbefore: '2022-05-27',         placeholder: 'Test placeholder',         modelvalue: '2022-05-19',         format: 'DD-MM-YYYY'       })     })     describe('rendering', () => {       it('should render the title', () => {         expect(wrapper.text()).toContain('Test')       })     })   }) }) "
"<template>   <div class=""period-selector__container"">     <div class=""period-selector__inputs"">       <div class=""period-selector__inputs__select"">         <div class=""period-selector__inputs__select-title"">           {{ $t('ged.search.filters.period.title') }}         </div>         <natto-select           v-model=""selectedPeriod""           :options=""periodOptions""           @update:modelValue=""handleSelectChange""         />       </div>       <span class=""period-selector__inputs-separator"">ou</span>       <div class=""period-selector__inputs-date-pickers"">         <start-date-picker           v-model=""startDate""           :lock-after=""endDate""           :placeholder=""$t('ged.search.filters.period.beginning')""           @update:modelValue=""handleStartDateChange""         />         <end-date-picker           v-model=""endDate""           :lock-before=""startDate""           :placeholder=""$t('ged.search.filters.period.end')""           @update:modelValue=""handleEndDateChange""         />       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, ref, watch } from 'vue' import NattoSelect from '@/Common/components/Select/NattoSelect.vue' import SelectOption from '@/Common/models/Select/SelectOption' import useVModel from '@/Common/hooks' import Period from '@/Common/models/List/Period' import useDates from '@/Common/hooks/useDates' import StartDatePicker from '@/modules/Search/components/Filters/AdvancedSearchOptions/StartDatePicker.vue' import EndDatePicker from '@/modules/Search/components/Filters/AdvancedSearchOptions/EndDatePicker.vue'  export default defineComponent({   name: 'PeriodSelector',   components: { EndDatePicker, StartDatePicker, NattoSelect },   props: {     modelValue: {       type: Period,       required: true     }   },    setup(props) {     const period = useVModel(props)     const selectedPeriod = ref<number | undefined>(undefined)     const startDate = ref<string>('')     const endDate = ref<string>('')     const { dateNow, subtractInDays } = useDates()      const SELECT_OPTIONS = {       NO_PERIOD: undefined,       ONE_DAY: 1,       SEVEN_DAYS: 7,       THIRTY_DAYS: 30     }      const periodOptions = [       new SelectOption('', SELECT_OPTIONS.NO_PERIOD),       new SelectOption('Les dernières 24h', SELECT_OPTIONS.ONE_DAY),       new SelectOption('Les 7 derniers jours', SELECT_OPTIONS.SEVEN_DAYS),       new SelectOption('Les 30 derniers jours', SELECT_OPTIONS.THIRTY_DAYS)     ]      const handleSelectChange = (selectOption: number) => {       if (selectOption === SELECT_OPTIONS.NO_PERIOD) {         period.value = new Period()          return       }        period.value = new Period({         startDate: subtractInDays(dateNow(), selectOption),         endDate: dateNow()       })     }      const handleStartDateChange = (datePickerValue: string) => {       period.value = new Period({         startDate: datePickerValue,         endDate: endDate.value       })       selectedPeriod.value = SELECT_OPTIONS.NO_PERIOD     }      const handleEndDateChange = (datePickerValue: string) => {       period.value = new Period({         startDate: startDate.value,         endDate: datePickerValue       })       selectedPeriod.value = SELECT_OPTIONS.NO_PERIOD     }      watch(       () => props.modelValue,       (newPeriod: Period) => {         if (newPeriod.startDate || newPeriod.endDate) {           startDate.value = newPeriod.startDate           endDate.value = newPeriod.endDate         } else {           startDate.value = ''           endDate.value = ''           selectedPeriod.value = SELECT_OPTIONS.NO_PERIOD         }       }     )      return {       period,       periodOptions,       handleSelectChange,       selectedPeriod,       handleStartDateChange,       handleEndDateChange,       startDate,       endDate     }   } }) </script>","describe('PeriodSelector', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoSelectWrapper = findNattoSelect(wrapper)     startDatePickerWrapper = findStartDatePicker(wrapper)     endDatePickerWrapper = findEndDatePicker(wrapper)   })    describe('watch on modelValue', () => {     it('should reset all the elements if the period is undefined', async () => {       await wrapper.setProps({ modelValue: new Period() })        expect(startDatePickerWrapper.attributes('modelvalue')).toBe('')       expect(endDatePickerWrapper.attributes('modelvalue')).toBe('')       expect(nattoSelectWrapper.props('modelValue')).toBe(undefined)     })     it('should set the start and end date if the period is defined', async () => {       await wrapper.setProps({         modelValue: new Period({           startDate: '2022-05-19',           endDate: '2022-05-27'         })       })        await wrapper.vm.$nextTick()        expect(startDatePickerWrapper.attributes('modelvalue')).toBe('2022-05-19')       expect(endDatePickerWrapper.attributes('modelvalue')).toBe('2022-05-27')       expect(nattoSelectWrapper.props('modelValue')).toBe(undefined)     })   })    describe('bindings with NattoSelect', () => {     describe('props', () => {       test('static props', () => {         expect(nattoSelectWrapper.props()).toEqual({           options: [             {               label: '',               value: undefined             },             {               label: 'Les dernières 24h',               value: 1             },             {               label: 'Les 7 derniers jours',               value: 7             },             {               label: 'Les 30 derniers jours',               value: 30             }           ],           modelValue: undefined         })       })     })      describe('events', () => {       it('should reset the period if the selected option is default', async () => {         await nattoSelectWrapper.vm.$emit('update:modelValue', undefined)          expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([           [new Period()]         ])       })       it('should set the period to the correct date depending on the selected option', async () => {         await nattoSelectWrapper.vm.$emit('update:modelValue', 7)          expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([           [             new Period({               startDate: '2022-05-12',               endDate: '2022-05-19'             })           ]         ])       })     })   })   describe('bindings with StartDatePicker', () => {     describe('props', () => {       test('static props', () => {         expect(startDatePickerWrapper.attributes()).toStrictEqual({           'lock-after': '',           modelvalue: '',           placeholder: 'ged.search.filters.period.beginning'         })       })     })     describe('events', () => {       it('should set the startDate period', async () => {         await startDatePickerWrapper.vm.$emit('update:modelValue', '2022-05-19')          expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([           [             new Period({               startDate: '2022-05-19',               endDate: ''             })           ]         ])         expect(nattoSelectWrapper.props('modelValue')).toStrictEqual(undefined)       })     })   })   describe('bindings with EndDatePicker', () => {     test('props', () => {       expect(endDatePickerWrapper.attributes()).toStrictEqual({         'lock-before': '',         modelvalue: '',         placeholder: 'ged.search.filters.period.end'       })     })     describe('events', () => {       it('should set the endDate period', async () => {         await endDatePickerWrapper.vm.$emit('update:modelValue', '2022-05-27')          expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([           [             new Period({               startDate: '',               endDate: '2022-05-27'             })           ]         ])         expect(nattoSelectWrapper.props('modelValue')).toStrictEqual(undefined)       })     })   }) }) "
"<template>   <div class=""advanced-search-options__container"">     <div class=""advanced-search-options__filters"">       <period-selector v-model=""periodValue"" />     </div>     <div class=""advanced-search-options__actions"">       <reset-search-button @clicked=""$emit('reset-filters-clicked')"" />       <search-button @clicked=""$emit('search-clicked')"" />     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import ResetSearchButton from '@/modules/Search/components/Filters/Buttons/ResetSearchButton.vue' import SearchButton from '@/modules/Search/components/Filters/Buttons/SearchButton.vue' import PeriodSelector from '@/modules/Search/components/Filters/AdvancedSearchOptions/PeriodSelector.vue' import useVModel from '@/Common/hooks' import Period from '@/Common/models/List/Period'  export default defineComponent({   name: 'AdvancedSearchOptions',   components: {     PeriodSelector,     ResetSearchButton,     SearchButton   },    props: {     certified: {       type: [String, Boolean],       required: true     },     period: {       type: Period,       required: true     }   },    emits: [     'reset-filters-clicked',     'search-clicked',     'update:period',     'update:certified'   ],    setup(props) {     const certifiedValue = useVModel(props, 'certified')     const periodValue = useVModel(props, 'period')      return {       certifiedValue,       periodValue     }   } }) </script>","describe('AdvancedSearchOptions', () => {   beforeEach(() => {     wrapper = createWrapper()     periodSelectorWrapper = findPeriodSelector(wrapper)     certifiedSelectorWrapper = findCertifiedSelector(wrapper)     resetSearchButtonWrapper = findResetSearchButton(wrapper)     searchButtonWrapper = findSearchButton(wrapper)   })    describe('bindings with PeriodSelector', () => {     test('props bindings', () => {       expect(periodSelectorWrapper.props()).toStrictEqual({         modelValue: new Period()       })     })     describe('events', () => {       it('should emits update:period when PeriodSelector emit update:modelValue', async () => {         const period = new Period({           startDate: '2022-05-19',           endDate: '2022-05-27'         })          await periodSelectorWrapper.vm.$emit('update:modelValue', period)          expect(wrapper.emitted('update:period')).toHaveLength(1)         expect(wrapper.emitted('update:period')).toStrictEqual([[period]])       })     })   })   /*describe('bindings with CertifiedSelector', () => {     test('props bindings', () => {       expect(certifiedSelectorWrapper.props()).toStrictEqual({         modelValue: 'all'       })     })     describe('events', () => {       it('should emits update:certified when CertifiedSelector emit update:modelValue', async () => {         const certified = true          await certifiedSelectorWrapper.vm.$emit('update:modelValue', certified)          expect(wrapper.emitted('update:certified')).toHaveLength(1)         expect(wrapper.emitted('update:certified')).toStrictEqual([[true]])       })     })   })*/   describe('bindings with ResetSearchButton', () => {     describe('events', () => {       it('should emit reset-search-clicked when ResetSearchButton emits clicked', async () => {         await resetSearchButtonWrapper.vm.$emit('clicked')          expect(wrapper.emitted('reset-filters-clicked')).toHaveLength(1)       })     })   })   describe('bindings with SearchButton', () => {     describe('events', () => {       it('should emit search-clicked when SearchButton emits clicked', async () => {         await searchButtonWrapper.vm.$emit('clicked')          expect(wrapper.emitted('search-clicked')).toHaveLength(1)       })     })   }) }) "
"<template>   <search-date-picker :title=""$t('ged.common.to')"" /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import SearchDatePicker from '@/modules/Search/components/Filters/AdvancedSearchOptions/SearchDatePicker.vue'  export default defineComponent({   name: 'EndDatePicker',   components: { SearchDatePicker } }) </script>","describe('EndDatePicker', () => {   beforeEach(() => {     wrapper = createWrapper()     searchDatePickerWrapper = findSearchDatePicker(wrapper)   })    describe('bindings with SearchDatePicker', () => {     describe('props', () => {       test('static props', () => {         expect(searchDatePickerWrapper.attributes()).toStrictEqual({           title: 'ged.common.to'         })       })     })   }) }) "
"<template>   <div class=""certified-selector__container"">     <span class=""certified-selector__title"">{{       $t('ged.common.documentType')     }}</span>     <natto-radio-group       v-model=""certified""       :radio-items=""certifiedSelectorItems""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoRadioGroup, {   RadioItem } from '@/Common/components/Radio/NattoRadioGroup.vue' import { useTranslation } from '@/Common/hooks/useTranslation' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'CertifiedSelector',   components: { NattoRadioGroup },    props: {     modelValue: {       type: [String, Number],       required: true     }   },    setup(props) {     const certified = useVModel(props)     const { t } = useTranslation()      const certifiedSelectorItems: RadioItem[] = [       {         value: 'all',         label: t('ged.search.filters.certified.all')       },       {         value: true,         label: t('ged.search.filters.certified.onlyCertified')       },       {         value: false,         label: t('ged.search.filters.certified.excludeCertified')       }     ]      return {       certifiedSelectorItems,       certified     }   } }) </script>","describe('CertifiedSelector', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoRadioGroupWrapper = findNattoRadioGroup(wrapper)   })    describe('bindings with NattoRadioGroup', () => {     test('props bindings', () => {       expect(nattoRadioGroupWrapper.props()).toStrictEqual({         radioItems: [           {             value: 'all',             label: 'ged.search.filters.certified.all'           },           {             value: true,             label: 'ged.search.filters.certified.onlyCertified'           },           {             value: false,             label: 'ged.search.filters.certified.excludeCertified'           }         ]       })       expect(nattoRadioGroupWrapper.attributes('modelvalue')).toBe('all')     })     describe('events', () => {       it('should emit update:modelValue when NattoRadioGroup emit update:modelValue', async () => {         wrapper = createWrapper()          nattoRadioGroupWrapper = findNattoRadioGroup(wrapper)          await nattoRadioGroupWrapper.vm.$emit('update:modelValue', false)          expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])       })     })   }) }) "
"<template>   <natto-badge :value=""activeFiltersCount"">     <MpAdvancedSearchBtn       :text=""$tc('ged.search.input.advanced')""       :active=""displayAdvancedSearch""       @click=""$emit('open-advanced-filters')""     />   </natto-badge> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoBadge from '@/Common/components/Badges/NattoBadge.vue'  export default defineComponent({   name: 'OpenFilterButton',   props: {     activeFiltersCount: Number,     displayAdvancedSearch: Boolean   },   components: {     NattoBadge   },   emits: ['open-advanced-filters'] }) </script>","describe('OpenFilterButton', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoBadgeWrapper = findNattoBadge(wrapper)     mpAdvancedSearchBtnWrapper = findMpAdvancedSearchBtn(wrapper)   })    describe('bindings with NattoBadge', () => {     it('should pass props', () => {       expect(nattoBadgeWrapper.props().value).toBe(0)     })   })    describe('bindings with MpAdvancedSearchBtn', () => {     describe('props bindings', () => {       it('should have active class when advanced filters are opened', () => {         expect(mpAdvancedSearchBtnWrapper.attributes('active')).toBe('true')         expect(mpAdvancedSearchBtnWrapper.attributes('text')).toBe(           'ged.search.input.advanced'         )       })     })     describe('events', () => {       it('should trigger an open-advanced-filters event when MpAdvancedSearchBtn emit click', async () => {         await mpAdvancedSearchBtnWrapper.vm.$emit('click')         expect(wrapper.emitted('open-advanced-filters')).toBeTruthy()       })     })   }) }) "
"<template>   <natto-tabs :items=""tabItems"" /> </template>  <script lang=""ts""> import NattoTabs from '@/Common/components/Tabs/NattoTabs.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import { defineComponent, computed } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'FolderTabs',   components: { NattoTabs },   props: {     folders: {       type: Folders,       required: true     }   },   setup(props) {     const { t } = useTranslation()      const tabItems = computed(() => {       let items = props.folders.collection.map((x) => ({         id: x.id,         name: x.id,         label: x.name       }))        items.unshift({         id: 0,         name: 0,         label: t('ged.search.tabs.label.all')       })        return items     })      return {       tabItems     }   } }) </script>","describe('folders-tabs', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings', () => {     it('props', () => {       const nattoTabsWrapper = findNattoTabs(wrapper)        expect(nattoTabsWrapper.props('items')).toStrictEqual([         { id: 0, name: 0, label: 'ged.search.tabs.label.all' },         { id: 1122, name: 1122, label: 'Comptabilité' },         { id: 1233, name: 1233, label: 'Gestion Sociale' }       ])     })   }) }) "
"<template>   <natto-tabs stretch :items=""tabItems"">     <template v-if=""isCertified"" #download>       <document-download-tab         :document=""document""         @download-clicked=""$emit('download-clicked')""       />     </template>     <template #details>       <div>         <div class=""doc-preview"">           <document-details-banner             :document=""document""             @click=""displayPreview""           />         </div>          <div class=""doc-details"">           <document-details-tab :document=""document"" />         </div>       </div>     </template>   </natto-tabs> </template>  <script lang=""ts""> import NattoTabs from '@/Common/components/Tabs/NattoTabs.vue' import { defineComponent, computed } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation' import DocumentDetailsTab from '@/modules/Search/components/Drawer/DocumentDetailsTab.vue' import DocumentDetailsBanner from '@/modules/Search/components/Drawer/DocumentDetailsBanner.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import DocumentDownloadTab from '@/modules/Search/components/Drawer/DocumentDownloadTab.vue' export default defineComponent({   name: 'DocumentDetailsDrawerTabs',   components: {     DocumentDownloadTab,     NattoTabs,     DocumentDetailsBanner,     DocumentDetailsTab   },   props: {     document: {       type: Document,       required: true     }   },   emits: ['open-preview'],   setup(props, { emit }) {     const { tc } = useTranslation()      const isCertified = computed(       () => props.document?.properties?.hasSubscribedToVault     )      const tabItems = computed(() => {       let tabItems = []        tabItems.push({         id: 'details',         name: 'details',         label: tc('ged.search.tabs.label.details')       })       if (isCertified.value) {         tabItems.push({           id: 'download',           name: 'download',           label: tc('ged.search.tabs.label.download')         })       }        return tabItems     })      const displayPreview = () => {       emit('open-preview')     }      return {       tabItems,       displayPreview,       isCertified     }   } }) </script>","describe('DocumentDetailsDrawerTabs', () => {   beforeEach(() => {     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('bindings', () => {     it('Should have liste of tab passed and strech', () => {       const wrapper = createWrapper()        const NattoTabsWrapper = wrapper.findComponent(NattoTabs)        expect(NattoTabsWrapper.props('items')).toHaveLength(1)        expect(NattoTabsWrapper.props('stretch')).toBe(true)     })     it('Should have two tab when a document is certifed', () => {       const props: DocumentDetailsDrawerTabsProps = {         document: documentCertified       }        const wrapperCertif = createWrapper(props)        const NattoTabsWrapper = wrapperCertif.findComponent(NattoTabs)        expect(NattoTabsWrapper.props('items')).toHaveLength(2)        expect(NattoTabsWrapper.props('stretch')).toBe(true)     })   }) }) "
"<template>   <natto-card class=""arbo-card"">     <div class=""arbo-card-container"">       <div class=""arbo-card-header"">         <arbo-card-title :title=""rootFolder.name"" />       </div>       <div class=""arbo-card-content two-rows"">         <div class=""arbo-description"">           <arbo-description             :description=""rootFolder.properties?.folderDescription""           />         </div>         <div class=""arbo-shortcuts"">           <folder-shortcut-list             :folderShortcuts=""shortcutFolders""             @folder-shortcut-click=""handleShortcutClick""             @explore-more-clicked=""handleExploreClick""           />         </div>       </div>     </div>   </natto-card> </template>  <script lang=""ts""> import FolderShortcutList from '@/modules/Search/components/Cards/FolderShortcutList.vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import { defineComponent, computed } from 'vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import ArboDescription from '@/modules/Search/components/Cards/ArboDescription.vue' import ArboCardTitle from '@/modules/Search/components/Cards/ArboCardTitle.vue' import NattoCard from '@/Common/components/Cards/NattoCard.vue' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode'  export default defineComponent({   name: 'ArboCard',    components: {     NattoCard,     ArboCardTitle,     ArboDescription,     FolderShortcutList   },    props: {     rootFolder: {       type: Folder,       required: true     }   },    emits: ['explore-more-clicked', 'shortcut-clicked'],    setup(props, { emit }) {     const store = useStore()      const { folders } = useSearchStoreHelpers()      const shortcutFolders = computed(() =>       folders(store).value.getShortcutsFolder(props.rootFolder?.id ?? 0)     )      return {       handleExploreClick() {         if (props.rootFolder.properties?.tracingName) {           trackEventFactory(             analyticsCode['mdv-cta-arbo-card-explore-click'],             props.rootFolder.properties.tracingName           )         }         emit('explore-more-clicked')       },       handleShortcutClick({         shortcutFolder,         shortcutIndex       }: {         shortcutFolder: Folder         shortcutIndex: number       }) {         if (           props.rootFolder.properties?.tracingName &&           shortcutFolder.properties?.tracingName         ) {           trackEventFactory(             analyticsCode['mdv-cta-arbo-card-shortcut-click'],             props.rootFolder.properties.tracingName,             shortcutIndex + 1, // Index start at 0             shortcutFolder.properties.tracingName           )         }         emit('shortcut-clicked', shortcutFolder.id)       },       shortcutFolders     }   } }) </script>","describe('ArboCard', () => {   beforeEach(() => {     wrapper = createWrapper()     arboCardTitleWrapper = findArboCardTitle(wrapper)     jest.clearAllMocks()   })   describe('binding', () => {     describe('props', () => {       it('Should bind rootFolder correctly ', () => {         expect(wrapper.props('rootFolder')).toStrictEqual(           defaultProps.rootFolder         )       })       it('Should bind headerTitle correctly ', () => {         expect(arboCardTitleWrapper.props('title')).toStrictEqual(           'Comptabilité'         )       })       describe('binding with arbo description', () => {         it('Should pass correct value to child component', () => {           const ArboDescriptionWrapper = wrapper.findComponent(ArboDescription)            expect(ArboDescriptionWrapper.props('description')).toBe(             'Ranger les documents'           )         })       })     })   })    describe('FolderShortcutList', () => {     it('Should bind rootFolder correctly ', () => {       wrapper = createWrapper({         rootFolder: foldersData.collection[1]       })        const shortcutListWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(FolderShortcutList)        expect(shortcutListWrapper.props('folderShortcuts')).toHaveLength(1)        expect(shortcutListWrapper.props('folderShortcuts')[0]).toStrictEqual(         foldersData.collection[1].children[0]       )     })      describe('events', () => {       const cases = [         {           // Folder WITHOUT tracingName           rootFolder: foldersData.collection[0],           expectedTrackEventCalled: false         },         {           // Folder WITH tracingName           rootFolder: foldersData.collection[1],           expectedTrackEventCalled: true         }       ]        describe('Should fire explore-more-clicked when explore-plus-button emit click event', () => {         test.each(cases)(           'test mdv-cta-arbo-card-explore-click event and explore-more-clicked event',           async ({ rootFolder, expectedTrackEventCalled }) => {             wrapper = createWrapper({ rootFolder })             folderShortcutListWrapper = findFolderShortcutList(wrapper)              await folderShortcutListWrapper.vm.$emit('explore-more-clicked')              if (expectedTrackEventCalled) {               expect(trackEventFactory).toHaveBeenCalledWith(                 'mdv-cta-arbo-card-explore-click',                 'Accounting'               )             } else {               expect(trackEventFactory).not.toHaveBeenCalled()             }              expect(wrapper.emitted('explore-more-clicked')).toBeTruthy()           }         )       })        describe('Should fire shortcut-clicked when folder-shortcut-click emit click event', () => {         test.each(cases)(           'test mdv-cta-arbo-card-shortcut-click event and explore-more-clicked event',           async ({ rootFolder, expectedTrackEventCalled }) => {             wrapper = createWrapper({               rootFolder             })              const shortcutListWrapper: VueWrapper<ComponentPublicInstance> =               wrapper.findComponent(FolderShortcutList)              await shortcutListWrapper.vm.$emit('folder-shortcut-click', {               shortcutFolder: foldersData.collection[1].children[0],               shortcutIndex: 0             })              if (expectedTrackEventCalled) {               expect(trackEventFactory).toHaveBeenCalledWith(                 'mdv-cta-arbo-card-shortcut-click',                 'Accounting',                 1,                 'KPMG/Test'               )             } else {               expect(trackEventFactory).not.toHaveBeenCalled()             }              expect(wrapper.emitted()['shortcut-clicked']).toBeTruthy()             expect(wrapper.emitted()['shortcut-clicked']).toHaveLength(1)             expect(wrapper.emitted()['shortcut-clicked'][0]).toStrictEqual([               1223             ])           }         )       })     })   }) }) "
"<template>   <div class=""arbo-description"">     <p class=""description-text"">{{ description }}</p>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  export default defineComponent({   name: 'ArboDescription',   props: {     description: { type: String, default: '' }   } }) </script>","describe('ArboDescription', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     it('Should bind Contentdescription correctly ', () => {       expect(wrapper.props('description')).toStrictEqual(         defaultProps.description       )     })   }) }) "
"<template>   <div class=""arbo-card__title"">     <folder-icon class=""arbo-card__title--icon"" />     <span class=""arbo-card__title--text"">       {{ title }}     </span>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import FolderIcon from '@/Common/components/Icons/FolderIcon.vue'  export default defineComponent({   name: 'ArboCardTitle',   components: { FolderIcon },   props: {     title: {       type: String,       required: true     }   } }) </script>","describe('ArboCardTitle', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('should render the title', () => {       wrapper = createWrapper({ title: 'test' })        expect(wrapper.text()).toContain('test')     })   }) }) "
"<template>   <div class=""arbo-card__list"">     <arbo-card       v-for=""folder in folders.collection""       :key=""folder.id""       :root-folder=""folder""       @explore-more-clicked=""goToArboView({ folderId: folder.id })""       @shortcut-clicked=""goToArboView({ folderId: $event })""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import ArboCard from '@/modules/Search/components/Cards/ArboCard.vue' import { useStore } from 'vuex' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'ArboCardList',   components: { ArboCard },    setup() {     const store = useStore()      const { folders } = useSearchStoreHelpers()      const { goToArboView } = useSearchNavigator()      return {       folders: folders(store),       goToArboView     }   } }) </script>","describe('ArboCardList', () => {   beforeEach(() => {     wrapper = createWrapper()     arboCardWrappers = findArboCards(wrapper)   })   afterEach(() => {     jest.clearAllMocks()   })    describe('bindings with ArboCard', () => {     describe('rendering', () => {       it('should render 5 ArboCards if folders.collection has 5 rootFolder', () => {         // Then 5 ArboCards must be rendered         expect(findArboCards(wrapper)).toHaveLength(5)       })       it('should render 0 ArboCards if no folders', () => {         // Then 5 ArboCards must be rendered         expect(findArboCards(emptyFolderWrapper)).toHaveLength(0)       })     })     describe('props bindings', () => {       const cases = [         {           arboCardIndex: 0,           expectedFolder: useFoldersData().FoldersData.collection[0],           expectedFolderName: 'A classer'         },         {           arboCardIndex: 1,           expectedFolder: useFoldersData().FoldersData.collection[1],           expectedFolderName: 'Autres'         },         {           arboCardIndex: 2,           expectedFolder: useFoldersData().FoldersData.collection[2],           expectedFolderName: 'Banque'         },         {           arboCardIndex: 3,           expectedFolder: useFoldersData().FoldersData.collection[3],           expectedFolderName: 'Achats'         },         {           arboCardIndex: 4,           expectedFolder: useFoldersData().FoldersData.collection[4],           expectedFolderName: 'Ventes'         }       ]        it.each(cases)(         'should bind correctly the root folders',         ({ arboCardIndex, expectedFolder, expectedFolderName }) => {           // Then ArboCard must have as rootFolder and headerTitle prop the respective folder in the folders.collection           expect(             findArboCards(wrapper)[arboCardIndex].props('rootFolder')           ).toStrictEqual(expectedFolder)         }       )     })     describe('events', () => {       const cases = [         { arboCardIndex: 0, expectedFolderId: 1122 },         { arboCardIndex: 1, expectedFolderId: 1233 },         { arboCardIndex: 2, expectedFolderId: 1234 },         { arboCardIndex: 3, expectedFolderId: 1235 },         { arboCardIndex: 4, expectedFolderId: 1236 }       ]        it.each(cases)(         'should go to ArboView with corresponding folderId when ArboCard emits explore-more-clicked',         async ({ arboCardIndex, expectedFolderId }) => {           // When ArboCard emits explore-more-clicked           await findArboCards(wrapper)[arboCardIndex].vm.$emit(             'explore-more-clicked'           )            // Then router.push must have been called to go to ArboView with correspond folderId           expect(routerMock.push).toHaveBeenCalledWith({             name: 'ArboView',             query: { folderId: expectedFolderId }           })         }       )        it.each(cases)(         'should go to ArboView with corresponding folderId when ArboCard emits shortcut-clicked',         async ({ arboCardIndex, expectedFolderId }) => {           // When ArboCard emits shortcut-clicked with folderId           await findArboCards(wrapper)[arboCardIndex].vm.$emit(             'shortcut-clicked',             expectedFolderId           )            // Then router.push must have been called to go to ArboView with correspond folderId           expect(routerMock.push).toHaveBeenCalledWith({             name: 'ArboView',             query: { folderId: expectedFolderId }           })         }       )     })   }) }) "
"<template>   <div class=""folder-shortcut-list"">     <folder-card       v-for=""(folder, index) in folderShortcuts""       :key=""folder.id""       :folder=""folder""       class=""folder-item""       @folder-click=""handleFolderClick(folder, index)""     />     <div v-if=""isPair"" class=""offset-grid-zone"" />     <arbo-explore-button @click=""handleExploreClick"" />   </div> </template>  <script lang=""ts""> import FolderCard from '@/modules/Search/components/Cards/FolderCard.vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import { defineComponent, PropType, computed } from 'vue' import ArboExploreButton from '@/modules/Search/components/Buttons/ArboExploreButton.vue'  export default defineComponent({   name: 'FolderShortcutList',   components: { FolderCard, ArboExploreButton },   props: {     folderShortcuts: {       type: Array as PropType<Folder[]>,       required: true     }   },   emits: ['folder-shortcut-click', 'explore-more-clicked'],   setup(props, { emit }) {     const handleFolderClick = (       shortcutFolder: Folder,       shortcutIndex: number     ) => {       emit('folder-shortcut-click', { shortcutFolder, shortcutIndex })     }      return {       isPair: computed(() => props.folderShortcuts.length % 2 === 0),       handleExploreClick() {         emit('explore-more-clicked')       },       handleFolderClick     }   } }) </script>","describe('FolderShortcutList', () => {   beforeEach(() => {     jest.clearAllMocks()   })   describe('bindings with ArboExploreButton', () => {     it('should fire explore-more-clicked on explore btn click', async () => {       const wrapper = createWrapper(         Folders.loaded([           {             id: 1122,             name: 'Comptabilité',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           },           {             id: 1233,             name: 'Gestion Sociale',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           }         ]).collection       )        const exploreBtnWrapper = wrapper.findComponent(ArboExploreButton)        await exploreBtnWrapper.vm.$emit('click')        expect(wrapper.emitted()['explore-more-clicked']).toBeTruthy()     })   })   describe('bindings', () => {     describe('props', () => {       it('Should send correct folder when send folders props', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ]).collection         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(FolderCard)          expect(shortcutCardWrappper[0].vm.folder).toEqual({           id: 1122,           name: 'Comptabilité',           parentId: 0,           children: [],           properties: {},           permissions: []         })         expect(shortcutCardWrappper[1].vm.folder).toEqual({           id: 1233,           name: 'Gestion Sociale',           parentId: 0,           children: [],           properties: {},           permissions: []         })       })     })     describe('events', () => {       it('Should fire folder-shortcut-click event when click event is fired', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ]).collection         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(FolderCard)          shortcutCardWrappper[0].vm.$emit('folder-click', 1122)          expect(wrapper.emitted()['folder-shortcut-click']).toBeTruthy()         expect(wrapper.emitted()['folder-shortcut-click']).toHaveLength(1)         expect(wrapper.emitted()['folder-shortcut-click'][0]).toEqual([           {             shortcutFolder: {               id: 1122,               name: 'Comptabilité',               parentId: 0,               children: [],               properties: {},               permissions: []             },             shortcutIndex: 0           }         ])       })     })   })   describe('rendering', () => {     describe('props', () => {       it('Should dispaly folders when send folders props', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ]).collection         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(FolderCard)          expect(shortcutCardWrappper).toHaveLength(2)       })     })   }) }) "
"<template>   <natto-shortcut-card     prepend-icon=""documents""     :text=""folder.properties?.isShortcut""     @click=""handleClick""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import NattoShortcutCard from '@/Common/components/Cards/NattoShortcutCard.vue'  export default defineComponent({   name: 'FolderCard',   components: { NattoShortcutCard },   props: {     folder: {       type: Folder,       required: true     }   },   emits: ['folder-click'],   setup(props, { emit }) {     const handleClick = () => {       emit('folder-click')     }      return {       handleClick     }   } }) </script>","describe('FolderCard', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoShortcutCardWrapper = findNattoShortcutCard(wrapper)   })   describe('binding with NattoShortcutCard', () => {     it('props bindings', () => {       expect(nattoShortcutCardWrapper.props('prependIcon')).toBe('documents')       expect(nattoShortcutCardWrapper.props('text')).toBe('Shortcut name')     })     describe('events', () => {       it('Should fire folder-click on when shortcut card emit click', async () => {         await nattoShortcutCardWrapper.vm.$emit('click')          expect(wrapper.emitted()['folder-click']).toBeTruthy()         expect(wrapper.emitted()['folder-click']).toHaveLength(1)       })     })   }) }) "
"<template>   <natto-tree     :data=""folders.collection""     :props=""defaultProps""     @current-change=""handleCurrentChange""   >     <template #item=""{ data }"">       <search-tree-item         :folder=""data""         :is-folder-selected=""data.id === selectedFolder""         @click=""goToArboView({ folderId: data.id })""       />     </template>   </natto-tree> </template>  <script lang=""ts""> import { defineComponent, ref } from 'vue' import NattoTree from '@/Common/components/Tree/NattoTree.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import SearchTreeItem from '@/modules/Search/components/Trees/SearchTreeItem.vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'MainViewTree',   components: { SearchTreeItem, NattoTree },   props: {     folders: {       type: Folders,       required: true     }   },    setup() {     const selectedFolder = ref()     const { goToArboView } = useSearchNavigator()      return {       selectedFolder,       handleCurrentChange: (folder: Folder) => {         selectedFolder.value = folder.id       },       goToArboView,       defaultProps: {         label: 'id',         children: 'children'       }     }   } }) </script>","describe('MainViewTree', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoTreeWrapper = findNattoTree(wrapper)     searchItemWrapper = findSearchTreeItem(wrapper)   })    describe('bindings with NattoTree', () => {     test('props bindings', () => {       expect(nattoTreeWrapper.attributes()).toStrictEqual({         data: `${useFoldersData().FoldersData.collection}`,         props: `${{ label: 'id', children: 'children' }}`       })     })     describe('events', () => {       it('should select the folder', async () => {         // Given SearchTreeItem isFolderSelected is false         expect(searchItemWrapper.props('isFolderSelected')).toBe(false)          // When NattoTree emit current-change with a folder         await nattoTreeWrapper.vm.$emit(           'current-change',           useFoldersData().FoldersData.collection[0]         )          await flushPromises()          // Then SearchTreeItem isFolderSelected prop must be at true         expect(searchItemWrapper.props('isFolderSelected')).toBe(true)       })     })   })   describe('bindings with SearchTreeItem', () => {     test('props', () => {       expect(searchItemWrapper.props()).toStrictEqual({         folder: useFoldersData().FoldersData.collection[0],         isFolderSelected: false       })     })     describe('events', () => {       it('should go to arbo view when search item emit click', async () => {         await searchItemWrapper.vm.$emit('click')          expect(router.push).toHaveBeenCalledWith({           name: 'ArboView',           query: { folderId: 1122 } // Id of first folder in collection         })       })     })   }) }) "
"<template>   <div     class=""search-tree__item""     :class=""{ 'search-tree__item--disabled': disabled }""   >     <span       class=""search-tree__item__name""       :class=""{ 'search-tree__item__name--active': isFolderSelected }""     >       {{ folder.name }}     </span>     <span       v-if=""folder?.children?.length > 0""       class=""search-tree__item__children-length""       :class=""{         'search-tree__item__children-length--active': isFolderSelected       }""     >       {{ folder?.children?.length }}     </span>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder'  export default defineComponent({   name: 'SearchTreeItem',    props: {     folder: Folder,     isFolderSelected: Boolean   } }) </script>","describe('SearchTreeItem', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('should render the folder name and the folder children length', () => {       expect(wrapper.text()).toContain('A classer')       expect(wrapper.text()).toContain('1')     })     it.each([       {         isFolderSelected: true,         activeNameExist: true,         activeChildrenLength: true       },       {         isFolderSelected: false,         activeNameExist: false,         activeChildrenLength: false       }     ])(       'should add active classes when the folder is selected',       ({ isFolderSelected, activeChildrenLength, activeNameExist }) => {         wrapper = createWrapper({           ...defaultProps,           isFolderSelected         })          expect(wrapper.find('.search-tree__item__name--active').exists()).toBe(           activeNameExist         )         expect(           wrapper.find('.search-tree__item__children-length--active').exists()         ).toBe(activeChildrenLength)       }     )   }) }) "
"<template>   <natto-table     :table-data=""documents.collection""     :loading=""documents.state === 'loading'""     :hide-header=""hideHeader""     :infinite-scroll-finished=""areAllDocumentsLoaded""     :cell-class-name=""documentsCellClassName""     @on-scroll-to-bottom=""handleScrollToBottom""     @row-clicked=""$emit('document-clicked', $event)""   >     <document-type />     <document-name-element :search=""search"" display-description />     <document-creation-date />     <document-sync-status-element v-if=""isCollabUser"" />     <document-actions       display-go-to       @goto-clicked=""handleGoTo""       @delete-clicked=""handleDeleteFileClicked""       @download-clicked=""$emit('on-download-document', $event.documentId)""     />   </natto-table>   <delete-file-modal-confirmation     v-model=""fileDeleteModalState.isDeleteFileModalConfirmationOpened""     :document-ids=""fileDeleteModalState.documentId""     :is-synchronized-document=""fileDeleteModalState.isSynchronizedDocument""   /> </template>  <script lang=""ts""> import { defineComponent, reactive } from 'vue' import NattoTable from '@/Common/components/Table/NattoTable.vue' import DocumentCreationDate from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentCreationDateElement.vue' import DocumentNameElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentNameElement.vue' import DocumentActions from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentActionsElement.vue' import DocumentSyncStatusElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentSyncStatusElement.vue' import Documents from '@/modules/Search/models/Documents/Inputs/Documents' import DocumentType from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentTypeElement.vue' import DeleteFileModalConfirmation from '@/modules/DataManipulation/Delete/DeleteFile/components/Modals/DeleteFileModalConfirmation.vue' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'DocumentsTable',   components: {     DocumentType,     DocumentActions,     DocumentNameElement,     DocumentCreationDate,     NattoTable,     DocumentSyncStatusElement,     DeleteFileModalConfirmation   },    props: {     documents: {       type: Documents,       required: true     },     hideHeader: Boolean,     areAllDocumentsLoaded: Boolean,     isCollabUser: Boolean,     search: String   },    emits: ['on-download-document', 'on-scroll-to-bottom', 'document-clicked'],    setup(props, { emit }) {     const { goToArboView } = useSearchNavigator()      const documentsCellClassName = ({       columnIndex     }: {       row: unknown       column: unknown       rowIndex: number       columnIndex: number     }): string => {       if (columnIndex === 0) {         // Index 0 is the column of the file type icon          return 'justify-center'       }        return ''     }      const fileDeleteModalState = reactive({       isDeleteFileModalConfirmationOpened: false,       documentId: [] as string[],       isSynchronizedDocument: false     })      const handleGoTo = ({ folderId }: { folderId: number }) => {       goToArboView({ folderId })     }      const handleDeleteFileClicked = (args: {       documentId: string       isSynchronizedDocument: boolean     }) => {       fileDeleteModalState.documentId = [args.documentId]       fileDeleteModalState.isDeleteFileModalConfirmationOpened = true       fileDeleteModalState.isSynchronizedDocument = args.isSynchronizedDocument     }      const handleScrollToBottom = () => {       emit('on-scroll-to-bottom')     }      return {       documentsCellClassName,       fileDeleteModalState,       handleDeleteFileClicked,       handleScrollToBottom,       handleGoTo     }   } }) </script>","describe('DocumentsTable', () => {   beforeEach(() => {     wrapper = createWrapper()     documentActionElementWrapper = findDocumentActionsElement(wrapper)   })    describe('DocumentsNameElement bindings', () => {     test('props bindings', () => {       const documentNameElementWrapper = findDocumentNameElement(wrapper)        expect(documentNameElementWrapper.vm.search).toBe('test')     })   })    describe('DocumentActionsElement bindings', () => {     test('props bindings', () => {       expect(documentActionElementWrapper.props()).toStrictEqual({         displayGoTo: true       })     })     describe('events', () => {       it('Should open delete folder modal when delete-clicked', async () => {         await documentActionElementWrapper.vm.$emit('delete-clicked', {           documentId: '1234',           isSynchronizedDocument: true         })          const deleteFileModalConfirmationWrapper: VueWrapper<any> =           wrapper.findComponent(DeleteFileModalConfirmation)          expect(deleteFileModalConfirmationWrapper.props('modelValue')).toBe(           true         )         expect(           deleteFileModalConfirmationWrapper.props('documentIds')         ).toStrictEqual(['1234'])         expect(           deleteFileModalConfirmationWrapper.props('isSynchronizedDocument')         ).toBe(true)       })       it('Should go to arboView if goto-clicked is emitted', async () => {         await documentActionElementWrapper.vm.$emit('goto-clicked', {           documentId: '1234',           isSynchronizedDocument: true,           folderId: 9876         })          expect(router.push).toHaveBeenCalledWith({           name: 'ArboView',           query: { folderId: 9876 }         })       })        it('should send an on-download-document event, when download-clicked event is sent to from DocumentActions', async () => {         await documentActionElementWrapper.vm.$emit('download-clicked', {           documentId: '1234',           isSynchronizedDocument: true         })          expect(wrapper.emitted('on-download-document')).toBeTruthy()         expect(wrapper.emitted('on-download-document')).toEqual([['1234']])       })     })   })    describe('Natto Table bindings', () => {     describe('props', () => {       it('should pass props to the NattoTable props', () => {         // Given the documents are defined         wrapper = createWrapper({           documents: Documents.loaded([documentAPIMock]),           hideHeader: true,           areAllDocumentsLoaded: true,           isCollabUser: false         })          // Then the Documents.collection must be passed to the NattoTable         const nattoTableWrapper = findNattoTable(wrapper)          expect(nattoTableWrapper.vm.tableData).toEqual([           {             comments: 'je suis le bilan comptable',             createdBy: '',             id: 'myID',             folderId: 45454,             name: 'Mon bilan comptable',             creationDate: '2018-05-27',             path: [],             properties: new Properties({ syncStatus: constants.PENDING_SYNC }),             restorationStatus: '',             size: 54545,             type: 'jpg',             updatedDate: '2018-05-27',             preview: '',             lifecycleStatus: LifeCycleStatus.Treated           }         ])         expect(nattoTableWrapper.vm.hideHeader).toBe(true)         expect(nattoTableWrapper.vm.cellClassName).toBe(           wrapper.vm.documentsCellClassName         )         expect(nattoTableWrapper.vm.infiniteScrollFinished).toBe(true)       })     })     describe('events', () => {       it('should emit document-clicked when NattoTable emits row-clicked', () => {         const nattoTableWrapper = findNattoTable(wrapper)          const document = new Document()          document.id = 'TEST'         nattoTableWrapper.vm.$emit('row-clicked', document)          expect(wrapper.emitted('document-clicked')).toHaveLength(1)         expect(wrapper.emitted('document-clicked')).toStrictEqual([[document]])         expect(wrapper.emitted('document-clicked')).toBeTruthy()       })       it('should emit on-scroll-to-bottom when NattoTable emits on-scroll-to-bottom', () => {         const nattoTableWrapper = findNattoTable(wrapper)          nattoTableWrapper.vm.$emit('on-scroll-to-bottom')          expect(wrapper.emitted('on-scroll-to-bottom')).toHaveLength(1)         expect(wrapper.emitted('on-scroll-to-bottom')).toBeTruthy()       })       it('should return justify-center class for first column and empty string for others column', () => {         // Given         expect(wrapper.vm.documentsCellClassName({ columnIndex: 0 })).toBe(           'justify-center'         )         expect(wrapper.vm.documentsCellClassName({ columnIndex: 1 })).toBe('')       })     })     describe('rendering', () => {       it('should not render ged sync icon when isCollabUser is false', () => {         expect(           wrapper.findComponent(DocumentSyncStatusElement).exists()         ).toBeFalsy()       })        it('should not render ged sync icon when isCollabUser is true', () => {         wrapper = createWrapper({           documents: Documents.loaded([documentAPIMock]),           hideHeader: true,           areAllDocumentsLoaded: true,           isCollabUser: true         })         expect(           wrapper.findComponent(DocumentSyncStatusElement).exists()         ).toBeTruthy()       })     })   }) }) "
"<template>   <natto-drop-zone     class=""arbo-documents__drop-zone""     :disabled=""isTableDropZoneDisabled""     @files-changes=""handleDroppedFiles""   >     <multiple-documents-ctas       :selected-documents-ids=""state.selectedDocumentsIds""       @download-all-clicked=""handleDownloadAll""       @delete-all-clicked=""handleDeleteAll""     />     <template #over-content>       <arbo-documents-table-drop-zone-content />     </template>     <div class=""arbo-documents__table"">       <natto-table         ref=""nattoTableRef""         hide-header         :are-all-selected=""areAllSelected""         :table-data=""documents.collection""         :loading=""documents.isLoading""         :items-per-page=""documentsPerPage""         :items-total=""documentsTotalInFolderAndChild""         :pageNumber=""pageNumber""         :sort-options=""sortOptions""         paginated         highlight-row-on-click         is-selection         @page-opened=""handlePageOpened""         @sort-arbo-table=""propagateSortEvent""         @row-clicked=""handleRowClick""         @selection-change=""selectionChangeHandler""         @select-all=""handleSelectAll""       >         <template #prepend-table>           <documents-folders-browser             v-if=""!isSearchActive""             v-model:search-folder-id=""searchFolder""             :folders=""folders""           />           <documents-in-folder-and-child-bar             v-if=""isSearchActive""             :nb-documents-in-folder-and-child=""documentsTotalInFolderAndChild""           />         </template>         <template #default>           <document-name-element             :display-description=""isSearchActive""             :search=""search""           />           <document-creation-date-element />           <document-sync-status-element v-if=""isCollabUser"" />           <document-actions-element             :display-go-to=""isSearchActive""             @document-dropdown-clicked=""handleActionDropdownClicked""             @download-clicked=""$emit('on-download-document', $event.documentId)""             @delete-clicked=""handleDeleteFileClicked""             @goto-clicked=""handleGoTo""             @actions-activator-selected=""handleActivatorSelection""           />         </template>         <template #append-table>           <documents-in-all-folders-bar             v-if=""isSearchActive""             :nb-documents-in-all-folders=""documentsTotalInAllFolders""             @click=""$emit('click-on-total-count')""           />         </template>       </natto-table>     </div>   </natto-drop-zone>   <delete-file-modal-confirmation     v-model=""state.isDeleteFileModalConfirmationOpened""     :document-ids=""state.selectedDocumentsIds""     :is-synchronized-document=""state.isSynchronizedDocument""     @delete-file-confirmed=""$emit('delete-file-confirmed')""   /> </template>  <script lang=""ts""> import { computed, defineComponent, reactive, ref } from 'vue' import useVModel from '@/Common/hooks' import NattoTable from '@/Common/components/Table/NattoTable.vue'  import Documents from '@/modules/Search/models/Documents/Inputs/Documents' import Folders from '@/modules/Search/models/Folders/Inputs/Folders'  import DocumentsFoldersBrowser from '@/modules/Search/components/Navigation/DocumentsFoldersBrowser.vue' import DocumentNameElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentNameElement.vue' import DocumentCreationDateElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentCreationDateElement.vue' import DocumentActionsElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentActionsElement.vue' import DocumentsInAllFoldersBar from '@/modules/Search/components/Filters/InfoBars/DocumentsInAllFoldersBar.vue' import DocumentsInFolderAndChildBar from '@/modules/Search/components/Filters/InfoBars/DocumentsInFolderAndChildBar.vue' import DocumentSyncStatusElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentSyncStatusElement.vue' import DeleteFileModalConfirmation from '@/modules/DataManipulation/Delete/DeleteFile/components/Modals/DeleteFileModalConfirmation.vue' import DocumentsSortOptions from '@/modules/Search/models/Documents/Query/DocumentsSortOptions' import NattoDropZone from '@/Common/components/Upload/NattoDropZone.vue' import ArboDocumentsTableDropZoneContent from '@/modules/Search/components/DocumentsTable/ArboDocumentsTableDropZoneContent.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import MultipleDocumentsCtas from '@/modules/Search/components/Buttons/MultipleDocumentsCtas/MultipleDocumentsCtas.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import { isString } from 'lodash'  export default defineComponent({   name: 'ArboDocumentsTable',   components: {     MultipleDocumentsCtas,     ArboDocumentsTableDropZoneContent,     NattoDropZone,     DocumentsInFolderAndChildBar,     DocumentsInAllFoldersBar,     DocumentActionsElement,     DocumentCreationDateElement,     DocumentNameElement,     NattoTable,     DocumentsFoldersBrowser,     DocumentSyncStatusElement,     DeleteFileModalConfirmation   },   props: {     sortOptions: {       type: DocumentsSortOptions,       required: false     },     folders: {       type: Folders,       required: true     },     documents: {       type: Documents,       required: true     },     searchFolderId: {       type: Number,       required: true     },     documentsPerPage: {       type: Number,       required: true     },     documentsTotalInFolderAndChild: {       type: Number,       default: 0     },     documentsTotalInAllFolders: {       type: Number,       default: 0     },     isCollabUser: {       type: Boolean,       default: false     },     pageNumber: {       type: Number,       default: 1     },     search: String,     isTableDropZoneDisabled: Boolean   },   emits: [     'update:searchFolderId',     'onDownloadDocument',     'click-on-total-count',     'page-opened',     'sort-arbo-table',     'files-dropped',     'document-clicked',     'delete-file-confirmed',     'on-actions-click'   ],    setup(props, { emit }) {     const store = useStore()     const {       dispatchDownloadDocuments,       setSearchFolderId,       filters,       setSearch,       fetchDocuments     } = useSearchStoreHelpers()      const nattoTableRef = ref(null as any)     const searchFolder = useVModel(props, 'searchFolderId')      const state = reactive({       isDeleteFileModalConfirmationOpened: false,       selectedDocumentsIds: [] as string[],       isSynchronizedDocument: false     })      const handleActionDropdownClicked = (documentId: string) => {       if (         documentId &&         (!state.selectedDocumentsIds ||           state.selectedDocumentsIds?.length === 0 ||           !state.selectedDocumentsIds?.every((docId) => docId === documentId))       ) {         clearTableSelection(documentId)       }     }      const handleDeleteFileClicked = (args: {       documentId: string       isSynchronizedDocument: boolean     }) => {       clearTableSelection(args.documentId)       state.isDeleteFileModalConfirmationOpened = true       state.isSynchronizedDocument = args.isSynchronizedDocument     }     const clearTableSelection = (documentId: string) => {       nattoTableRef.value?.clearSelection()       if (documentId) {         nattoTableRef.value?.selectRow(documentId)         state.selectedDocumentsIds = [documentId]       }     }      const handlePageOpened = (pageNumber: number) => {       emit('page-opened', pageNumber)     }      const handleDroppedFiles = (filesData: File[]) => {       emit('files-dropped', filesData)     }      const handleRowClick = (doc: Document) => {       if (doc.name) {         emit('document-clicked', doc)       }     }      const handleSelectAll = () => {       nattoTableRef.value?.toggleAll()     }      const isSearchActive = computed(() => !!props.search)      const selectionChangeHandler = (documentIds: string[]) => {       if (documentIds.length > 0 && !isString(documentIds[0])) {         return       }        state.selectedDocumentsIds = documentIds     }      const handleActivatorSelection = (documentId: string) => {       const document = props.documents?.collection.filter(         (d) => d.id === documentId       )[0]        emit('on-actions-click', document)     }      const handleDeleteAll = async () => {       state.isDeleteFileModalConfirmationOpened = true     }      const handleDownloadAll = async () => {       await dispatchDownloadDocuments(store, state.selectedDocumentsIds)     }      const handleGoTo = async ({ folderId }: { folderId: number }) => {       setSearchFolderId(store, {         searchFolderId: folderId,         findInChildFolders: filters(store).value.findInChildFolders       })       setSearch(store, '')       await fetchDocuments(store)     }      const areAllSelected = computed(       () =>         props.documents.collection.length ===           state.selectedDocumentsIds.length &&         props.documents.collection.length !== 0     )      return {       areAllSelected,       handleActionDropdownClicked,       clearTableSelection,       nattoTableRef,       selectionChangeHandler,       handleDroppedFiles,       state,       searchFolder,       handleDeleteFileClicked,       handlePageOpened,       propagateSortEvent: (data: DocumentsSortOptions) => {         emit('sort-arbo-table', data)       },       handleRowClick,       isSearchActive,       handleActivatorSelection,       handleDeleteAll,       handleDownloadAll,       handleSelectAll,       handleGoTo     }   } }) </script>","describe('ArboDocumentsTable', () => {   beforeEach(() => {     // Given ArboDocumentsTable is mounted     wrapper = createWrapper()     nattoDropZoneWrapper = findNattoDropZone(wrapper)     multipleDocumentsCtas = findMultipleDocumentsCtas(wrapper)   })    describe('binding with natto-drop-zone', () => {     describe('props', () => {       it('should call uploadFiles on drop', async () => {         // Given the isTableDropZoneDisabled prop is true         wrapper = createWrapper({           ...defaultProps,           isTableDropZoneDisabled: true         })          nattoDropZoneWrapper = findNattoDropZone(wrapper)          // Then the disabled prop of the NattoDropZone must also be true         expect(nattoDropZoneWrapper.props('disabled')).toBe(true)       })     })     describe('events', () => {       it('should emit files-dropped when NattoDropZone emit files-changes', () => {         // Given we drop a file         const files = [new File(['test'], 'test.txt', { type: 'text/plain' })]          // When NattoDropZone emit files-changes         nattoDropZoneWrapper.vm.$emit('files-changes', files)          // Then ArboDocumentsTable must emit files-dropped         expect(wrapper.emitted('files-dropped')).toHaveLength(1)         expect(wrapper.emitted('files-dropped')).toEqual([[files]])       })     })   })    describe('bindings with NattoTable', () => {     describe('props', () => {       it('static props', () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          expect(nattoTableWrapper.vm.tableData).toEqual([           {             comments: 'je suis le bilan comptable',             createdBy: '',             creationDate: '2018-05-27',             folderId: 45454,             id: 'myID',             name: 'Mon bilan comptable',             path: [],             properties: {               syncStatus: constants.PENDING_SYNC,               hasSubscribedToVault: false             },             restorationStatus: '',             size: 54545,             type: 'jpg',             updatedDate: '2018-05-27',             preview: '',             lifecycleStatus: LifeCycleStatus.Treated           }         ])         expect(nattoTableWrapper.vm.hideHeader).toBe(true)         expect(nattoTableWrapper.vm.itemsPerPage).toBe(10)         expect(nattoTableWrapper.vm.itemsTotal).toBe(5201)         expect(nattoTableWrapper.vm.pageNumber).toBe(1)         expect(nattoTableWrapper.vm.paginated).toBe(true)         expect(nattoTableWrapper.vm.loading).toBe(false)         expect(nattoTableWrapper.vm.sortOptions).toEqual(           defaultProps.sortOptions         )         expect(nattoTableWrapper.vm.highlightRowOnClick).toEqual(true)         expect(nattoTableWrapper.props('isSelection')).toBe(true)         expect(nattoTableWrapper.props('areAllSelected')).toBe(false)       })       describe('areAllSelected', () => {         it.each([           {             documents: Documents.loading(''),             selectionIds: [],             areAllSelected: false           },           {             documents: Documents.loading(''),             selectionIds: ['19'],             areAllSelected: false           },           {             documents: Documents.loaded([{ id: '19' } as DocumentFromAPI]),             selectionIds: [],             areAllSelected: false           },           {             documents: Documents.loaded([               { id: '19' },               { id: '27' }             ] as DocumentFromAPI[]),             selectionIds: ['27'],             areAllSelected: false           },           {             documents: Documents.loaded([{ id: '19' } as DocumentFromAPI]),             selectionIds: ['19'],             areAllSelected: true           }         ])(           'areSelected must be true only if we have documents and the selectedIds is the same length as the collection',           async ({ documents, selectionIds, areAllSelected }) => {             wrapper = createWrapper({               ...defaultProps,               documents             })              const nattoTableWrapper: NattoTableWrapper =               wrapper.findComponent(NattoTable)              await nattoTableWrapper.vm.$emit('selection-change', selectionIds)              expect(wrapper.vm.areAllSelected).toBe(areAllSelected)           }         )       })     })     describe('events', () => {       it('should emit page-opened when NattoTable emits page-opened', async () => {         // When NatoTable emits page-opened         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          await nattoTableWrapper.vm.$emit('page-opened', 2)          // Then ArboDocumentsTable must emit page-opened too         expect(wrapper.emitted('page-opened')).toHaveLength(1)         expect(wrapper.emitted('page-opened')).toEqual([[2]])       })       it('Should emit sort-arbo-table on sort-arbo-table', async () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          await nattoTableWrapper.vm.$emit(           'sort-arbo-table',           defaultProps.sortOptions         )          expect(wrapper.emitted('sort-arbo-table')).toHaveLength(1)         expect(wrapper.emitted('sort-arbo-table')).toStrictEqual([           [defaultProps.sortOptions]         ])       })       it('Should emit document-clicked when row-clicked on table ', () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          nattoTableWrapper.vm.$emit('row-clicked', { id: 1, name: 'test' })         expect(wrapper.emitted('document-clicked')).toEqual([           [{ id: 1, name: 'test' }]         ])       })       it('Should not emit document-clicked when row-clicked on table with a document.name property', () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          nattoTableWrapper.vm.$emit('row-clicked', { id: 1 })         expect(wrapper.emitted('document-clicked')).toBeFalsy()       })       it('should call the toggleAll method of ElTable when NattoTable emits select-all', () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          nattoTableWrapper.vm.toggleAll = jest.fn()          nattoTableWrapper.vm.$emit('select-all')          expect(nattoTableWrapper.vm.toggleAll).toHaveBeenCalled()       })     })   })    describe('bindings with DocumentsFolderBrowser', () => {     describe('rendering', () => {       const displayCases = [         { search: '', displayDocumentsFolderBrowser: true },         { search: 'test', displayDocumentsFolderBrowser: false }       ]        test.each(displayCases)(         'isSearchActive: $isSearchActive => displayDocumentsFolderBrowser: $displayDocumentsFolderBrowser',         ({ search, displayDocumentsFolderBrowser }) => {           wrapper = createWrapper({ ...defaultProps, search })           expect(wrapper.findComponent(DocumentsFoldersBrowser).exists()).toBe(             displayDocumentsFolderBrowser           )         }       )     })     describe('props', () => {       // Given DocumentsFolderBrowser is displayed       wrapper = createWrapper({ ...defaultProps, search: '' })        const documentsFoldersBrowserWrapper: DocumentsFoldersBrowserTypeWrapper =         wrapper.findComponent(DocumentsFoldersBrowser)        expect(documentsFoldersBrowserWrapper.vm.folders).toStrictEqual(         Folders.loading()       )     })     describe('events', () => {       describe('goto-clicked', () => {         it('Should set the folderId, reset the search and fetch the documents when goto-clicked fired', async () => {           const store = createSearchStoreMocked()            store.dispatch = jest.fn()           wrapper = createWrapper({ ...defaultProps, search: '' }, store)           const documentActionElementWrapper: DocumentActionsElementWrapper =             wrapper.findComponent(DocumentActionsElement)            await documentActionElementWrapper.vm.$emit('goto-clicked', {             documentId: '1234',             isSynchronizedDocument: true,             folderId: 9876           })            expect(store.dispatch).toHaveBeenNthCalledWith(             1,             searchModule('setFilters'),             {               certified: 'all',               findInChildFolders: false,               folderId: 9876,               period: {                 endDate: '',                 startDate: ''               },               search: ''             }           )           expect(store.dispatch).toHaveBeenNthCalledWith(             2,             searchModule('setFilters'),             {               certified: 'all',               findInChildFolders: false,               folderId: 0,               period: {                 endDate: '',                 startDate: ''               },               search: ''             }           )           expect(store.dispatch).toHaveBeenNthCalledWith(             3,             searchModule('fetchDocuments')           )         })       })       describe('download-clicked', () => {         it('Should emit on-download-document when download-clicked fired', async () => {           // Given DocumentsFolderBrowser is displayed           wrapper = createWrapper({ ...defaultProps, search: '' })           const documentActionElementWrapper: VueWrapper<any> =             wrapper.findComponent(DocumentActionsElement)            await documentActionElementWrapper.vm.$emit('download-clicked', {             documentId: '1234',             isSynchronizedDocument: true           })            expect(wrapper.emitted('on-download-document')).toHaveLength(1)           expect(wrapper.emitted('on-download-document')).toEqual([['1234']])         })       })        describe('document-dropdown-clicked', () => {         it.each([           {             selectedDocumentIds: [               'document-id-1',               'document-id-2',               'document-id-3'             ],             selectedDocumentActionId: 'document-id-1',             expectedSelectedDocument: ['document-id-1']           },           {             selectedDocumentIds: [               'document-id-1',               'document-id-2',               'document-id-3'             ],             selectedDocumentActionId: 'document-id-X',             expectedSelectedDocument: ['document-id-X']           },           {             selectedDocumentIds: [],             selectedDocumentActionId: 'document-id-1',             expectedSelectedDocument: ['document-id-1']           }         ])(           'Should reset document selection when document-dropdown-clicked is fired',           async ({             selectedDocumentIds,             selectedDocumentActionId,             expectedSelectedDocument           }) => {             // Given DocumentsFolderBrowser is displayed             wrapper = createWrapper({ ...defaultProps, search: '' })              const documentActionElementWrapper: VueWrapper<any> =               wrapper.findComponent(DocumentActionsElement)              const nattoTableWrapper: NattoTableWrapper =               wrapper.findComponent(NattoTable)              nattoTableWrapper.vm.clearSelection = jest.fn()             nattoTableWrapper.vm.mpTableRef.handleRowClick = jest.fn()             nattoTableWrapper.vm.$emit('selection-change', selectedDocumentIds)             documentActionElementWrapper.vm.$emit(               'document-dropdown-clicked',               selectedDocumentActionId             )             await wrapper.vm.$nextTick()              multipleDocumentsCtas = findMultipleDocumentsCtas(wrapper)             expect(nattoTableWrapper.vm.clearSelection).toHaveBeenCalled()             expect(               multipleDocumentsCtas.props('selectedDocumentsIds')             ).toStrictEqual(expectedSelectedDocument)           }         )       })       describe('delete-clicked', () => {         it.each([           {             selectedDocumentIds: [               'document-id-1',               'document-id-2',               'document-id-3'             ],             selectedDocumentActionId: 'document-id-1',             expectedDeletedDocumentId: ['document-id-1']           },           {             selectedDocumentIds: [               'document-id-1',               'document-id-2',               'document-id-3'             ],             selectedDocumentActionId: 'document-id-X',             expectedDeletedDocumentId: ['document-id-X']           },           {             selectedDocumentIds: [],             selectedDocumentActionId: 'document-id-1',             expectedDeletedDocumentId: ['document-id-1']           }         ])(           'Should open delete popup for expectedDeletedDocumentId when selectedDocumentIds and deleted action is on the selectedDocumentActionId',           async ({             selectedDocumentActionId,             expectedDeletedDocumentId,             selectedDocumentIds           }) => {             // Given DocumentsFolderBrowser is displayed             wrapper = createWrapper({ ...defaultProps, search: '' })             const documentActionElementWrapper: VueWrapper<any> =               wrapper.findComponent(DocumentActionsElement)              const nattoTableWrapper: NattoTableWrapper =               wrapper.findComponent(NattoTable)              nattoTableWrapper.vm.$emit('selection-change', selectedDocumentIds)             nattoTableWrapper.vm.clearSelection = jest.fn()             nattoTableWrapper.vm.mpTableRef.handleRowClick = jest.fn()              await documentActionElementWrapper.vm.$emit('delete-clicked', {               documentId: selectedDocumentActionId,               isSynchronizedDocument: true             })              const deleteFileModalConfirmationWrapper: VueWrapper<any> =               wrapper.findComponent(DeleteFileModalConfirmation)              expect(nattoTableWrapper.vm.clearSelection).toHaveBeenCalled()             expect(deleteFileModalConfirmationWrapper.props('modelValue')).toBe(               true             )             expect(               deleteFileModalConfirmationWrapper.props('documentIds')             ).toStrictEqual(expectedDeletedDocumentId)             expect(               deleteFileModalConfirmationWrapper.props('isSynchronizedDocument')             ).toBe(true)           }         )       })       it('Should emit delete-file-confirmed when DeleteFileModalConfirmation emits delete-file-confirmed', async () => {         wrapper = createWrapper({ ...defaultProps, search: '' })          const deleteFileModalConfirmationWrapper: VueWrapper<any> =           wrapper.findComponent(DeleteFileModalConfirmation)          await deleteFileModalConfirmationWrapper.vm.$emit(           'delete-file-confirmed'         )          expect(wrapper.emitted('delete-file-confirmed')).toHaveLength(1)       })       it('Should emit update:selectedFolderToUpload when DocumentsFolderBrowser emits update:selectedFolderToUpload', async () => {         // Given DocumentsFolderBrowser is displayed         wrapper = createWrapper({ ...defaultProps, search: '' })          // When documentsViewHeaderWrapper emits update:selectedFolderToUpload         const documentsFoldersBrowserWrapper: DocumentsFoldersBrowserTypeWrapper =           wrapper.findComponent(DocumentsFoldersBrowser)          await documentsFoldersBrowserWrapper.vm.$emit(           'update:searchFolderId',           27         )          // Then update:selectedFolderToUpload must be emitted with 27         expect(wrapper.emitted('update:searchFolderId')).toStrictEqual([[27]])       })     })   })    describe('Bindings with DocumentsInFolderAndChildBar', () => {     describe('Rendering', () => {       describe('Display or NOT DocumentsInFolderAndChildBar', () => {         const displayCases = [           { search: '', expected: false },           { search: 'test', expected: true }         ]          test.each(displayCases)(           'Should DocumentsInFolderAndChildBar have display at $expect if isSearchActive prop is $isSearchActive',           ({ search, expected }) => {             wrapper = createWrapper({ ...defaultProps, search })             expect(               wrapper.findComponent(DocumentsInFolderAndChildBar).exists()             ).toBe(expected)           }         )       })     })     describe('Props', () => {       it('Should have nbDocumentsInFolderAndChild set at 1', () => {         const documentsInFolderAndChildBarWrapper: VueWrapper<           ComponentPublicInstance<{ nbDocumentsInFolderAndChild: number }>         > = wrapper.findComponent(DocumentsInFolderAndChildBar)          expect(           documentsInFolderAndChildBarWrapper.vm.nbDocumentsInFolderAndChild         ).toBe(5201)       })     })   })    describe('Bindings with DocumentsInAllFolders', () => {     describe('Rendering', () => {       describe('Display or NOT DocumentsInAllFolders', () => {         const displayCases = [           { search: '', expected: false },           { search: 'test', expected: true }         ]          test.each(displayCases)(           'Should DocumentsInAllFoldersBar have display at $expect if search prop is $search',           ({ search, expected }) => {             wrapper = createWrapper({ ...defaultProps, search })             expect(               wrapper.findComponent(DocumentsInAllFoldersBar).exists()             ).toBe(expected)           }         )       })     })     describe('Props', () => {       it('Should have nbDocumentsInFolderAndChild set at 75201', () => {         const documentsInAllFoldersBarWrapper: VueWrapper<           ComponentPublicInstance<{ nbDocumentsInAllFolders: number }>         > = wrapper.findComponent(DocumentsInAllFoldersBar)          expect(documentsInAllFoldersBarWrapper.vm.nbDocumentsInAllFolders).toBe(           75201         )       })     })     describe('Events', () => {       it('Should emit click-on-total-count when DocumentsInAllFoldersBar emit click', async () => {         // Given DocumentsInAllFoldersBar is displayed         wrapper = createWrapper({ ...defaultProps, search: 'test' })          // When DocumentsInAllFoldersBar emit click         const documentsInAllFoldersBarWrapper: VueWrapper<           ComponentPublicInstance<{ nbDocumentsInAllFolders: number }>         > = wrapper.findComponent(DocumentsInAllFoldersBar)          await documentsInAllFoldersBarWrapper.vm.$emit('click')          // Then ArboDocumentsTable should emit click-on-total-count         expect(wrapper.emitted('click-on-total-count')).toBeTruthy()       })     })   })    describe('bindings with DocumentSyncStatusElement', () => {     describe('rendering', () => {       it('should not render ged sync icon when isCollabUser is false', () => {         wrapper = createWrapper({ ...defaultProps, search: 'test' })          expect(           wrapper.findComponent(DocumentSyncStatusElement).exists()         ).toBeFalsy()       })        it('should not render ged sync icon when isCollabUser is true', () => {         wrapper = createWrapper({           ...defaultProps,           documents: Documents.loaded([documentAPIMock]),           folders: Folders.loading(),           searchFolderId: 27,           documentsPerPage: 10,           documentsTotalInFolderAndChild: 5201,           documentsTotalInAllFolders: 75201,           search: 'test',           isCollabUser: true,           pageNumber: 1         })          expect(           wrapper.findComponent(DocumentSyncStatusElement).exists()         ).toBeTruthy()       })     })   })    describe('bindings with MultipleDocumentsCtas', () => {     test('static props', async () => {       const nattoTableWrapper: NattoTableWrapper =         wrapper.findComponent(NattoTable)        nattoTableWrapper.vm.$emit('selection-change', ['27'])        await flushPromises()        multipleDocumentsCtas = findMultipleDocumentsCtas(wrapper)        expect(multipleDocumentsCtas.props('selectedDocumentsIds')).toStrictEqual(         ['27']       )     })     describe('events', () => {       it('should open the deleteFileModalConfirmation when delete-all-clicked is emitted', async () => {         // When download-all-clicked is emitted         multipleDocumentsCtas = findMultipleDocumentsCtas(wrapper)          await multipleDocumentsCtas.vm.$emit('delete-all-clicked')          expect(           findDeleteFileModalConfirmation(wrapper).props('modelValue')         ).toBe(true)       })       it('should dispatchDownloadDocuments when download-all-clicked is emitted', async () => {         const store = createSearchStoreMocked()          // Given a new store is init         store.dispatch = jest.fn()          wrapper = createWrapper(defaultProps, store)          // When download-all-clicked is emitted         multipleDocumentsCtas = findMultipleDocumentsCtas(wrapper)          await multipleDocumentsCtas.vm.$emit('download-all-clicked')          await flushPromises()          // Then the store must dispatch the downloadDocuments action         expect(store.dispatch).toHaveBeenCalledWith(           searchModule('downloadDocuments'),           []         )       })     })   }) }) "
"<template>   <documents-table-element label=""Actions"" width=""10%"">     <template #item=""{ props }"">       <div class=""document-actions-container"">         <natto-dropdown>           <template #activator>             <document-actions-dropdown-activator               @click=""$emit('document-dropdown-clicked', props.id)""             />           </template>           <template #list>             <document-actions-dropdown-list               :document-id=""props.id""               :display-go-to=""displayGoTo""               @item-clicked=""handleAction($event, props)""             />           </template>         </natto-dropdown>       </div>     </template>     <template #header>       <document-action-header />     </template>   </documents-table-element> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DocumentActionHeader from '@/modules/Search/components/DocumentsTable/DocumentsTableHeaders/DocumentActionHeader.vue' import DocumentsTableElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentsTableElement.vue' import NattoDropdown from '@/Common/components/Dropdown/NattoDropdown.vue' import DocumentActionsDropdownActivator from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentActionsDropdownActivator.vue' import DocumentActionsDropdownList from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentActionsDropdownList.vue' import { ITEMS } from '@/Common/types/actionItemTypes' import Document from '@/modules/Search/models/Documents/Inputs/Document'  export default defineComponent({   name: 'DocumentActionsElement',   components: {     DocumentsTableElement,     DocumentActionHeader,     NattoDropdown,     DocumentActionsDropdownActivator,     DocumentActionsDropdownList   },   props: {     displayGoTo: Boolean   },   setup(props, { emit }) {     const handleAction = (action: ITEMS, document: Document) => {       emit('actions-activator-selected', document.id)       emit(`${action}-clicked`, {         documentId: document.id,         isSynchronizedDocument: document.isSync,         folderId: document.folderId       })     }      return {       handleAction     }   } }) </script>","describe('DocumentActionsElement', () => {   beforeEach(() => {     wrapper = createWrapper()     documentActionsDropdownList = findDocumentActionsDropdownList(wrapper)     documentActionsDropdownActivator =       findDocumentActionsDropdownActivator(wrapper)   })    describe('bindings with DocumentActionsDropdownList', () => {     describe('props', () => {       test('static props', () => {         expect(documentActionsDropdownList.props('documentId')).toBe('myID')       })     })     describe('events', () => {       it('should emit goTo-clicked when dropdownList emits item-clicked with goto', async () => {         await documentActionsDropdownList.vm.$emit('item-clicked', ITEMS.GOTO)          expect(wrapper.emitted('goto-clicked')).toHaveLength(1)         expect(wrapper.emitted('goto-clicked')).toStrictEqual([           [             {               documentId: 'myID',               isSynchronizedDocument: true,               folderId: 45454             }           ]         ])       })     })   })   describe('bindings with DocumentActionsDropdownActivator', () => {     describe('events', () => {       it('should emit document-dropdown-clicked when activator emits click', async () => {         await documentActionsDropdownActivator.vm.$emit('click')          expect(wrapper.emitted('document-dropdown-clicked')).toHaveLength(1)         expect(wrapper.emitted('document-dropdown-clicked')).toStrictEqual([           ['myID']         ])       })     })   }) }) "
"<template>   <documents-table-element width=""55%"">     <template #item=""{ props }"">       <div class=""document-name__item"">         <div>           <div class=""document-name__item__name"">             <document-type-item v-if=""!displayDescription"" />             <document-name-item :name=""props.name"" :search=""search"" />           </div>           <document-path-item v-if=""displayDescription"" :path=""props.path"" />         </div>         <document-tags           :has-subscribed-to-vault=""props?.properties?.hasSubscribedToVault""           :is-treated=""props.isTreated""           :is-new=""props.isNew""         />       </div>     </template>     <template #header>       <document-name-header :value=""value"" />     </template>   </documents-table-element> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DocumentNameItem from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentNameItem.vue' import DocumentPathItem from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentPathItem.vue' import DocumentNameHeader from '@/modules/Search/components/DocumentsTable/DocumentsTableHeaders/DocumentNameHeader.vue' import DocumentsTableElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentsTableElement.vue' import DocumentTypeItem from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentTypeItem.vue' import DocumentTags from '@/modules/Search/components/Tags/DocumentTags.vue'  export default defineComponent({   name: 'DocumentNameElement',   components: {     DocumentTags,     DocumentTypeItem,     DocumentsTableElement,     DocumentNameHeader,     DocumentNameItem,     DocumentPathItem   },   props: {     displayDescription: Boolean,     value: String,     search: String   } }) </script>","describe('DocumentNameElement', () => {   beforeEach(() => {     wrapper = createWrapper()     documentTags = findDocumentTags(wrapper)   })    describe('bindings with DocumentTags', () => {     describe('props', () => {       it.each([         {           properties: {} as PropertiesFromAPI,           documentCertifyTagExists: false         },         {           properties: {             ...documentAPIMock.properties,             HasSubscribedToVault: undefined           },           documentCertifyTagExists: false         },         {           properties: {             ...documentAPIMock.properties,             HasSubscribedToVault: 'Oui'           },           documentCertifyTagExists: true         }       ])(         'should render DocumentCertifyTag if the document property hasSubscribedToVault is at true',         ({ properties, documentCertifyTagExists }) => {           // Given the document has the hasSubscribedToVault property at true           const document = new Document({             ...documentAPIMock,             properties           })            // When the wrapper is created with a certified document           wrapper = createWrapper({             DocumentsTableElement: createDocumentsTableElement(document)           })            // Then DocumentCertifyTag must exist           documentTags = findDocumentTags(wrapper)           expect(documentTags.props('hasSubscribedToVault')).toBe(             documentCertifyTagExists           )         }       )       it('should bind isTreated with document getter isTreated', () => {         const document = new Document({           ...documentAPIMock,           lifecycleStatus: LifeCycleStatus.Treated         })          wrapper = createWrapper({           DocumentsTableElement: createDocumentsTableElement(document)         })          documentTags = findDocumentTags(wrapper)         expect(documentTags.props('isTreated')).toBe(true)       })       it('should bind isNew with document getter isNew', () => {         const document = new Document({           ...documentAPIMock,           lifecycleStatus: LifeCycleStatus.New         })          wrapper = createWrapper({           DocumentsTableElement: createDocumentsTableElement(document)         })          documentTags = findDocumentTags(wrapper)         expect(documentTags.props('isNew')).toBe(true)       })     })   }) }) "
"<template>   <div class=""document-sync-status__item"" v-if=""document.properties"">     <natto-button type=""text"">       <ged-sync-status-icon :syncStatus=""document.properties?.syncStatus"" />     </natto-button>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoButton from '@/Common/components/Buttons/NattoButton.vue' import GedSyncStatusIcon from '@/Common/components/Icons/GedSyncStatusIcon.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document'  export default defineComponent({   name: 'DocumentSyncStatusItem',   components: { GedSyncStatusIcon, NattoButton },   props: {     document: {       type: Document,       required: true     }   } }) </script>","describe('DocumentSyncStatusItem', () => {   describe('rendering', () => {     it('should render icons  properly', async () => {       const DocumentSyncStatusItemWrapper = wrapper.findComponent(         DocumentSyncStatusItem       )        const NattoButtonWrapper =         DocumentSyncStatusItemWrapper.findComponent(NattoButton)        const syncPendingIconWrapper = NattoButtonWrapper.find('.sync-pending')        expect(syncPendingIconWrapper.exists).toBeTruthy()     })   })   describe('binding', () => {     it('Should bind correctly the syncStatus prop', () => {       const DocumentSyncStatusItemWrapper = wrapper.findComponent(         DocumentSyncStatusItem       )        const NattoButtonWrapper =         DocumentSyncStatusItemWrapper.findComponent(NattoButton)        const GedSyncStatusIconWrapper =         NattoButtonWrapper.findComponent(GedSyncStatusIcon)        expect(GedSyncStatusIconWrapper.props('syncStatus')).toBe(         constants.PENDING_SYNC       )     })   }) }) "
"<template>   <section class=""folder-actions-dropdown__list"">     <document-action-dropdown-item       v-for=""{         label,         icon,         disabled,         action,         tooltipContent       } in documentActions""       :key=""label""       :label=""label""       :icon=""icon""       :disabled=""disabled""       :tooltip-content=""tooltipContent""       @click=""handleClickItem(action)""     />   </section> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import { useStore } from 'vuex' import DocumentActionDropdownItem from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentActionDropdownItem.vue' import useDeleteFileHelpers from '@/modules/DataManipulation/Delete/DeleteFile/store/helpers' import { ITEMS } from '@/Common/types/actionItemTypes' import { useTranslation } from '@/Common/hooks/useTranslation'  type ActionItem = {   action: ITEMS   label: string   icon: string   disabled?: boolean   tooltipContent?: string }  export default defineComponent({   name: 'DocumentActionsDropdownList',   components: { DocumentActionDropdownItem },   props: {     documentId: {       type: String,       required: true     },     displayGoTo: Boolean   },    setup(props, { emit }) {     const store = useStore()      const { isFileDeletable } = useDeleteFileHelpers(store)     const { t } = useTranslation()      const documentActions = computed(() => {       const actions: ActionItem[] = [         {           action: ITEMS.DELETE,           label: t('ged.common.delete'),           icon: 'delete',           disabled: !isFileDeletable(props.documentId),           tooltipContent: t('ged.dataManipulation.delete.cantDelete')         },         {           action: ITEMS.DOWNLOAD,           label: t('ged.common.download'),           icon: 'download'         }       ]        if (props.displayGoTo) {         actions.push({           action: ITEMS.GOTO,           label: t('ged.common.goTo'),           icon: 'd-arrow-right'         })       }        return actions     })      return {       documentActions,       handleClickItem: (action: string) => {         emit('item-clicked', action)       }     }   } }) </script>","describe('DocumentActionsDropdownList', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('props', () => {       it('static props', () => {         const dropdownItemWrapper = wrapper.findComponent(           DocumentActionDropdownItem         )          expect(dropdownItemWrapper.props()).toStrictEqual({           disabled: true,           icon: 'delete',           label: 'ged.common.delete',           tooltipContent: 'ged.dataManipulation.delete.cantDelete'         })       })     })     describe('events', () => {       it('Should fire item-clicked when item clicked', () => {         const dropdownItemWrapper = wrapper.findComponent(           DocumentActionDropdownItem         )          dropdownItemWrapper.trigger('click')          expect(wrapper.emitted('item-clicked')).toHaveLength(1)         expect(wrapper.emitted('item-clicked')).toStrictEqual([[ITEMS.DELETE]])       })     })   })   describe('rendering', () => {     it.each(testCases)(       'When file  deletable = $fileIsDeletable should dropdown delete action should be disabled=$buttonShouldBeDisabled ',       async ({ fileIsDeletable, buttonShouldBeDisabled }) => {         storeMock = createDeleteFileStoreMocked({           isFileDeletable: fileIsDeletable         })          wrapper = createWrapper({           ...defaultProps,           documentId: '69241b23-f6d1-458d-8675-1ea36f593303',           isSynchronizedDocument: false         })         await wrapper.vm.$nextTick()         const dropdownItemWrapper = wrapper.findComponent(           DocumentActionDropdownItem         )          expect(dropdownItemWrapper.props('disabled')).toBe(           buttonShouldBeDisabled         )       }     )     it.each([       { displayGoTo: true, expectedItemsCount: 3 },       { displayGoTo: false, expectedItemsCount: 2 }     ])(       'should display the goto item if displayGoTo is at true',       ({ displayGoTo, expectedItemsCount }) => {         wrapper = createWrapper({           ...defaultProps,           displayGoTo         })          const dropdownItemWrappers = wrapper.findAllComponents(           DocumentActionDropdownItem         )          expect(dropdownItemWrappers).toHaveLength(expectedItemsCount)       }     )   }) }) "
"<template>   <natto-dropdown-item     :icon=""icon""     :label=""label""     :disabled=""disabled""     :tooltip-content=""tooltipContent""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoDropdownItem from '@/Common/components/Dropdown/NattoDropdownItem.vue'  export default defineComponent({   name: 'DocumentActionDropdownItem',   components: { NattoDropdownItem },   props: {     label: {       type: String,       required: true     },     icon: {       type: String,       default: ''     },     disabled: Boolean,     tooltipContent: String   } }) </script>","describe('DocumentActionDropdownItem', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoDropdownItemWrapper = findNattoDropdownItem(wrapper)   })    describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       expect(nattoDropdownItemWrapper.props('label')).toBe('test')       expect(nattoDropdownItemWrapper.props('icon')).toBe('delete')       expect(nattoDropdownItemWrapper.props('disabled')).toBe(false)       expect(nattoDropdownItemWrapper.props('tooltipContent')).toBe(         'je suis le tooltipContent'       )     })   }) }) "
"<template>   <div class=""create-folder-modal-container"">     <el-dialog       @close=""handleClose""       append-to-body       custom-class=""create-folder-dialog-container""       v-model=""isCreateFolderModalOpened""     >       <natto-create-folder-form         show-form         :creation-folder-error=""creationFolderError""         :selectedFolderId=""selectedFolderId""         :placeholder=""$t('ged.dataManipulation.create.folder.title')""         @create-folder-click=""handleCreateClick""         @cancel-create-folder-click=""handleClose""       />     </el-dialog>   </div> </template>  <script lang=""ts""> import { defineComponent, ref } from 'vue' import { useStore } from 'vuex' import useVModel from '@/Common/hooks' import NattoCreateFolderForm from '@/modules/DataManipulation/Create/CreateFolder/components/NattoCreateFolderForm.vue' import { CreateFolderQuery } from '@/modules/Search/types' import useCreateFolderModule from '@/modules/DataManipulation/Create/CreateFolder/store/helpers' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'CreateFolderModal',   components: { NattoCreateFolderForm },    props: {     modelValue: Boolean,     selectedFolderId: Number   },    emits: ['on-create-folder', 'update:modelValue'],    setup(props) {     const isCreateFolderModalOpened = useVModel(props)      const { t } = useTranslation()      const store = useStore()     const creationFolderError = ref('')     const folderName = ref('')      const { createFolderByArbo } = useCreateFolderModule(store)      return {       isCreateFolderModalOpened,       folderName,       handleClose: () => {         creationFolderError.value = ''         isCreateFolderModalOpened.value = false       },       handleCreateClick: async (query: CreateFolderQuery) => {         try {           await createFolderByArbo(query)           isCreateFolderModalOpened.value = false         } catch (error) {           if (error.code === 403) {             creationFolderError.value = t(               'ged.dataManipulation.create.folder.error.alreadyExists',               { folderName: query.folderName }             )           } else {             throw error           }         }       },       creationFolderError     }   } }) </script>","describe('create-folder-modal', () => {   beforeEach(() => {     wrapper = createWrapper(1234, true)     mockStore.dispatch = jest.fn()     jest.clearAllMocks()   })   describe('binding', () => {     describe('props', () => {       it('Should bind selectedFolderId prop value correctly', () => {         const NattoCreateFolderForWrapper = wrapper.findComponent(           NattoCreateFolderForm         )          expect(wrapper.props('selectedFolderId')).toBe(1234)         expect(wrapper.props('selectedFolderId')).toBe(           NattoCreateFolderForWrapper.props('selectedFolderId')         )       })       it('Should bind modelValue prop value correctly', () => {         expect(wrapper.props('modelValue')).toBe(true)       })     })     describe('events', () => {       describe('create-folder-click event', () => {         it('Should dispatch createFolderByArbo when create-folder-click event is triggered', async () => {           wrapper = createWrapper(1234, true)            const data = {             targetFolder: 1234,             folderName: 'hello'           }            const NattoCreateFolderForWrapper = wrapper.findComponent(             NattoCreateFolderForm           )            await NattoCreateFolderForWrapper.vm.$emit(             'create-folder-click',             data           )            await wrapper.vm.$nextTick()            expect(mockStore.dispatch).toHaveBeenCalledWith(             createFolderModule('CreateFolder'),             {               targetFolder: 1234,               folderName: 'hello'             }           )           expect(wrapper.emitted('update:modelValue')).toEqual([[false]])         })         it('Should catch createFolderByArbo error when create-folder-click event is triggered', async () => {           mockStore.dispatch = jest.fn(() => {             throw new FolderExistsError()           })            const data = {             targetFolder: 1234,             folderName: 'hello'           }            wrapper = createWrapper(1234, true)            const nattoCreateFolderWrapper = wrapper.findComponent(             NattoCreateFolderForm           )            // When create-folder-click is emitted           await nattoCreateFolderWrapper.vm.$emit('create-folder-click', data)            // Then set the error message           expect(wrapper.vm.creationFolderError).toBe(             'ged.dataManipulation.create.folder.error.alreadyExists with {""folderName"":""hello""}'           )         })       })        it('Should reset error and close the modal when cancel-create-folder-click event is triggered', async () => {         const nattoCreateFolderForWrapper = wrapper.findComponent(           NattoCreateFolderForm         )          await nattoCreateFolderForWrapper.vm.$emit('cancel-create-folder-click')         expect(nattoCreateFolderForWrapper.props('creationFolderError')).toBe(           ''         )         expect(wrapper.emitted('update:modelValue')).toEqual([[false]])       })     })   }) }) "
"<template>   <div v-loading=""isPreviewLoading"" class=""preview-container"">     <natto-dialog v-model=""isPreviewOpened"" :show-close=""false"">       <div class=""preview-content"">         <preview-modal-header           :document=""document""           :is-document-deletable=""isFileDeletable(document.id)""           :is-document-deleting=""isFileDeleting()""           :is-downloading=""isDownloading""           @close-click=""isPreviewOpened = false""           @download=""downloadDocument""           @delete=""deleteDocument""         />         <natto-doc-viewer v-if=""isVisualizationPdfType"" :file=""visualization"" />         <img           v-else           :src=""previewImage""           class=""preview-content__image""           alt=""preview-image""         />       </div>     </natto-dialog>   </div> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import NattoDialog from '@/Common/components/Modals/NattoDialog.vue' import useVModel from '@/Common/hooks' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import PreviewModalHeader from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/PreviewModalHeader.vue' import useDeleteFileHelpers from '@/modules/DataManipulation/Delete/DeleteFile/store/helpers' import NattoDocViewer from '@/Common/components/DocViewer/NattoDocViewer.vue'  export default defineComponent({   name: 'PreviewModal',   components: { NattoDocViewer, PreviewModalHeader, NattoDialog },   props: {     document: {       type: Document,       required: true     },     modelValue: {       type: Boolean,       required: true     }   },    setup(props, { emit }) {     const isPreviewOpened = useVModel(props)     const store = useStore()      const {       getPreviewDocumentImage,       dispatchDownloadDocument,       isPreviewLoading,       fetchDocuments,       visualization,       isDownloading     } = useSearchStoreHelpers()      const { deleteFile, isFileDeletable, isFileDeleting } =       useDeleteFileHelpers(store)      const downloadDocument = async () => {       await dispatchDownloadDocument(         store,         props.document.id ?? '',         !isVisualizationPdfType.value       )     }      const deleteDocument = async () => {       if (isFileDeletable(props.document.id ?? '')) {         await deleteFile(props.document.id ?? '')         isPreviewOpened.value = false         emit('delete')         await fetchDocuments(store)       }     }      const isVisualizationPdfType = computed(       () => visualization(store).value.type === 'application/pdf'     )      return {       isPreviewLoading: isPreviewLoading(store),       isDownloading: isDownloading(store),       isPreviewOpened,       previewImage: getPreviewDocumentImage(store),       isFileDeletable,       deleteDocument,       downloadDocument,       isFileDeleting,       visualization: visualization(store),       isVisualizationPdfType     }   } }) </script>","describe('PreviewModal', () => {   beforeEach(() => {     wrapper = createWrapper()     previewModalHeaderWrapper = findPreviewModalHeader(wrapper)   })    describe('bindings with PreviewModalHeader', () => {     test('props bindings', () => {       const document = new Document()        document.id = 'columbo'       document.name = 'test'       document.type = '.pdf'        const wrapper = createWrapper({         props: {           ...defaultProps,           document         },         store: createDeleteFileStoreMocked({           isFileDeleting: true,           isFileDeletable: true         })       })        previewModalHeaderWrapper = findPreviewModalHeader(wrapper)        expect(previewModalHeaderWrapper.props()).toStrictEqual({         document,         isDocumentDeleting: true,         isDocumentDeletable: true       })     })      describe('events', () => {       it('should close the modal when the cross is clicked', async () => {         await previewModalHeaderWrapper.vm.$emit('close-click')          expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])       })       it('should dispatch downloadDocument with columbo when PreviewModalHeader emits download', async () => {         const store = createDeleteFileStoreMocked()          store.dispatch = jest.fn()          wrapper = createWrapper({           store         })          previewModalHeaderWrapper = findPreviewModalHeader(wrapper)          await previewModalHeaderWrapper.vm.$emit('download')          expect(store.dispatch).toHaveBeenCalledWith(           searchModule('downloadDocument'),           'columbo'         )       })       it('should dispatch deleteFile with columbo, close the modal and fetch the documents when PreviewModalHeader emits delete', async () => {         const store = createDeleteFileStoreMocked({           isFileDeletable: true,           isFileDeleting: false         })          store.dispatch = jest.fn()          wrapper = createWrapper({           store         })          previewModalHeaderWrapper = findPreviewModalHeader(wrapper)          await previewModalHeaderWrapper.vm.$emit('delete')          await flushPromises()          expect(store.dispatch).toHaveBeenNthCalledWith(           1,           deleteFileModule('deleteFiles'),           ['columbo']         )         expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])         expect(wrapper.emitted('delete')).toHaveLength(1)         expect(store.dispatch).toHaveBeenNthCalledWith(           2,           searchModule('fetchDocuments')         )       })       it('should not dispatch deleteFile with columbo, close the modal and fetch the documents when document is not deletable', async () => {         const store = createDeleteFileStoreMocked()          store.dispatch = jest.fn()          wrapper = createWrapper({           store: createDeleteFileStoreMocked({             isFileDeleting: false,             isFileDeletable: false           })         })          previewModalHeaderWrapper = findPreviewModalHeader(wrapper)          await previewModalHeaderWrapper.vm.$emit('delete')          await flushPromises()          expect(store.dispatch).not.toHaveBeenCalled()         expect(wrapper.emitted('update:modelValue')).toBeFalsy()         expect(wrapper.emitted('delete')).toBeFalsy()       })     })   })    describe('props binding', () => {     describe('natto-dialog', () => {       test('modelValue', () => {         expect(wrapper.findComponent(NattoDialog).props('modelValue')).toBe(           true         )       })     })     describe('img', () => {       test('src', () => {         const wrapper = createWrapper({           store: createDeleteFileStoreMocked({             previewDocumentImage: 'preview-url'           })         })         const imgWrapper = wrapper.find('img')          expect(imgWrapper.attributes('src')).toBe('preview-url')       })     })   }) }) "
"<template>   <natto-tag class=""preview-modal__document-type"">     <MpIcon :name=""documentTypeIcon(type)"" />   </natto-tag> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import useDocumentTypeComputed from '@/modules/Search/components/Drawer/DocumentTypeTag/documentTypeComputeds' import NattoTag from '@/Common/components/Tags/NattoTag.vue'  export default defineComponent({   name: 'PreviewModalDocumentType',   components: { NattoTag },   props: {     type: {       type: String,       default: 'file'     }   },    setup() {     const { documentTypeIcon } = useDocumentTypeComputed()      return {       documentTypeIcon     }   } }) </script>","describe('DocumentTypeTag', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with NattoTag', () => {     describe('documentTypeIcon', () => {       const cases = [         {           type: '.pdf',           expectedIcon: 'pdf'         },         {           type: '.txt',           expectedIcon: 'file'         },         {           type: '.xls',           expectedIcon: 'xls'         },         {           type: '.jpg',           expectedIcon: 'file'         }       ]        test.each(cases)(         'It should bind document type icon correctly',         ({ type, expectedIcon }) => {           wrapper = createWrapper({             type           })            expect(findMpIcon(wrapper).props('name')).toEqual(expectedIcon)         }       )     })   }) }) "
"<template>   <div class=""preview-modal__header"">     <div class=""preview-modal__header__name"">       <preview-modal-document-type :type=""document.type"" />       <preview-modal-certified-tag         v-if=""document?.properties?.hasSubscribedToVault""       />       <span class=""preview-modal__header__name__text"">{{ document.name }}</span>     </div>     <preview-modal-ctas       :is-document-deletable=""isDocumentDeletable""       :is-document-deleting=""isDocumentDeleting""       :is-downloading=""isDownloading""       @close-click=""$emit('close-click')""       @download=""$emit('download')""       @delete=""$emit('delete')""     />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import PreviewModalCTAs from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/PreviewModalCTAs.vue' import PreviewModalDocumentType from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/PreviewModalDocumentType.vue' import PreviewModalCertifiedTag from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/PreviewModalCertifiedTag.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document'  export default defineComponent({   name: 'PreviewModalHeader',   components: {     PreviewModalCertifiedTag,     PreviewModalDocumentType,     'preview-modal-ctas': PreviewModalCTAs   },   props: {     document: {       type: Document,       required: true     },     isDocumentDeletable: Boolean,     isDocumentDeleting: Boolean,     isDownloading: Boolean   } }) </script>","describe('PreviewModalHeader', () => {   beforeEach(() => {     wrapper = createWrapper()     previewModalCTAsWrapper = findPreviewModalCTAs(wrapper)     previewModalDocumentType = findPreviewModalDocumentType(wrapper)     previewModalCertifiedTag = findPreviewModalCertifiedTag(wrapper)   })    describe('bindings with PreviewModalCtas', () => {     describe('props', () => {       it('static props', () => {         expect(previewModalCTAsWrapper.props()).toStrictEqual({           isDocumentDeletable: false,           isDocumentDeleting: false         })       })     })     describe('events', () => {       it.each([['close-click'], ['download'], ['delete']])(         'should emit %p when cross emits %p',         async (event) => {           // When PreviewModalCtas emits the event           await previewModalCTAsWrapper.vm.$emit(event)            // Then the event must be emitted           expect(wrapper.emitted(event)).toBeTruthy()         }       )     })   })   describe('bindings with preview-modal-document-type', () => {     describe('props', () => {       it('static props', () => {         wrapper = createWrapper()          previewModalDocumentType = findPreviewModalDocumentType(wrapper)          expect(previewModalDocumentType.props()).toStrictEqual({           type: '.pdf'         })       })     })   })   describe('bindings with preview-modal-certified-tag', () => {     describe('rendering', () => {       it.each([         { hasSubscribedToVault: false, existPreviewModalCertifiedTag: false },         { hasSubscribedToVault: true, existPreviewModalCertifiedTag: true }       ])(         'static props',         ({ hasSubscribedToVault, existPreviewModalCertifiedTag }) => {           const document = new Document()            document.properties.hasSubscribedToVault = hasSubscribedToVault            wrapper = createWrapper({             document           })            previewModalCertifiedTag = findPreviewModalCertifiedTag(wrapper)            expect(previewModalCertifiedTag.exists()).toBe(             existPreviewModalCertifiedTag           )         }       )     })   }) }) "
"<template>   <preview-cta-container :tooltip-content=""tooltipContent"">     <loading-icon v-if=""isDocumentDeleting"" />     <MpIcon v-else name=""delete"" />   </preview-cta-container> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import PreviewCTAContainer from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/PreviewCTAContainer.vue' import { useTranslation } from '@/Common/hooks/useTranslation' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue'  export default defineComponent({   name: 'DeleteCTA',   components: {     LoadingIcon,     'preview-cta-container': PreviewCTAContainer   },   props: {     isDocumentDeletable: Boolean,     isDocumentDeleting: Boolean   },   setup(props) {     const { t } = useTranslation()      const tooltipContent = computed(() =>       props.isDocumentDeletable         ? t('ged.dataManipulation.delete.file')         : t('ged.dataManipulation.delete.cantDelete')     )      return {       tooltipContent     }   } }) </script>","describe('DeleteCTA', () => {   beforeEach(() => {     wrapper = createWrapper()     previewCTAContainer = findPreviewCTAContainer(wrapper)     loadingIconWrapper = findLoadingIcon(wrapper)     mpIconWrapper = findMpIcon(wrapper)   })    describe('bindings with PreviewCTAContainer', () => {     describe('props bindings', () => {       it.each([         {           isDocumentDeletable: false,           translation: 'ged.dataManipulation.delete.cantDelete'         },         {           isDocumentDeletable: true,           translation: 'ged.dataManipulation.delete.file'         }       ])(         'should bind the good translation in function if the document is deletable',         ({ isDocumentDeletable, translation }) => {           wrapper = createWrapper({             ...defaultProps,             isDocumentDeletable           })            previewCTAContainer = findPreviewCTAContainer(wrapper)            expect(previewCTAContainer.props('tooltipContent')).toBe(translation)         }       )     })     describe('rendering', () => {       it.each([         {           isDocumentDeleting: true,           loadingIconExist: true,           mpIconExist: false         },         {           isDocumentDeleting: false,           loadingIconExist: false,           mpIconExist: true         }       ])(         'should render LoadingIcon if the document is deleting',         ({ isDocumentDeleting, loadingIconExist, mpIconExist }) => {           wrapper = createWrapper({ ...defaultProps, isDocumentDeleting })           loadingIconWrapper = findLoadingIcon(wrapper)           mpIconWrapper = findMpIcon(wrapper)            expect(loadingIconWrapper.exists()).toBe(loadingIconExist)           expect(mpIconWrapper.exists()).toBe(mpIconExist)         }       )     })   }) }) "
"<template>   <div class=""preview-modal__ctas"">     <download-cta :is-downloading=""isDownloading"" @click=""$emit('download')"" />     <delete-cta       :is-document-deletable=""isDocumentDeletable""       :is-document-deleting=""isDocumentDeleting""       @click=""$emit('delete')""     />     <cross-close @click=""$emit('close-click')"" />   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import CrossClose from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/CrossClose.vue' import DownloadCTA from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/DownloadCTA.vue' import DeleteCTA from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/DeleteCTA.vue'  export default defineComponent({   name: 'PreviewModalCTAs',   components: {     'delete-cta': DeleteCTA,     'download-cta': DownloadCTA,     CrossClose   },   props: {     isDocumentDeletable: Boolean,     isDocumentDeleting: Boolean,     isDownloading: Boolean   } }) </script>","describe('PreviewModalCTAs', () => {   beforeEach(() => {     wrapper = createWrapper()     crossCloseWrapper = findCrossClose(wrapper)     downloadCTAWrapper = findDownloadCTA(wrapper)     deleteCTAWrapper = findDeleteCTA(wrapper)   })    describe('bindings with CrossClose', () => {     describe('events', () => {       it('should emit download when CrossClose is clicked', async () => {         await crossCloseWrapper.vm.$emit('click')          expect(wrapper.emitted('close-click')).toHaveLength(1)       })     })   })   describe('bindings with DeleteCTA', () => {     test('props bindings', () => {       wrapper = createWrapper({         isDocumentDeleting: true,         isDocumentDeletable: true       })        deleteCTAWrapper = findDeleteCTA(wrapper)        expect(deleteCTAWrapper.props('isDocumentDeleting')).toBe(true)       expect(deleteCTAWrapper.props('isDocumentDeletable')).toBe(true)     })     describe('events', () => {       it('should emit download when DeleteCTA is clicked', async () => {         await deleteCTAWrapper.vm.$emit('click')          expect(wrapper.emitted('delete')).toHaveLength(1)       })     })   })   describe('bindings with DownloadCTA', () => {     describe('events', () => {       it('should emit download when DownloadCTA is clicked', async () => {         await downloadCTAWrapper.vm.$emit('click')          expect(wrapper.emitted('download')).toHaveLength(1)       })     })   }) }) "
"<template>   <natto-tooltip :content=""tooltipContent"" placement=""bottom"">     <div       class=""preview-cta__container""       :class=""{ disabled }""       @click=""$emit('click')""     >       <slot />     </div>   </natto-tooltip> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoTooltip from '@/Common/components/Tooltips/NattoTooltip.vue'  export default defineComponent({   name: 'PreviewCTAContainer',   components: { NattoTooltip },   props: {     tooltipContent: String,     disabled: Boolean   } }) </script>","describe('PreviewCTAContainer', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoTooltipWrapper = findNattoTooltip(wrapper)   })    describe('bindings with NattoTooltip', () => {     test('props bindings', () => {       expect(nattoTooltipWrapper.props('content')).toBe('test')       expect(nattoTooltipWrapper.props('disabled')).toBe(false)     })     it('should render the default slot', () => {       expect(wrapper.text()).toContain('test slot')     })     describe('events', () => {       it('should emit click when container is clicked', () => {})     })   }) }) "
"<template>   <preview-cta-container :tooltip-content=""$t('ged.common.download')"">     <loading-icon v-if=""isDownloading"" />     <MpIcon v-else name=""download"" />   </preview-cta-container> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import PreviewCTAContainer from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/PreviewCTAContainer.vue' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue'  export default defineComponent({   name: 'DownloadCTA',   props: {     isDownloading: Boolean   },   components: {     LoadingIcon,     'preview-cta-container': PreviewCTAContainer   } }) </script>","describe('DownloadCTA', () => {   beforeEach(() => {     wrapper = createWrapper()     previewCTAContainer = findPreviewCTAContainer(wrapper)     mpIconWrapper = findMpIcon(wrapper)   })    describe('bindings with PreviewCTAContainer', () => {     test('props bindings', () => {       expect(previewCTAContainer.props('tooltipContent')).toBe(         'ged.common.download'       )       expect(mpIconWrapper.props('name')).toBe('download')     })   }) }) "
"<template>   <preview-cta-container :tooltip-content=""$t('ged.common.close')"">     <MpIcon name=""close"" />   </preview-cta-container> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import PreviewCTAContainer from '@/modules/Search/components/Modals/PreviewModal/PreviewModalHeader/CTAs/PreviewCTAContainer.vue'  export default defineComponent({   name: 'CrossClose',   components: {     'preview-cta-container': PreviewCTAContainer   } }) </script>","describe('CrossClose', () => {   beforeEach(() => {     wrapper = createWrapper()     previewCTAContainer = findPreviewCTAContainer(wrapper)     mpIconWrapper = findMpIcon(wrapper)   })    describe('bindings with PreviewCTAContainer', () => {     test('props bindings', () => {       expect(previewCTAContainer.props('tooltipContent')).toBe(         'ged.common.close'       )       expect(mpIconWrapper.props('name')).toBe('close')     })   }) }) "
"<template>   <div class=""document-download-container"">     <certification-icon class=""download-tab-header"" />      <div class=""download-tab-content"">       <div class=""download-tab-description"">         <p class=""part1"">           {{ $t('ged.drawer.downloadTab.description.part1') }}         </p>         <p class=""part2"">           {{ $t('ged.drawer.downloadTab.description.part2') }}         </p>       </div>       <div class=""download-tab-date"">         <p class=""download-tab-label"">           {{ $t('ged.drawer.downloadTab.date') }}         </p>         <div class=""download-tab-date-value"">           <natto-date             class=""document-creation-date""             :date=""document.creationDate""             format=""DD MMMM YYYY""           />         </div>       </div>       <div class=""download-tab-button"">         <MpButton           @click=""$emit('download-clicked')""           class=""download-btn""           size=""small""           type=""primary""           :disabled=""isDownloading""         >           <div class=""download-btn__content"">             <transition name=""el-zoom-in-center"">               <loading-icon size=""15"" v-if=""isDownloading"" />             </transition>             <span>{{ $t('ged.drawer.downloadTab.download') }}</span>           </div>         </MpButton>       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import CertificationIcon from '@/Common/components/Icons/CertificationIcon.vue' import NattoDate from '@/Common/components/Dates/NattoDate.vue' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import Document from '@/modules/Search/models/Documents/Inputs/Document'  export default defineComponent({   name: 'DocumentDownloadTab',   components: {     LoadingIcon,     CertificationIcon,     NattoDate   },   props: {     document: {       type: Document,       required: true     }   },    setup() {     const store = useStore()     const { isDownloading } = useSearchStoreHelpers()      return {       isDownloading: isDownloading(store)     }   } }) </script>","describe('DocumentDownloadTab', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('bindings with NattoDate', () => {     it('Should bind document prop correctly', async () => {       const Date = wrapper.findComponent(NattoDate)        expect(Date.props('date')).toEqual('2018-05-27')     })   })   describe('bindings with MpButton', () => {     describe('events', () => {       it('should emit download-clicked when the button is clicked', async () => {         await findMpButton(wrapper).vm.$emit('click')          expect(wrapper.emitted('download-clicked')).toHaveLength(1)       })     })     describe('rendering', () => {       it.each([         { isDownloading: false, isLoadingIconExists: false },         { isDownloading: true, isLoadingIconExists: true }       ])(         'should display loadingIcon only if downloading',         ({ isLoadingIconExists, isDownloading }) => {           wrapper = createWrapper({             store: createSearchStoreMocked({               isDownloading             })           })            expect(findLoadingIcon(wrapper).exists()).toBe(isLoadingIconExists)         }       )     })   }) }) "
"<template>   <div class=""comments-tab-container"">     <mp-input       v-loading=""isLoading""       type=""textarea""       v-model=""comment""       @change=""updateComWhenInputChange""     />     <div class=""description"" v-if=""currentComment"">       <div class=""comment-date-container"">         <p class=""header"">           {{ $t('ged.drawer.commentsTab.commentDate') }}         </p>         <natto-date class=""label"" :date=""commentDate"" format=""DD MMMM YYYY"" />       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, ref, watch } from 'vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex' import NattoDate from '@/Common/components/Dates/NattoDate.vue'  export default defineComponent({   name: 'CommentsTab',   props: {     documentId: { type: String, required: true },     commentDate: String,     currentComment: String   },   components: {     NattoDate   },    emits: ['comment-updated'],    setup(props, { emit }) {     const store = useStore()     const comment = ref(props.currentComment)     const isLoading = ref(false)      watch(       () => props.documentId,       () => {         comment.value = props.currentComment       }     )     const { dispatchPatchDocumentComment } = useSearchStoreHelpers()      const updateComWhenInputChange = async () => {       if (comment.value) {         try {           isLoading.value = true           await dispatchPatchDocumentComment(             store,             props.documentId,             comment.value           )           emit('comment-updated')         } finally {           isLoading.value = false         }       }     }      return {       updateComWhenInputChange,       comment,       isLoading     }   } }) </script>","describe('CommentsTab', () => {   beforeEach(() => {     storeMock = createSearchStoreMocked()     storeMock.dispatch = jest.fn()     wrapper = createWrapper()   })   describe('binding with MpInput', () => {     describe('props', () => {       it('Should pass the correct modelValue', () => {         wrapper = createWrapper(storeMock)         const input = findMpInput(wrapper)          expect(input.props('modelValue')).toStrictEqual('')       })     })     describe('events', () => {       it('Should dispatch patch document on input change ', async () => {         const input = wrapper.findComponent(MpInput)          await input.vm.$emit('update:modelValue', 'test')         await input.vm.$emit('change')          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/patchDocumentComment',           { documentId: 'test', value: 'test' }         )       })       it('Should not dispatch patch document on input change when input is an empty string ', async () => {         const input = wrapper.findComponent(MpInput)          await input.vm.$emit('update:modelValue', '')         await input.vm.$emit('change')          expect(storeMock.dispatch).toHaveBeenCalledTimes(0)       })     })   }) }) "
"<template>   <natto-drawer v-model:opened=""value"">     <template #header>       <div class=""drawer-icon-zone"">         <document-type-tag :type=""document.type"" />         <certified-tag-drawer           v-if=""document?.properties?.hasSubscribedToVault""         />       </div>     </template>     <div class=""drawer-content"">       <div class=""title"">         <p>{{ $t('ged.drawer.header.title') }}</p>       </div>       <div class=""doc-content"">         <div class=""doc-tabs"">           <document-details-drawer-tabs             :document=""document""             @open-preview=""displayPreview""             @download-clicked=""downloadDocument""           />         </div>       </div>     </div>   </natto-drawer>   <preview-modal     v-if=""isPreviewModalOpened""     v-model=""isPreviewModalOpened""     :document=""document""     @delete=""value = false""   /> </template>  <script lang=""ts""> import { defineComponent, ref, watch } from 'vue' import NattoDrawer from '@/Common/components/Drawer/NattoDrawer.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import DocumentDetailsDrawerTabs from '@/modules/Search/components/Tabs/DocumentDetailsDrawerTabs.vue' import PreviewModal from '@/modules/Search/components/Modals/PreviewModal/PreviewModal.vue' import useVModel from '@/Common/hooks' import CertifiedTagDrawer from '@/modules/Search/components/Drawer/CertifiedTagDrawer.vue' import DocumentTypeTag from '@/modules/Search/components/Drawer/DocumentTypeTag/DocumentTypeTag.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex'  export default defineComponent({   name: 'DocumentDetailsDrawer',   components: {     DocumentTypeTag,     CertifiedTagDrawer,     PreviewModal,     DocumentDetailsDrawerTabs,     NattoDrawer   },   props: {     opened: Boolean,     document: {       type: Document,       required: true     }   },    setup(props) {     const store = useStore()      const isPreviewModalOpened = ref(false)     const {       dispatchDownloadDocument,       downloadVisualization,       resetVisualization     } = useSearchStoreHelpers()      const value = useVModel(props, 'opened')      const displayPreview = () => {       isPreviewModalOpened.value = true     }      const downloadDocument = async () => {       await dispatchDownloadDocument(store, props.document.id ?? '')     }      watch(       () => props.document.id,       async () => {         await resetVisualization(store)         if (props.document.id && props.document.type === '.pdf') {           // Only pdf can have a visualization           await downloadVisualization(store, props.document.id)         }       }     )      return {       displayPreview,       isPreviewModalOpened,       value,       downloadDocument     }   } }) </script>","describe('DocumentDetailsDrawer', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('props', () => {     it.each([       { type: '.pdf', downloadVisualization: true },       { type: '.doc', downloadVisualization: false }     ])(       'should reset visualization and fetch an other visualization when the document change',       async ({ type, downloadVisualization }) => {         const storeMock = createSearchStoreMocked()          storeMock.dispatch = jest.fn()          wrapper = createWrapper({           store: storeMock         })          await wrapper.setProps({           document: new Document({ id: 2705, type } as never)         })          await flushPromises()          expect(storeMock.dispatch).toHaveBeenCalledWith(           searchModule('resetVisualization')         )          if (downloadVisualization) {           expect(storeMock.dispatch).toHaveBeenCalledWith(             searchModule('downloadVisualization'),             2705           )         } else {           expect(storeMock.dispatch).not.toHaveBeenCalledWith(             searchModule('downloadVisualization'),             2705           )         }       }     )   })   describe('binding', () => {     describe('NattoDrawer', () => {       it('Should bind with opened', async () => {         expect(findNattoDrawer(wrapper).props('opened')).toStrictEqual(true)       })     })     describe('props', () => {       it('Should bind with document', async () => {         const details = wrapper.findComponent(DocumentDetailsDrawerTabs)          expect(details.props('document')).toEqual({           comments: '',           createdBy: 'luffy',           id: 'myID',           folderId: 45454,           name: 'Mon bilan comptable',           creationDate: '2018-05-27',           path: [],           properties: new Properties({ syncStatus: constants.PENDING_SYNC }),           restorationStatus: '',           size: 54545,           type: '.pdf',           updatedDate: '2018-05-29',           preview: 'preview-href',           lifecycleStatus: LifeCycleStatus.Treated         })       })     })   })   describe('bindings with PreviewModal', () => {     describe('props', () => {       it('static props', async () => {         //When the banner emits click         await findDocumentDetailsDrawerTabs(wrapper).vm.$emit('open-preview')          // Given the document is set         // Then the PreviewModal must have this document as prop         const previewModalWrapper = findPreviewModal(wrapper)          expect(previewModalWrapper.props('document')).toStrictEqual(document)         expect(previewModalWrapper.props('modelValue')).toStrictEqual(true)       })     })     describe('events bindings', () => {       it('should close the modal when PreviewModal emit an update:modelValue event with false as payload', async () => {         //When the banner emits open-preview         await findDocumentDetailsDrawerTabs(wrapper).vm.$emit('open-preview')          // Then the previewModal must exist         expect(findPreviewModal(wrapper).exists()).toBe(true)          // When PreviewModal emit update:modelValue with false         await findPreviewModal(wrapper).vm.$emit('update:modelValue', false)          // Then the previewModal must not exist         expect(findPreviewModal(wrapper).exists()).toBe(false)       })       it('should close the drawer when PreviewModal emit a delete event', async () => {         //When the banner emits click         await findDocumentDetailsDrawerTabs(wrapper).vm.$emit('open-preview')          // Then the previewModal must exist         expect(findPreviewModal(wrapper).exists()).toBe(true)          // When PreviewModal emit update:modelValue with true         await findPreviewModal(wrapper).vm.$emit('delete')          // Then the drawer must be closed         expect(wrapper.emitted('update:opened')).toStrictEqual([[false]])       })     })   })   describe('bindings with CertifiedTagDrawer', () => {     describe('rendering', () => {       it('should render the certifiedTag if the document has the property hasSubscribedToVault at true', () => {         const document = new Document()          document.properties.hasSubscribedToVault = true          wrapper = createWrapper({ props: { ...defaultProps, document } })          expect(findCertifiedTagDrawer(wrapper).exists()).toBe(true)       })     })   })   describe('bindings with DocumentDetailsDrawerTabs', () => {     describe('events', () => {       it('should dispatch downloadDocument when download-clicked is emitted', async () => {         const store = createSearchStoreMocked()          store.dispatch = jest.fn()         wrapper = createWrapper({           store         })          const documentDetailsDrawerTabs = findDocumentDetailsDrawerTabs(wrapper)          await documentDetailsDrawerTabs.vm.$emit('download-clicked')          expect(store.dispatch).toHaveBeenCalledWith(           searchModule('downloadDocument'),           'myID'         )       })     })   }) }) "
"<template>   <div     v-if=""previewImage""     v-loading=""isPreviewLoading || isDownloading""     class=""document-details__banner""   >     <img       :src=""previewImage""       class=""document-details__banner__image""       alt=""preview-image""     />     <div class=""overlay"">       <div class=""overlay-content"">         <mp-icon name=""expand"" />         <span class=""label"">{{ $t('ged.drawer.preview.expand') }}</span>       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, watch } from 'vue' import { useStore } from 'vuex' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import Document from '@/modules/Search/models/Documents/Inputs/Document'  export default defineComponent({   name: 'DocumentDetailsBanner',    props: {     document: {       type: Document,       required: true     }   },    setup(props) {     const store = useStore()      const {       downloadPreview,       getPreviewDocumentImage,       isPreviewLoading,       isDownloading     } = useSearchStoreHelpers()      watch(       () => props.document.id,       async () => {         if (props.document.id) {           await downloadPreview(store, props.document.id)         }       },       { immediate: true }     )      return {       isPreviewLoading: isPreviewLoading(store),       previewImage: getPreviewDocumentImage(store),       isDownloading: isDownloading(store)     }   } }) </script>","describe('DocumentDetailsBanner', () => {   beforeEach(() => {     wrapper = createWrapper()     previewImgWrapper = findPreviewImg(wrapper)   })    describe('bindings with Preview Img', () => {     describe('mounted', () => {       it('should call the downloadPreview action on mounted', () => {         // The downloadPreview must have been called         expect(storeDefault.dispatch).toHaveBeenCalledWith(           'GED/Search/downloadPreview',           '27'         )       })     })     test('props bindings', () => {       // Given preview image is set to dataBase64 string       wrapper = createWrapper(         defaultProps,         createSearchStoreMocked({           previewDocumentImage: 'test'         })       )        // Then the img preview must have as src the dataBase64 string       expect(findPreviewImg(wrapper).attributes('src')).toBe('test')     })     describe('rendering', () => {       it.each([         {           isPreviewLoading: false,           isDownloading: false,           expectedVLoading: false         },         {           isPreviewLoading: false,           isDownloading: true,           expectedVLoading: true         },         {           isPreviewLoading: true,           isDownloading: false,           expectedVLoading: true         },         { isPreviewLoading: true, isDownloading: true, expectedVLoading: true }       ])(         'should display loading mask when preview is loading or the document is downloading',         ({ isPreviewLoading, isDownloading, expectedVLoading }) => {           const log = console.log            console.log = jest.fn()            wrapper = createWrapper(             defaultProps,             createSearchStoreMocked({               isDownloading,               isPreviewLoading             })           )            expect(console.log).toHaveBeenCalledWith(             `v-loading value : ${expectedVLoading}`           )            console.log = log         }       )       it('should send a downloadPreview action when document change', async () => {         const store = createSearchStoreMocked()          store.dispatch = jest.fn()         wrapper = createWrapper(defaultProps, store)          await wrapper.setProps({           document: new Document({ id: '19' } as DocumentFromAPI)         })          // Then the store must have dispatched two downloadPreview actions (one during mounted and other when document changes)         expect(store.dispatch).toHaveBeenNthCalledWith(           1,           'GED/Search/downloadPreview',           '27'         )         expect(store.dispatch).toHaveBeenNthCalledWith(           2,           'GED/Search/downloadPreview',           '19'         )       })        it('should not display preview when previewImage is null', async () => {         const store = createSearchStoreMocked({           previewDocumentImage: undefined         })          store.dispatch = jest.fn()         wrapper = createWrapper(defaultProps, store)          await wrapper.setProps({           document: new Document({ id: '19' } as DocumentFromAPI)         })          expect(wrapper.classes()).not.toContain(['document-details__banner'])       })     })   }) }) "
"<template>   <div class=""document-details-container"">     <div class=""details-content"">       <div class=""field flex-100"">         <p class=""libelle"">{{ $t('ged.drawer.details.documentName') }}</p>         <p class=""label"">{{ document.name }}</p>       </div>       <div class=""field flex-50"">         <p class=""libelle"">{{ $t('ged.drawer.details.creationDate') }}</p>         <natto-date           class=""label""           :date=""document.creationDate""           format=""DD MMMM YYYY""         />       </div>       <div class=""field flex-50"">         <p class=""libelle"">{{ $t('ged.drawer.details.updatedDate') }}</p>         <natto-date           class=""label""           :date=""document.updatedDate""           format=""DD MMMM YYYY""         />       </div>       <div class=""field flex-100"">         <p class=""libelle"">{{ $t('ged.drawer.details.createdby') }}</p>         <div class=""user-container"">           <p class=""label"" v-if=""document.createdBy?.toUpperCase() !== 'ADMIN'"">             <a :href=""'mailto:' + document.createdBy"">{{               document.createdBy             }}</a>           </p>           <p class=""label"" v-else>             {{ document.createdBy }}           </p>         </div>       </div>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import NattoDate from '@/Common/components/Dates/NattoDate.vue'  export default defineComponent({   name: 'DocumentDetailsTab',   components: {     NattoDate   },   props: {     document: {       type: Document,       required: true     }   } }) </script>","describe('DocumentDetailsTab', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     it('Should bind document prop correctly', async () => {       const MpIconWrapper = wrapper.findAllComponents(NattoDate)        expect(MpIconWrapper).toHaveLength(2)       expect(MpIconWrapper[0].props('date')).toEqual('2018-05-27')       expect(MpIconWrapper[1].props('date')).toEqual('2018-05-29')        const labels = findAllControle(wrapper, '.label')        expect(labels).toHaveLength(4)       expect(labels[0].text()).toBe('Mon bilan comptable')       expect(labels[1].text()).toBe('27 mai 2018')       expect(labels[3].text()).toBe('luffy')     })   }) }) "
"<template>   <natto-tag :class=""$attrs.class"" class=""document-type-tag"">     <MpIcon :name=""documentTypeIcon(type)"" />     <span class=""document-type-tag__name"">{{ documentType(type) }}</span>   </natto-tag> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoTag from '@/Common/components/Tags/NattoTag.vue' import useDocumentTypeComputed from '@/modules/Search/components/Drawer/DocumentTypeTag/documentTypeComputeds'  export default defineComponent({   name: 'DocumentTypeTag',   components: { NattoTag },   props: {     type: {       type: String,       default: 'file'     }   },    setup() {     const { documentTypeIcon, documentType } = useDocumentTypeComputed()      return {       documentTypeIcon,       documentType     }   } }) </script>","describe('DocumentTypeTag', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with NattoTag', () => {     describe('documentTypeIcon', () => {       const cases = [         {           type: '.pdf',           expectedIcon: 'pdf'         },         {           type: '.txt',           expectedIcon: 'file'         },         {           type: '.xls',           expectedIcon: 'xls'         },         {           type: '.jpg',           expectedIcon: 'file'         }       ]        test.each(cases)(         'It should bind document type icon correctly',         ({ type, expectedIcon }) => {           wrapper = createWrapper({             type           })            expect(findMpIcon(wrapper).props('name')).toEqual(expectedIcon)         }       )     })     describe('documentType', () => {       const cases = [         {           type: '.pdf',           expectedType: 'PDF'         },         {           type: '.txt',           expectedType: 'TXT'         },         {           type: '.xls',           expectedType: 'XLS'         },         {           type: '.jpg',           expectedType: 'JPG'         }       ]        test.each(cases)(         'It should render document type correctly',         ({ type, expectedType }) => {           wrapper = createWrapper({             type           })            expect(wrapper.text()).toEqual(expectedType)         }       )     })   }) }) "
"<template>   <natto-folders-browser     class=""documents-folder-browsers""     :folders=""browserFolders""     :height=""height""     :disabled=""disabled""     @browser-folder-selected=""browse""   >     <template #actions=""{ folder }"">       <div class=""documents-folder-browsers__actions__dropdown"">         <ged-sync-status-icon           v-if=""isCollabUser""           class=""documents-folder-browsers__sync-icon""           :syncStatus=""folder.properties?.syncStatus""         />         <folder-actions-dropdown           :folder=""folder""           @delete-clicked=""handleDeleteFolder""         />       </div>     </template>   </natto-folders-browser>   <delete-folder-modal-confirmation     v-model=""folderDeleteModalState.isDeleteFolderModalConfirmationOpened""     :folder-id=""folderDeleteModalState.folderToDelete.id ?? 0""     :folder-name=""folderDeleteModalState.folderToDelete?.name ?? ''""   /> </template>  <script lang=""ts""> import { computed, defineComponent, reactive } from 'vue' import NattoFoldersBrowser from '@/Common/components/Navigation/NattoFoldersBrowser.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' import FolderActionsDropdown from '@/modules/Search/components/Navigation/FolderActionsDropdown/FolderActionsDropdown.vue' import DeleteFolderModalConfirmation from '@/modules/DataManipulation/Delete/DeleteFolder/components/Modals/DeleteFolderModalConfirmation.vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import GedSyncStatusIcon from '@/Common/components/Icons/GedSyncStatusIcon.vue'  export default defineComponent({   name: 'DocumentsFoldersBrowser',   props: {     folders: {       type: Folders,       required: true     },     searchFolderId: {       type: Number,       required: true     },     height: Number,     disabled: { type: Boolean, default: false },     isCollabUser: {       type: Boolean,       default: false     }   },   components: {     GedSyncStatusIcon,     DeleteFolderModalConfirmation,     FolderActionsDropdown,     NattoFoldersBrowser   },   emits: ['update:searchFolderId'],    setup(props, { emit }) {     const folderDeleteModalState = reactive({       isDeleteFolderModalConfirmationOpened: false,       folderToDelete: {} as Folder     })      const browse = (event: Event) => {       if (props.disabled === false) {         emit('update:searchFolderId', event)       }     }     const browserFolders = computed(() => {       if (props.searchFolderId === 0) {         return props.folders.collection       }        return props.folders.getFolderById(props.searchFolderId)?.children     })      const handleDeleteFolder = (folder: Folder) => {       folderDeleteModalState.isDeleteFolderModalConfirmationOpened = true       folderDeleteModalState.folderToDelete = folder     }      return {       browse,       browserFolders,       handleDeleteFolder,       folderDeleteModalState     }   } }) </script>","describe('documents-folders-browser', () => {   describe('rendering', () => {     it('should render ged sync icon when isCollabUser is true', () => {       let wrapper = createWrapper(FoldersData, 1122, 160, false, false, true)        const GedSyncStatusIconWrapper = wrapper.findComponent(GedSyncStatusIcon)        const syncSuccessIconWrapper =         GedSyncStatusIconWrapper.find('.sync-success')       const syncPendingIconWrapper =         GedSyncStatusIconWrapper.find('.sync-pending')       const syncFailedIconWrapper = GedSyncStatusIconWrapper.find('.sync-fail')        expect(syncSuccessIconWrapper.exists).toBeTruthy()       expect(syncPendingIconWrapper.exists).toBeTruthy()       expect(syncFailedIconWrapper.exists).toBeTruthy()     })      it('should not render ged sync icon when isCollabUser is false', () => {       expect(wrapper.findComponent(GedSyncStatusIcon).exists()).toBeFalsy()     })   })   describe('binding', () => {     describe('props', () => {       it('Should have a correct folders binding', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('folders')).toHaveLength(1)       })       it('Should have the correct height value', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('height')).toEqual(160)       })       it('Should pass the correct disabled prop to child component', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('disabled')).toEqual(           wrapper.vm.disabled         )       })       it('Should pass the correct inUpload prop to child component', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          expect(NattoFoldersBrowserWrapper.props('inUpload')).toEqual(           wrapper.vm.inUpload         )       })     })     describe('events', () => {       it('should fire update:selectedFolderToUpload when natto-folders-browser fire browser-folder-selected', () => {         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          NattoFoldersBrowserWrapper.vm.$emit('browser-folder-selected', 55)          expect(wrapper.emitted('update:searchFolderId')).toBeTruthy()         expect(wrapper.emitted()['update:searchFolderId'][0]).toStrictEqual([           55         ])       })       it('should not fire update:selectedFolderToUpload when natto-folders-browser fire browser-folder-selected and disabled is true', () => {         const wrapper = createWrapper(FoldersData, 1122, 160, true, false, false)         const NattoFoldersBrowserWrapper =           wrapper.findComponent(NattoFoldersBrowser)          NattoFoldersBrowserWrapper.vm.$emit('browser-folder-selected', 55)          expect(wrapper.emitted('update:selectedFolderToUpload')).toBeFalsy()       })       it('should open DeleteFolderModal when delete-clicked is clicked', async () => {         // When FolderActionsDropdown emit delete-item         const folderActionsDropdownWrapper = findFolderActionsDropdown(wrapper)          await folderActionsDropdownWrapper.vm.$emit(           'delete-clicked',           new Folder({ id: 4521, name: 'home' } as Category)         )          // Then DeleteFolderModalConfirmation must be opened         const deleteFolderModalConfirmationWrapper =           findDeleteFolderModalConfirmation(wrapper)          expect(deleteFolderModalConfirmationWrapper.props('modelValue')).toBe(           true         )         expect(deleteFolderModalConfirmationWrapper.props('folderName')).toBe(           'home'         )         expect(deleteFolderModalConfirmationWrapper.props('folderId')).toBe(           4521         )       })     })   }) }) "
"<template>   <natto-dropdown>     <template #activator>       <folder-actions-dropdown-activator />     </template>     <template #list>       <folder-actions-dropdown-list         :folder-id=""folder.id""         @item-clicked=""handleAction""       />     </template>   </natto-dropdown> </template>  <script lang=""ts""> import { defineComponent } from 'vue'  import NattoDropdown from '@/Common/components/Dropdown/NattoDropdown.vue'  import FolderActionsDropdownActivator from '@/modules/Search/components/Navigation/FolderActionsDropdown/FolderActionsDropdownActivator.vue' import FolderActionsDropdownList from '@/modules/Search/components/Navigation/FolderActionsDropdown/FolderActionsDropdownList/FolderActionsDropdownList.vue' import Folder from '@/modules/Search/models/Folders/Inputs/Folder' import { ITEMS } from '@/Common/types/actionItemTypes'  export default defineComponent({   name: 'FolderActionsDropdown',    components: {     FolderActionsDropdownList,     FolderActionsDropdownActivator,     NattoDropdown   },    props: {     folder: {       type: Folder,       required: true     }   },    setup(props, { emit }) {     const handleAction = (action: keyof ITEMS) => {       emit(`${action}-clicked`, props.folder)     }      return {       handleAction     }   } }) </script>","describe('FolderActionsDropdown', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with FolderActionsDropdownList', () => {     it('props binding', () => {       const folderActionsDropdownListWrapper =         findFolderActionsDropdownListWrapper(wrapper)        expect(folderActionsDropdownListWrapper.props('folderId')).toBe(4521)     })     describe('events binding', () => {       it('should send delete-clicked event with folder when FolderActionsDropdownList emit an item-clicked event with delete as action', async () => {         // When FolderActionsDropdownList emit an item-clicked event with delete action         const folderActionsDropdownListWrapper =           findFolderActionsDropdownListWrapper(wrapper)          await folderActionsDropdownListWrapper.vm.$emit(           'item-clicked',           'delete'         )          // Then FolderActionsDropdown should send 1 delete-clicked event with folder as payload         expect(wrapper.emitted('delete-clicked')).toHaveLength(1)         expect(wrapper.emitted('delete-clicked')).toStrictEqual([           [new Folder({ id: 4521, children: [] as Category[] } as Category)]         ])       })     })   }) }) "
"<template>   <natto-dropdown-item     :icon=""icon""     :label=""label""     :disabled=""disabled""     :tooltip-content=""noPermissionToDeleteFolder""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoDropdownItem from '@/Common/components/Dropdown/NattoDropdownItem.vue' import constants from '@/Common/constants'  export default defineComponent({   name: 'FolderActionDropdownItem',   components: { NattoDropdownItem },   props: {     label: {       type: String,       required: true     },     icon: {       type: String,       default: ''     },     disabled: Boolean   },    setup() {     return {       noPermissionToDeleteFolder: constants.messages.folders.delete.error     }   } }) </script>","describe('FolderActionDropdownItem', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('bindings with ElDropdownItem', () => {     it('props <=> :props', () => {       // Given FolderActionDropdownItem receive props       wrapper = createWrapper({         icon: 'delete',         label: 'Supprimer',         disabled: false       })        // Then ElDropdownItem must receive those props       const nattoDropdownItemWrapper = findNattoDropdownItem(wrapper)        expect(nattoDropdownItemWrapper.props('icon')).toBe('delete')       expect(nattoDropdownItemWrapper.props('disabled')).toBe(false)       expect(nattoDropdownItemWrapper.props('label')).toBe('Supprimer')       expect(nattoDropdownItemWrapper.props('tooltipContent')).toBe(         constants.messages.folders.delete.error       )     })   }) }) "
"<template>   <section class=""folder-actions-dropdown__list"">     <folder-action-dropdown-item       v-for=""{ action, label, icon, disabled } in folderActions""       :key=""action""       :label=""label""       :icon=""icon""       :disabled=""disabled""       @click=""handleClickItem(action)""     />   </section> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import FolderActionDropdownItem from '@/modules/Search/components/Navigation/FolderActionsDropdown/FolderActionsDropdownList/FolderActionDropdownItem.vue' import { useStore } from 'vuex' import useDeleteFolderHelpers from '@/modules/DataManipulation/Delete/DeleteFolder/store/helpers' import { ITEMS } from '@/Common/types/actionItemTypes'  export default defineComponent({   name: 'FolderActionsDropdownList',   components: { FolderActionDropdownItem },   props: {     folderId: {       type: Number,       required: true     }   },    setup(props, { emit }) {     const store = useStore()      const { hasPermissionToDeleteFolder, isFolderDeletable } =       useDeleteFolderHelpers(store)      const folderActions = computed(() => [       {         action: ITEMS.DELETE,         label: 'Supprimer',         icon: 'delete',         disabled:           !isFolderDeletable(props.folderId) ||           !hasPermissionToDeleteFolder(props.folderId)       }     ])      return {       folderActions,       handleClickItem: (action: string) => {         emit('item-clicked', action)       }     }   } }) </script>","describe('FolderActionsDropdownList', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with FolderActionsDropdownItem', () => {     it('should render 1 FolderActionsDropdownItem', () => {       expect(findFolderActionsDropdownItemWrappers(wrapper)).toHaveLength(1)     })     it('should emit item-click with folderId when FolderActionsDropdownItem emit click', async () => {       // When FolderActionsDropdownItem emit click       const folderActionsDropdownItemWrapper =         findFolderActionsDropdownItemWrappers(wrapper)[0]        await folderActionsDropdownItemWrapper.vm.$emit('click')        // Then it should emit item-click with action name       expect(wrapper.emitted('item-clicked')).toHaveLength(1)       expect(wrapper.emitted('item-clicked')).toStrictEqual([['delete']])     })     describe('item disabled depending on store getters', () => {       const cases = [         {           hasPermissionToDeleteFolder: false,           isFolderDeletable: false,           expectedDisabled: true         },         {           hasPermissionToDeleteFolder: false,           isFolderDeletable: true,           expectedDisabled: true         },         {           hasPermissionToDeleteFolder: true,           isFolderDeletable: false,           expectedDisabled: true         },         {           hasPermissionToDeleteFolder: true,           isFolderDeletable: true,           expectedDisabled: false         }       ]        it.each(cases)(         'should return $expectedDisabled when hasPermissionToDelete = $hasPermissionToDelete / isFolderDeletable = $isFolderDeletable',         ({           hasPermissionToDeleteFolder,           isFolderDeletable,           expectedDisabled         }) => {           // Given           wrapper = createWrapper(             defaultProps,             createDeleteFolderStoreMocked({               hasPermissionToDeleteFolder,               isFolderDeletable             })           )            // Then           const folderActionsDropdownItemWrapper =             findFolderActionsDropdownItemWrappers(wrapper)[0]            expect(folderActionsDropdownItemWrapper.props('disabled')).toBe(             expectedDisabled           )         }       )     })   }) }) "
"<template>   <natto-shortcut-card     prepend-icon=""reader""     :text=""$t('ged.search.arboCard.buttons.exploreMore')""     type=""secondary""   /> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoShortcutCard from '@/Common/components/Cards/NattoShortcutCard.vue'  export default defineComponent({   name: 'ArboExploreButton',   components: {     NattoShortcutCard   } }) </script>","describe('ArboExploreButton', () => {   beforeEach(() => {     wrapper = createWrapper()     nattoShortcutCardWrapper = findNattoShortcutCard(wrapper)   })   describe('binding with NattoShortcutCard', () => {     it('props bindings', () => {       expect(nattoShortcutCardWrapper.props('prependIcon')).toBe('reader')       expect(nattoShortcutCardWrapper.props('text')).toBe(         'ged.search.arboCard.buttons.exploreMore'       )       expect(nattoShortcutCardWrapper.props('type')).toBe('secondary')     })   }) }) "
"<template>   <natto-button class=""multiple-documents-cta"" :disabled=""disabled"">     <div class=""multiple-documents-cta__content"">       <slot name=""prepend-icon"" />       <span class=""multiple-documents-cta__text"">         {{ text }}       </span>     </div>   </natto-button> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoButton from '@/Common/components/Buttons/NattoButton.vue'  export default defineComponent({   name: 'MultipleDocumentsCta',   components: { NattoButton },   props: {     text: {       type: String,       required: true     },     disabled: Boolean   } }) </script>","describe('MultipleDocumentsCta', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('bindings with NattoButton', () => {     describe('rendering', () => {       it('should render the text and prepend icon', () => {         expect(wrapper.text()).toContain('The prepend icon Columbo')       })     })   }) }) "
"<template>   <multiple-documents-cta     :disabled=""selectedDocumentsIds.length === 0""     :text=""$t('ged.common.download')""   >     <template #prepend-icon>       <loading-icon size=""10"" v-if=""isMultipleDownloadLoading === true"" />       <download-icon v-else />     </template>   </multiple-documents-cta> </template>  <script lang=""ts""> import { defineComponent, PropType } from 'vue' import MultipleDocumentsCta from '@/modules/Search/components/Buttons/MultipleDocumentsCtas/MultipleDocumentsCta.vue' import DownloadIcon from '@/Common/components/Icons/DownloadIcon.vue' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import { useStore } from 'vuex'  export default defineComponent({   name: 'DownloadCta',   components: { LoadingIcon, DownloadIcon, MultipleDocumentsCta },   props: {     selectedDocumentsIds: {       type: Array as PropType<string[]>,       required: true     }   },   setup() {     const store = useStore()     const { isMultipleDownloadLoading } = useSearchStoreHelpers()      return {       isMultipleDownloadLoading: isMultipleDownloadLoading(store)     }   } }) </script>","describe('DownloadCta', () => {   beforeEach(() => {     wrapper = createWrapper()     multipleDocumentsCta = findMultipleDocumentsCta(wrapper)   })    describe('bindings with MultipleDocumentsCta', () => {     test('props bindings', () => {       expect(multipleDocumentsCta.props()).toStrictEqual({         text: 'ged.common.download',         disabled: false       })     })     describe('rendering', () => {       it('should render the download-icon via the MultipleDocumentsCta prepend-icon slot', () => {         expect(findDownloadIcon(wrapper).exists()).toBe(true)       })       it('should render the loading icon when isFileDeleting is true', () => {         wrapper = createWrapper({           store: createSearchStoreMocked({             multipleDownloadLoading: true           })         })          expect(findLoadingIcon(wrapper).exists()).toBe(true)         expect(findDownloadIcon(wrapper).exists()).toBe(false)       })     })   }) }) "
"<template>   <div class=""multiple-documents-ctas"">     <download-cta       :selected-documents-ids=""selectedDocumentsIds""       @click=""$emit('download-all-clicked')""     />     <delete-cta       :selected-documents-ids=""selectedDocumentsIds""       @click=""$emit('delete-all-clicked')""     />   </div> </template>  <script lang=""ts""> import { defineComponent, PropType } from 'vue' import DownloadCta from '@/modules/Search/components/Buttons/MultipleDocumentsCtas/DownloadCta.vue' import DeleteCta from '@/modules/Search/components/Buttons/MultipleDocumentsCtas/DeleteCta.vue'  export default defineComponent({   name: 'MultipleDocumentsCtas',   components: { DeleteCta, DownloadCta },   props: {     selectedDocumentsIds: {       type: Array as PropType<string[]>,       required: true     }   } }) </script>","describe('MultipleDocumentsCtas', () => {   beforeEach(() => {     wrapper = createWrapper()     downloadCta = findDownloadCta(wrapper)     deleteCta = findDeleteCta(wrapper)   })    describe('bindings with DownloadCta', () => {     describe('events', () => {       it('should emit download when DownloadCta emit a click event', async () => {         await downloadCta.vm.$emit('click')          expect(wrapper.emitted('download-all-clicked')).toHaveLength(1)       })     })   })    describe('bindings with DeleteCta', () => {     test('static props', () => {       expect(deleteCta.props('selectedDocumentsIds')).toStrictEqual(['27'])     })     describe('events', () => {       it('should emit download when DeleteCta emit a click event', async () => {         await deleteCta.vm.$emit('click')          expect(wrapper.emitted('delete-all-clicked')).toHaveLength(1)       })     })   }) }) "
"<template>   <multiple-documents-cta     :disabled=""isDeleteCtaDisabled""     :text=""$t('ged.common.delete')""   >     <template #prepend-icon>       <loading-icon v-if=""isFileDeleting()"" size=""10"" />       <delete-icon v-else />     </template>   </multiple-documents-cta> </template>  <script lang=""ts""> import { computed, defineComponent, PropType } from 'vue' import MultipleDocumentsCta from '@/modules/Search/components/Buttons/MultipleDocumentsCtas/MultipleDocumentsCta.vue' import DeleteIcon from '@/Common/components/Icons/DeleteIcon.vue' import { useStore } from 'vuex' import useDeleteFileHelpers from '@/modules/DataManipulation/Delete/DeleteFile/store/helpers' import LoadingIcon from '@/Common/components/Icons/LoadingIcon.vue'  export default defineComponent({   name: 'DeleteCta',   components: { LoadingIcon, DeleteIcon, MultipleDocumentsCta },   props: {     selectedDocumentsIds: {       type: Array as PropType<string[]>,       required: true     }   },    setup(props) {     const store = useStore()     const { areDocumentsDeletable, isFileDeleting } =       useDeleteFileHelpers(store)      const isDeleteCtaDisabled = computed(       () =>         isFileDeleting() ||         props.selectedDocumentsIds.length === 0 ||         !areDocumentsDeletable(props.selectedDocumentsIds)     )      return {       isDeleteCtaDisabled,       isFileDeleting     }   } }) </script>","describe('DeleteCta', () => {   beforeEach(() => {     wrapper = createWrapper()     multipleDocumentsCta = findMultipleDocumentsCta(wrapper)   })    describe('bindings with MultipleDocumentsCta', () => {     describe('props bindings', () => {       test('static props', () => {         expect(multipleDocumentsCta.props()).toStrictEqual({           text: 'ged.common.delete',           disabled: true         })       })       it.each([         {           selectedDocumentsIds: [],           areDocumentsDeletable: false,           disabled: true         },         {           selectedDocumentsIds: [],           areDocumentsDeletable: true,           disabled: true         },         {           selectedDocumentsIds: ['19', '27'],           areDocumentsDeletable: false,           disabled: true         },         {           selectedDocumentsIds: ['19', '27'],           areDocumentsDeletable: true,           disabled: false         }       ])(         'should disabled the delete cta when areDocumentsDeletable is false',         ({ selectedDocumentsIds, areDocumentsDeletable, disabled }) => {           wrapper = createWrapper({             props: { selectedDocumentsIds },             store: createDeleteFileStoreMocked({               areDocumentsDeletable             })           })            expect(findMultipleDocumentsCta(wrapper).props('disabled')).toBe(             disabled           )         }       )     })     describe('rendering', () => {       it('should render the delete icon via the MultipleDocumentsCta prepend-icon slot', () => {         expect(findDeleteIcon(wrapper).exists()).toBe(true)       })       it('should render the loading icon when isFileDeleting is true', () => {         wrapper = createWrapper({           store: createDeleteFileStoreMocked({             isFileDeleting: true           })         })          expect(findLoadingIcon(wrapper).exists()).toBe(true)         expect(findDeleteIcon(wrapper).exists()).toBe(false)       })     })   }) }) "
"<template>   <div class=""shortcut-grid"">     <div class=""title-area"">       <span class=""title-font"">Mes raccourcis</span>     </div>     <div class=""cards-area"">       <div class=""shortcut-cards"">         <shortcut-card           v-for=""(item, index) in folders.collection""           :key=""index""           :folder=""item""           @click=""folderCardClicked(item.id)""         >         </shortcut-card>       </div>     </div>   </div> </template>  <script lang=""ts""> import ShortcutCard from '@/modules/Search/components/Shortcuts/ShortcutCard.vue' import Folders from '@/modules/Search/models/Folders/Inputs/Folders' export default {   name: 'ShortcutsGrid',   components: { ShortcutCard },    props: {     folders: {       type: Folders,       required: true     }   },   emits: ['folder-shortcut-click'],    setup(     props: Record<string, Folders>,     { emit }: { emit: (event: string, ...args: unknown[]) => void }   ): Record<string, (id: number) => void> {     const folderCardClicked = (id: number) => {       emit('folder-shortcut-click', id)     }      return {       folderCardClicked     }   } } </script>","describe('DocumentsViewHeader', () => {   describe('bindings', () => {     describe('props', () => {       it('Should send correct folder when send folders props', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ])         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(ShortcutCard)          expect(shortcutCardWrappper[0].vm.folder).toEqual({           id: 1122,           name: 'Comptabilité',           parentId: 0,           children: [],           properties: {},           permissions: []         })         expect(shortcutCardWrappper[1].vm.folder).toEqual({           id: 1233,           name: 'Gestion Sociale',           parentId: 0,           children: [],           properties: {},           permissions: []         })       })     })     describe('events', () => {       it('Should fire folder-shortcut-click event when click event is fired', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ])         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(ShortcutCard)          shortcutCardWrappper[0].vm.$emit('click', 1122)          expect(wrapper.emitted()['folder-shortcut-click']).toBeTruthy()         expect(wrapper.emitted()['folder-shortcut-click']).toHaveLength(1)         expect(wrapper.emitted()['folder-shortcut-click'][0]).toStrictEqual([           1122         ])       })     })   })   describe('rendering', () => {     describe('props', () => {       it('Should dispaly folders when send folders props', () => {         const wrapper = createWrapper(           Folders.loaded([             {               id: 1122,               name: 'Comptabilité',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             },             {               id: 1233,               name: 'Gestion Sociale',               parent: { id: 0 },               children: [],               properties: {},               permissions: []             }           ])         )         const shortcutCardWrappper: VueWrapper<any>[] =           wrapper.findAllComponents(ShortcutCard)          expect(shortcutCardWrappper).toHaveLength(2)       })     })   }) }) "
"<template>   <router-view     v-model:is-document-upload-modal-opened=""isDocumentUploadModalOpened""     @disable-selection-categories=""disabledSelectionCategories = $event""     @upload-all-files-same-folder=""triggerUploadAllFiles = true""     @on-files-dropped=""showPopup""   />   <documents-upload-modal     v-model=""isDocumentUploadModalOpened""     :disabled-categories=""disabledSelectionCategories""     :trigger-upload-all-files=""triggerUploadAllFiles""     @reset=""resetHandler""   /> </template>  <script lang=""ts""> import {   computed,   defineComponent,   onMounted,   ref,   watch,   onBeforeUnmount } from 'vue' import { router } from '@kpmg/mypulse-shared-dependencies' import { useStore } from 'vuex' import DocumentsUploadModal from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/DocumentsUploadModal.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers' import uploadModalHelper from '@/modules/DataManipulation/Upload/helpers/uploadModalHelper' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'SearchPage',   components: {     DocumentsUploadModal   },   setup() {     const store = useStore()     const {       accountId,       fetchFolders,       fetchDocuments,       fetchDocumentsTotalCount,       setPage,       addFetchDocumentsSubscriber     } = useSearchStoreHelpers()      const unsubscribe = addFetchDocumentsSubscriber(store)      onBeforeUnmount(() => {       unsubscribe()     })      const {       getFiles,       setGedNotification,       cancelFilesUpload,       closeGedNotification,       sortFiles     } = useUploadStoreHelpers()      const { cancelFileUploadNotification, getUploadNotification } =       uploadModalHelper()      const { goToMainView } = useSearchNavigator()      const isDocumentUploadModalOpened = ref(false)     const ready = computed(() => accountId(store))     const disabledSelectionCategories = ref(false)     const triggerUploadAllFiles = ref(false)      onMounted(async () => {       await fetchFolders(store)     })      const resetHandler = async () => {       isDocumentUploadModalOpened.value = false       triggerUploadAllFiles.value = false       showPopup(false, true)       setPage(store, 1)        await Promise.all([         fetchDocuments(store),         fetchDocumentsTotalCount(store)       ])     }      const cancelUploadConfirmationHandler = (action: string) => {       if (action === 'confirm') {         trackEventFactory(analyticsCode['upt-upload-cancel-popup-continue'])         showPopup(true)         cancelFilesUpload(store)       } else if (action === 'cancel') {         trackEventFactory(analyticsCode['upt-upload-cancel-popup-cancel'])       }     }      const showPopup = (loading?: boolean, fromModal?: boolean) => {       if (         !getFiles(store).value ||         getFiles(store).value.some((f) => f.ready()) ||         (getFiles(store).value.every((f) => f.finished()) && fromModal)       ) {         return       }       closeGedNotification(store)       const notification = getUploadNotification(         loading,         getFiles(store),         () => cancelFileUploadNotification(cancelUploadConfirmationHandler),         () => closeGedNotification(store),         () => openUploadModal()       )        setGedNotification(store, notification)     }      const openUploadModal = () => {       // todo: move the upload modal to the app.vue       // (edge case when we are in trash the upload modal is not visible bcz of variables scope that is only for searchpage)       sortFiles(store)       if (         router.currentRoute.value.path.includes('/documents/trash') ||         !router.currentRoute.value.path.includes('/documents')       ) {         goToMainView({ openFilesUploadModal: true })       } else {         isDocumentUploadModalOpened.value = true       }     }      watch(isDocumentUploadModalOpened, () => {       if (isDocumentUploadModalOpened.value) {         closeGedNotification(store)       } else {         trackEventFactory(analyticsCode['updm-select-destination-cross-close'])       }     })      return {       openUploadModal,       ready,       isDocumentUploadModalOpened,       resetHandler,       disabledSelectionCategories,       triggerUploadAllFiles,       showPopup     }   } }) </script>","describe('SearchPage', () => {   beforeEach(() => {     // Given Search.vue is mounted     wrapper = createWrapper()     storeMock.dispatch = jest.fn()     mockGoToMainView.mockClear()   })    describe('on created', () => {     it('should subscribe to fetchDocuments action', async () => {       await wrapper.vm.$nextTick()       expect(mockTest).toHaveBeenCalled()     })     it.each(['/trash', '/bank', 'documents/trash'])(       'openUploadModal when route is %s',       async (currentRoute) => {         routerMock.currentRoute.value.path = currentRoute         wrapper.vm.openUploadModal()         await wrapper.vm.$nextTick()         expect(mockGoToMainView).toHaveBeenCalledWith({           openFilesUploadModal: true         })       }     )     it.each(['/documents', '/documents/arbo'])(       'openUploadModal when route is %s',       async (currentRoute) => {         routerMock.currentRoute.value.path = currentRoute         wrapper.vm.openUploadModal()         await wrapper.vm.$nextTick()         expect(mockGoToMainView).not.toHaveBeenCalled()         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          expect(documentsUploadModalWrapper.props().modelValue).toBe(true)       }     )   })   describe('events', () => {     describe('events from RouterView', () => {       it('Should bind payload from update:isDocumentUploadModalOpened event with modelValue DocumentsUploadModal property', async () => {         // When RouterView receive an update:isDocumentUploadModalOpened event with true as payload         const routerViewWrapper = findRouterView(wrapper)          await routerViewWrapper.vm.$emit(           'update:isDocumentUploadModalOpened',           true         )          // Then modelValue property of DocumentsUploadModal must be true         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          expect(documentsUploadModalWrapper.props().modelValue).toBe(true)         expect(storeMock.dispatch).toHaveBeenCalledWith(           `${uploadModule('closeGedNotification')}`         )       })       it('Should bind payload from disable-selection-categories event with disabledCategories DocumentsUploadModal property', async () => {         // When RouterView receive a disable-selection-categories event with true as payload         const routerViewWrapper = findRouterView(wrapper)          await routerViewWrapper.vm.$emit('disable-selection-categories', true)          // Then disabledCategories property of DocumentsUploadModal must be true         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          expect(documentsUploadModalWrapper.props().disabledCategories).toBe(           true         )       })       it('Should bind payload from upload-all-files-same-folder event with triggerUploadAllFiles DocumentsUploadModal property', async () => {         // When RouterView receive a disable-selection-categories event with true as payload         const routerViewWrapper = findRouterView(wrapper)          await routerViewWrapper.vm.$emit('upload-all-files-same-folder')          // Then triggerUploadAllFiles property of DocumentsUploadModal must be true         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          expect(documentsUploadModalWrapper.props().triggerUploadAllFiles).toBe(           true         )       })     })     describe('events from DocumentsUploadModal', () => {       it('Should bind payload from update:modelValue event with isDocumentUploadModalOpened RouterView property', async () => {         // When RouterView receive a on-selected-folder-change event with 27 as payload         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          await documentsUploadModalWrapper.vm.$emit('update:modelValue', true)          // Then isDocumentUploadModalOpened property of RouterView must be true         const routerViewWrapper = findRouterView(wrapper)          expect(routerViewWrapper.props().isDocumentUploadModalOpened).toBe(true)       })       it('Should dispatch setPaginator, fetchDocuments and fetchDocumentsTotalCount actions, when reset is emitted', async () => {         // When DocumentsUploadModal emit reset         const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =           findDocumentsUploadModal(wrapper)          await documentsUploadModalWrapper.vm.$emit('reset')          // Then setPaginator and fetchDocuments  actions must be dispatched         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setPaginator',           new DocumentsPaginator()         )         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/fetchDocuments'         )         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/fetchDocumentsTotalCount'         )       })       describe('showPopup', () => {         it('Should call setGedNotifications when on-files-dropped event fired (all-files-authorized)', async () => {           storeMock.state.GED.DataManipulation.Upload.files = filesProgressCase           await wrapper.vm.$nextTick()           const routerViewWrapper = findRouterView(wrapper)            await routerViewWrapper.vm.$emit('on-files-dropped')           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             `${uploadModule('setGedNotification')}`,             'the notification'           )         })         it('Should call setGedNotifications when on-files-dropped event fired (some-files-authorized-other-no)', async () => {           storeMock.state.GED.DataManipulation.Upload.files = [             ...filesProgressCase,             ...filesFailedCase           ]            await wrapper.vm.$nextTick()           const routerViewWrapper = findRouterView(wrapper)            await routerViewWrapper.vm.$emit('on-files-dropped')           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             `${uploadModule('setGedNotification')}`,             'the notification'           )         })         it('Should call setGedNotifications when on-files-dropped event fired (all-files-are-unauthorized)', async () => {           storeMock.state.GED.DataManipulation.Upload.files = filesFailedCase            await wrapper.vm.$nextTick()           const routerViewWrapper = findRouterView(wrapper)            await routerViewWrapper.vm.$emit('on-files-dropped')           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             `${uploadModule('setGedNotification')}`,             'the notification'           )         })         it('Should not call setGedNotifications when on-files-dropped event fired (all-files-are-already-uploaded', async () => {           storeMock.state.GED.DataManipulation.Upload.files = FileUploadMock            await wrapper.vm.$nextTick()           const routerViewWrapper = findRouterView(wrapper)            await routerViewWrapper.vm.$emit('on-files-dropped')           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             `${uploadModule('setGedNotification')}`,             'the notification'           )         })         it('Should dispatch setPaginator, fetchDocuments, fetchDocumentsTotalCount and setGedNotifications actions, when reset is emitted', async () => {           storeMock.state.GED.DataManipulation.Upload.files = filesProgressCase            await wrapper.vm.$nextTick()            // When DocumentsUploadModal emit reset           const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =             findDocumentsUploadModal(wrapper)            await documentsUploadModalWrapper.vm.$emit('reset')            expect(storeMock.dispatch).toHaveBeenNthCalledWith(             1,             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).toHaveBeenNthCalledWith(             2,             `${uploadModule('setGedNotification')}`,             'the notification'           )           // Then setPaginator and fetchDocuments  actions must be dispatched           expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/setPaginator',             new DocumentsPaginator()           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocuments'           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocumentsTotalCount'           )            expect(global.ElNotification).toHaveBeenCalled()         })         it('Should dispatch only setPaginator, fetchDocuments, fetchDocumentsTotalCount actions, when reset is emitted with every files are finished', async () => {           storeMock.state.GED.DataManipulation.Upload.files = FileUploadMock            await wrapper.vm.$nextTick()            // When DocumentsUploadModal emit reset           const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =             findDocumentsUploadModal(wrapper)            await documentsUploadModalWrapper.vm.$emit('reset')            expect(storeMock.dispatch).not.toHaveBeenCalledWith(             `${uploadModule('closeGedNotification')}`           )           expect(storeMock.dispatch).not.toHaveBeenCalledWith(             `${uploadModule('setGedNotification')}`,             'the notification'           )            // Then setPaginator and fetchDocuments  actions must be dispatched           expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/setPaginator',             new DocumentsPaginator()           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocuments'           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocumentsTotalCount'           )         })         it('Should dispatch setPaginator, fetchDocuments, fetchDocumentsTotalCount and setGedNotifications actions, when reset is emitted and files are failling to upload', async () => {           storeMock.state.GED.DataManipulation.Upload.files = filesFailedCase            await wrapper.vm.$nextTick()            // When DocumentsUploadModal emit reset           const documentsUploadModalWrapper: VueWrapper<ComponentPublicInstance> =             findDocumentsUploadModal(wrapper)            await documentsUploadModalWrapper.vm.$emit('reset')            // Then setPaginator and fetchDocuments  actions must be dispatched           expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/setPaginator',             new DocumentsPaginator()           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocuments'           )            expect(storeMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchDocumentsTotalCount'           )            expect(global.ElNotification).toHaveBeenCalled()         })       })     })   }) }) "
"<template>   <arbo-view-layout>     <template #documents-view-header>       <arbo-header         v-if=""!folders?.isLoading""         :search-folder-id=""searchFolderId""         :folders=""folders""         :disabledUpload=""isUploading""         :canUploadFiles=""canUpload""         :hasAccessDs=""hasAccessDs""         @back-click=""handleBackToMainView""         @upload-triggered=""handleFilesOnChange""         @update:searchFolderId=""dispatchSetSearchFolderId""       />     </template>     <template #list-view>       <div class=""browse-documents display:flex"">         <documents-search-filters           :search=""filters.search""           :active-filters-count=""activeFiltersCount""           @update:search=""handleChangeInput""           @change-filters=""handleChangeFilters""           @reset-filters=""handleResetFilters""         />         <arbo-documents-table           ref=""arboTableRef""           :search-folder-id=""searchFolderId""           :documents=""documents""           :folders=""folders""           :documents-total-in-folder-and-child=""paginator.totalItems""           :documents-total-in-all-folders=""documentsTotalCount""           :documents-per-page=""paginator.itemsPerPage""           :pageNumber=""paginator.pageNumber""           :search=""filters.search""           :sort-options=""sortOptions""           :is-table-drop-zone-disabled=""isTableDropZoneDisabled""           @sort-arbo-table=""sortTableHandler""           @on-download-document=""dispatchDownloadDocument""           @page-opened=""pageChanged""           @click-on-total-count=""handleBackToMainView(false)""           @update:searchFolderId=""dispatchSetSearchFolderId""           @files-dropped=""handleFilesDropped""           @document-clicked=""handleDocumentClicked""           @on-actions-click=""handleActionsSelection""         />       </div>       <document-details-drawer         v-model:opened=""showDocDrawer""         :document=""documentSelected""       />     </template>   </arbo-view-layout> </template>  <script lang=""ts""> import { defineComponent, onMounted, provide, computed, ref } from 'vue' import { router } from '@kpmg/mypulse-shared-dependencies' import { useStore } from 'vuex' import useVModel from '@/Common/hooks' import FileUpload, {   StateUpload } from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import DocumentsPaginator from '@/modules/Search/models/Documents/Query/DocumentsPaginator' import ArboViewLayout from '@/modules/Search/components/Layouts/ArboViewLayout.vue' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers' import ArboHeader from '@/modules/Search/components/Headers/ArboHeader.vue' import ArboDocumentsTable from '@/modules/Search/components/DocumentsTable/ArboDocumentsTable.vue' import Period from '@/Common/models/List/Period' import DocumentsFilters from '@/modules/Search/models/Documents/Query/DocumentsFilters' import constants from '@/Common/constants' import DocumentsSearchFilters from '@/modules/Search/components/Filters/DocumentsSearchFilters.vue' import {   pageViewFactory,   trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import DocumentsSortOptions from '@/modules/Search/models/Documents/Query/DocumentsSortOptions' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator' import useUploadFilesMethod from '@/modules/DataManipulation/Upload/hooks/uploadFilesMethod' import DocumentDetailsDrawer from '@/modules/Search/components/Drawer/DocumentDetailsDrawer.vue' import Document from '@/modules/Search/models/Documents/Inputs/Document' import useDrawer from '@/modules/Search/hooks/useDrawer'  export default defineComponent({   name: 'ArboView',   components: {     DocumentsSearchFilters,     ArboDocumentsTable,     ArboHeader,     ArboViewLayout,     DocumentDetailsDrawer   },    props: {     isDocumentUploadModalOpened: {       type: Boolean,       required: true     }   },   emits: [     'on-selected-folder-change',     'disable-selection-categories',     'update:isDocumentUploadModalOpened',     'on-files-dropped'   ],    setup(props, { emit }) {     const arboTableRef = ref(null as any)      pageViewFactory(analyticsCode['arboview-pgv'])     const store = useStore()      const { handleDocumentClicked, documentSelected, showDocDrawer } =       useDrawer()      const {       folders,       documents,       fetchDocuments,       paginator,       setPaginator,       setPage,       setFilters,       resetFilters,       setSearchFolderId,       setSearch,       dispatchDownloadDocument,       filters,       flushDocumentsPromises,       documentsTotalCount,       searchFolderId,       setPeriod,       getActiveFiltersCount,       sortOptions,       setSortOptions,       setCertified     } = useSearchStoreHelpers()      const {       setFiles,       isUploading,       hasPermissionToUploadFile,       hasAccessDs,       setSelectedFolderToUpload     } = useUploadStoreHelpers()      const { uploadAllFilesInSameFolder } = useUploadFilesMethod()      const { goToMainView } = useSearchNavigator()      provide(       'documentsLoading',       computed(() => documents(store).value.isLoading)     )      const isDocumentUploadModalOpened = useVModel(       props,       'isDocumentUploadModalOpened'     )      const handleBackToMainView = async (reset = true) => {       if (reset) {         const parent = folders(store)?.value.getFolderById(           searchFolderId(store).value         )?.parentId          if (parent !== 0) {           setSearchFolderId(store, {             searchFolderId: parent ?? 0           })            await flushDocumentsPromises(store)         } else {           goToMainView()         }       } else {         goToMainView({ search: true })       }     }      const defaultPaginator = new DocumentsPaginator({       pageNumber: 1,       itemsPerPage: constants.ARBO_VIEW_ITEMS_PER_PAGE,       totalItems: 0     })      setPaginator(store, defaultPaginator)      setFilters(       store,       DocumentsFilters.createFromRouteQuery(router.currentRoute.value.query)     )      onMounted(async () => {       await flushDocumentsPromises(store)     })      const handleChangeInput = async (value: string) => {       setSearch(store, value)       setSearchFolderId(store, {         searchFolderId: searchFolderId(store).value,         findInChildFolders: Boolean(value) // Set at true only if a value is provided       })        setPaginator(store, defaultPaginator)        await flushDocumentsPromises(store)     }      const handleChangeFilters = async (filtersPayload: DocumentsFilters) => {       setPeriod(store, filtersPayload.period)       setCertified(store, filtersPayload.certified)       await flushDocumentsPromises(store)     }      const handleResetFilters = async () => {       setPeriod(store, new Period())       setSearch(store, '')       setCertified(store, 'all')       await flushDocumentsPromises(store)     }      const resetDocuments = async () => {       setPaginator(store, defaultPaginator)       setSortOptions(         store,         new DocumentsSortOptions({           sortBy: 'updated',           sortDirection: 'descending'         })       )       resetFilters(store)       await fetchDocuments(store)     }      const handleFilesOnChange = (filesData: File[]) => {       trackEventFactory(analyticsCode['adv-cta-upload-widget-click'])        const filesToUpload = filesData.map(         (f: File) => new FileUpload(f, StateUpload.TO_UPLOAD)       )        setFiles(store, filesToUpload)        setSelectedFolderToUpload(store, searchFolderId(store).value)        isDocumentUploadModalOpened.value = true     }      const pageChanged = async (pageNumber: number) => {       trackEventFactory(analyticsCode['adv-paginate'], pageNumber)       setPage(store, pageNumber)        await fetchDocuments(store)     }     const dispatchSetSearchFolderId = async (newSearchFolderId: number) => {       setSearchFolderId(store, {         searchFolderId: newSearchFolderId,         findInChildFolders: false       })       await resetDocuments()        trackEventFactory(         analyticsCode['adv-navigation-files'],         folders(store).value.getFolderDeepLevel(searchFolderId(store).value),         documents(store).value.collection.length       )       trackEventFactory(         analyticsCode['adv-navigation-folders'],         folders(store).value.getFolderDeepLevel(searchFolderId(store).value),         folders(store).value.getFolderById(searchFolderId(store).value)           ?.children.length ?? 0       )     }     const dispatchDownloadDocumentHandler = (documentId: string) => {       trackEventFactory(analyticsCode['adv-download-file'])       dispatchDownloadDocument(store, documentId)     }      const sortTableHandler = async (data: DocumentsSortOptions) => {       setSortOptions(store, data)       await fetchDocuments(store)     }      const handleFilesDropped = async (filesData: File[]) => {       const filesToUpload = filesData.map(         (f: File) => new FileUpload(f, StateUpload.TO_UPLOAD)       )        await setFiles(store, filesToUpload)        const emitOnFilesDropped = () => emit('on-files-dropped')        await uploadAllFilesInSameFolder(emitOnFilesDropped)     }      const handleActionsSelection = (document: Document) => {       documentSelected.value = document     }      return {       arboTableRef,       handleFilesDropped,       isTableDropZoneDisabled: computed(         () =>           isUploading(store).value ||           !hasPermissionToUploadFile(store, searchFolderId(store).value) ||           !hasAccessDs(store)       ),       canUpload: computed(() => {         return hasPermissionToUploadFile(store, searchFolderId(store).value)       }),       hasAccessDs: computed(() => {         return hasAccessDs(store)       }),       activeFiltersCount: getActiveFiltersCount(store),       folders: folders(store),       documents: documents(store),       documentsTotalCount: documentsTotalCount(store),       paginator: paginator(store),       handleChangeInput,       pageChanged,       handleFilesOnChange,       searchFolderId: searchFolderId(store),       dispatchDownloadDocument: (documentId: string) =>         dispatchDownloadDocumentHandler(documentId),       filters: filters(store),       handleBackToMainView,       dispatchSetSearchFolderId,       handleChangeFilters,       handleResetFilters,       isUploading: isUploading(store),       sortOptions: sortOptions(store),       sortTableHandler,       handleDocumentClicked,       showDocDrawer,       documentSelected,       handleActionsSelection     }   } }) </script>","describe('ArboView', () => {   beforeEach(async () => {     // Given ArboView is mounted     storeMock = createSearchStoreMocked()     storeMock.dispatch = jest.fn()      wrapper = createWrapper(storeMock)     arboDocumentsTableWrapper = findArboDocumentsTable(wrapper)     documentDetailsDrawer = findDocumentDetailsDrawer(wrapper)     expect(pageViewFactory).toBeCalledWith('arboview-pgv')   })   afterEach(() => {     jest.clearAllMocks()   })   describe('at creation', () => {     it('init paginator and searchFolderId', async () => {       // Given ArboView is mounted       wrapper = createWrapper()       // At mounted we set the searchFolderId with the value pass in props(from the router)        expect(storeMock.dispatch).toHaveBeenCalledWith(         'GED/Search/setPaginator',         {           pageNumber: 1,           itemsPerPage: constants.ARBO_VIEW_ITEMS_PER_PAGE,           totalItems: 0         }       )        expect(storeMock.dispatch).toHaveBeenCalledWith('GED/Search/setFilters', {         findInChildFolders: false,         folderId: 99,         search: '',         period: new Period(),         certified: 'all'       })     })   })   describe('binding with ArboDocumentsTable', () => {     describe('props', () => {       it('Should pass right props from store to BrowseDocumentsTable', () => {         // When the store getters return those values         wrapper = createWrapper(           createSearchStoreMocked({             folders: foldersData,             documents: docsData,             paginator: new Paginator({               totalItems: 100,               pageNumber: 1,               itemsPerPage: 10             }),             documentsTotalCount: 5421,             filters: new DocumentsFilters({               search: 'test',               folderId: 4521,               period: new Period(),               findInChildFolders: false             })           })         )          arboDocumentsTableWrapper = findArboDocumentsTable(wrapper)          // Then those must values must be bound with ArboDocumentsTable         expect(arboDocumentsTableWrapper.vm.folders).toEqual(foldersData)         expect(arboDocumentsTableWrapper.vm.documents).toEqual(docsData)         expect(           arboDocumentsTableWrapper.vm.documentsTotalInFolderAndChild         ).toBe(100)         expect(arboDocumentsTableWrapper.vm.documentsTotalInAllFolders).toBe(           5421         )         expect(arboDocumentsTableWrapper.vm.documentsPerPage).toBe(10)         expect(arboDocumentsTableWrapper.vm.pageNumber).toBe(1)         expect(arboDocumentsTableWrapper.vm.search).toBe('test')         expect(arboDocumentsTableWrapper.vm.searchFolderId).toBe(4521)         expect(arboDocumentsTableWrapper.vm.sortOptions).toEqual(           new DocumentsSortOptions({             sortBy: 'updated',             sortDirection: 'descending'           })         )       })       test.each([         {           isUploading: false,           hasPermissionToUploadFile: false,           hasAccessDs: false,           expectedDisabled: true         },         {           isUploading: false,           hasPermissionToUploadFile: false,           hasAccessDs: true,           expectedDisabled: true         },         {           isUploading: false,           hasPermissionToUploadFile: true,           hasAccessDs: false,           expectedDisabled: true         },         {           isUploading: false,           hasPermissionToUploadFile: true,           hasAccessDs: true,           expectedDisabled: false         },         {           isUploading: true,           hasPermissionToUploadFile: false,           hasAccessDs: false,           expectedDisabled: true         },         {           isUploading: true,           hasPermissionToUploadFile: false,           hasAccessDs: true,           expectedDisabled: true         },         {           isUploading: true,           hasPermissionToUploadFile: true,           hasAccessDs: false,           expectedDisabled: true         },         {           isUploading: true,           hasPermissionToUploadFile: true,           hasAccessDs: true,           expectedDisabled: true         }       ])(         'isTableDropZoneDisabled binding',         ({           isUploading,           hasPermissionToUploadFile,           hasAccessDs,           expectedDisabled         }) => {           // Given the wrapper is created with getters return values           const storeFileMocked = createFileStoreMock({             hasPermissionToUploadFile,             isUploading,             hasAccessDs           })            wrapper = createWrapper(storeFileMocked)            arboDocumentsTableWrapper = findArboDocumentsTable(wrapper)            // Then the prop isTableDropZoneDisabled must be set to good value           expect(arboDocumentsTableWrapper.vm.isTableDropZoneDisabled).toBe(             expectedDisabled           )         }       )     })     describe('events', () => {       it('Should uploadDocuments with state TO_UPLOAD when ArboDocumentsTable emits files-dropped', async () => {         const store = createFileStoreMock({           selectedFolderToUpload: 4521,           files: [             new FileUpload(               new File([''], 'File1.pdf', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'File2.pdf', { type: 'text/html' }),               StateUpload.TO_UPLOAD             ),             new FileUpload(               new File([''], 'File3.pdf', { type: 'text/html' }),               StateUpload.UPLOADED             )           ]         })          store.dispatch = jest.fn()         wrapper = createWrapper(store)          arboDocumentsTableWrapper = findArboDocumentsTable(wrapper)          const arrayOfBlob = new Array<Blob>()         const file1 = new File(arrayOfBlob, 'File1.pdf', {           type: 'application/pdf'         })          const file2 = new File(arrayOfBlob, 'File2.pdf', {           type: 'application/pdf'         })          await arboDocumentsTableWrapper.vm.$emit('files-dropped', [           file1,           file2         ])          await flushPromises()          // Then setFiles should have been dispatched         expect(store.dispatch).toHaveBeenNthCalledWith(           4,           'GED/DataManipulation/Upload/setFiles',           [             {               file: file1,               state: 0,               destination: null,               errorDescription: {}             },             {               file: file2,               state: 0,               destination: null,               errorDescription: {}             }           ]         )          expect(store.dispatch).toHaveBeenNthCalledWith(           5,           'GED/DataManipulation/Upload/setFileDestination',           { index: 0, destinationId: 4521 }         )         expect(store.dispatch).toHaveBeenNthCalledWith(           6,           'GED/DataManipulation/Upload/setFileState',           { index: 0, fileState: StateUpload.PENDING }         )         expect(store.dispatch).toHaveBeenNthCalledWith(           7,           'GED/DataManipulation/Upload/setFileDestination',           { index: 1, destinationId: 4521 }         )         expect(store.dispatch).toHaveBeenNthCalledWith(           8,           'GED/DataManipulation/Upload/setFileState',           { index: 1, fileState: StateUpload.PENDING }         )         expect(store.dispatch).toHaveBeenNthCalledWith(           9,           'GED/DataManipulation/Upload/uploadDocuments',           [0, 1]         )         expect(store.dispatch).toHaveBeenNthCalledWith(           10,           'GED/Search/fetchDocuments'         )          // And on-files-droppred must be emitted         expect(wrapper.emitted('on-files-dropped')).toHaveLength(1)       })       it('Should dispatch setPaginator and fetchDocuments when page-opened is emitted', async () => {         await arboDocumentsTableWrapper.vm.$emit('page-opened', 5)          expect(trackEventFactory).toBeCalledWith('adv-paginate', 5)         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setPaginator',           { itemsPerPage: 100, pageNumber: 5, totalItems: 0 }         )          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/fetchDocuments'         )       })       it('should dispatch downloadDocument when BrowseDocumentsTable emit on-download-document', async () => {         // When ArboDocumentsTable emit on-download-document         await arboDocumentsTableWrapper.vm.$emit(           'on-download-document',           'document-id'         )          expect(trackEventFactory).toBeCalledWith('adv-download-file')         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/downloadDocument',           'document-id'         )       })        it('Should dispatch with setFilters action when ArboDocumentsTable emits update:selectedFolderToUpload', async () => {         // When ArboDocumentsTable emits update:searchFolderId         await arboDocumentsTableWrapper.vm.$emit('update:searchFolderId', 27)          // Then dispatch with setFilters action must be call with 27         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 27,             search: '',             period: new Period(),             certified: 'all'           }         )       })        it('Should go to main view when click on total count and dont reset filters', async () => {         // When ArboDocumentsTable emits click-on-total-count         await arboDocumentsTableWrapper.vm.$emit('click-on-total-count')          // Then we should go to main view keeping the search (without reset the filters)         expect(storeMock.dispatch).not.toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 4521,             period: { endDate: '', startDate: '' },             search: 'test'           }         )         expect(routerMock.push).toHaveBeenCalledWith({           name: 'MainView',           query: {             search: true           }         })       })        it('Should change filters store and fetch documents when change-filters fired', async () => {         const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          const period = new Period({           startDate: '2018-02-01T23:00:00.000Z',           endDate: '2019-06-05T22:00:00.000Z'         })          const filters = new DocumentsFilters()          filters.period = period         filters.certified = true          await documentsSearchFiltersWrapper.vm.$emit('change-filters', filters)          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 0,             search: '',             period,             certified: 'all'           }         )         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 0,             search: '',             period: new Period(),             certified: true           }         )       })        it('Should change filters store and fetch documents when reset-search-filters fired', async () => {         const storeMockSample = createSearchStoreMocked({           filters: new DocumentsFilters({             search: 'not test',             folderId: 99,             period: new Period({               startDate: 'debut-de-2021',               endDate: 'fin-de-2021'             }),             findInChildFolders: false           })         })          wrapper = createWrapper(storeMockSample)         const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          await documentsSearchFiltersWrapper.vm.$emit('reset-filters')         await wrapper.vm.$nextTick()          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 99,             search: '',             period: new Period(),             certified: 'all'           }         )       })       it('Should dispatch setSortOptions on sort-arbo-table', async () => {         await arboDocumentsTableWrapper.vm.$emit(           'sort-arbo-table',           new DocumentsSortOptions({             sortBy: 'name',             sortDirection: 'ascending'           })         )          expect(storeMock.dispatch).toBeCalledWith(           'GED/Search/setSortOptions',           new DocumentsSortOptions({             sortBy: 'name',             sortDirection: 'ascending'           })         )       })       it('Should dispatch fetchDocuments on sort-arbo-table', async () => {         await arboDocumentsTableWrapper.vm.$emit(           'sort-arbo-table',           new DocumentsSortOptions({             sortBy: 'name',             sortDirection: 'ascending'           })         )          expect(storeMock.dispatch).toBeCalledWith('GED/Search/fetchDocuments')       })     })   })    describe('binding with DocumentsSearchFilters', () => {     describe('props', () => {       it('Should pass right props to DocumentsSearchFilters', () => {         wrapper = createWrapper(           createSearchStoreMocked({             filters: new DocumentsFilters({               search: 'test',               folderId: 4521,               period: new Period(),               findInChildFolders: false             })           })         )          const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          expect(documentsSearchFiltersWrapper.vm.search).toBe('test')         expect(documentsSearchFiltersWrapper.vm.activeFiltersCount).toBe(0)       })     })     describe('events', () => {       it('Should change filters store and fetch documents when handleChangeInput fired', async () => {         // Given         const store = createSearchStoreMocked({           filters: new DocumentsFilters({             search: 'not test',             folderId: 4521,             period: new Period(),             findInChildFolders: false           }),           paginator: new DocumentsPaginator({             pageNumber: 5           })         })          store.dispatch = jest.fn()          wrapper = createWrapper(store)          const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          await documentsSearchFiltersWrapper.vm.$emit('update:search', 'test')          await flushPromises()          expect(store.dispatch).toHaveBeenCalledWith('GED/Search/setFilters', {           findInChildFolders: false,           folderId: 4521,           search: 'test',           period: new Period(),           certified: 'all'         })         expect(store.dispatch).toHaveBeenCalledWith('GED/Search/setPaginator', {           itemsPerPage: 10,           pageNumber: 1,           totalItems: 0         })         expect(store.dispatch).toHaveBeenCalledWith('GED/Search/fetchDocuments')         expect(store.dispatch).toHaveBeenCalledWith(           'GED/Search/fetchDocumentsTotalCount'         )       })     })   })   describe('binding with ArboHeader', () => {     describe('binding', () => {       it('Should pass the correct canUploadFiles to child component', async () => {         const ArboHeaderWrapper = wrapper.findComponent(ArboHeader)          expect(ArboHeaderWrapper.props('canUploadFiles')).toBe(false)       })       it('Should pass the correct hasAccessDs to child component', () => {         // Given the store return hasAccessDs to true         const uploadStore = createFileStoreMock({           hasAccessDs: true         })          wrapper = createWrapper(uploadStore)          // Then hasAccessDs arboHeader prop must be also true         const ArboHeaderWrapper = wrapper.findComponent(ArboHeader)          expect(ArboHeaderWrapper.props('hasAccessDs')).toBe(true)       })     })     describe('rendering', () => {       const arboHeaderCases = [         { folders: Folders.loading(), arboHeaderExists: false },         { folders: Folders.loaded([]), arboHeaderExists: true }       ]        it.each(arboHeaderCases)(         'Should manage ArboHeader display in function of folders state',         async ({ folders, arboHeaderExists }) => {           wrapper = createWrapper(createSearchStoreMocked({ folders }))            await wrapper.vm.$nextTick()            const arboHeaderWrapper = wrapper.findComponent(ArboHeader)            expect(arboHeaderWrapper.exists()).toBe(arboHeaderExists)         }       )     })     describe('events', () => {       it('Should not be disabled when isUploading is false', async () => {         storeMock.state.GED.DataManipulation.Upload.files = [           new FileUpload(             new File([''], 'filename', { type: 'text/html' }),             StateUpload.UPLOADED           ),           new FileUpload(             new File([''], 'filename', { type: 'text/html' }),             StateUpload.CANCELED           )         ]          await wrapper.vm.$nextTick()          const ArboHeaderWrapper = wrapper.findComponent(ArboHeader)          expect(ArboHeaderWrapper.props('disabledUpload')).toBe(false)       })       it('Should be disabled when isUploading is true', async () => {         storeMock.state.GED.DataManipulation.Upload.files = [           new FileUpload(             new File([''], 'filename', { type: 'text/html' }),             StateUpload.UPLOADING           ),           new FileUpload(             new File([''], 'filename', { type: 'text/html' }),             StateUpload.PENDING           )         ]          await wrapper.vm.$nextTick()          const ArboHeaderWrapper = wrapper.findComponent(ArboHeader)          expect(ArboHeaderWrapper.props('disabledUpload')).toBe(true)       })       it('Should dispatch setFiles when ArboHeader emits upload-triggered', async () => {         const store = createSearchStoreMocked({           filters: new DocumentsFilters({             folderId: 27,             search: '',             period: new Period(),             findInChildFolders: false           })         })          store.dispatch = jest.fn()         wrapper = createWrapper(store)          const arboHeaderWrapper = wrapper.findComponent(ArboHeader)          const arrayOfBlob = new Array<Blob>()         const file1 = new File(arrayOfBlob, 'File1.pdf', {           type: 'application/pdf'         })          const file2 = new File(arrayOfBlob, 'File2.pdf', {           type: 'application/pdf'         })          await arboHeaderWrapper.vm.$emit('upload-triggered', [file1, file2])          await flushPromises()          expect(trackEventFactory).toBeCalledWith('adv-cta-upload-widget-click')         // Then setFiles should have been dispatched         expect(store.dispatch).toHaveBeenCalledWith(           'GED/DataManipulation/Upload/setFiles',           [             {               file: file1,               state: 0,               destination: null,               errorDescription: {}             },             {               file: file2,               state: 0,               destination: null,               errorDescription: {}             }           ]         )          // And setSelectedFolderToUpload must have been dispatched with searchFolderId value         expect(store.dispatch).toHaveBeenCalledWith(           'GED/DataManipulation/Upload/setSelectedFolderToUpload',           27         )       })       it('Should go to the main view when back-click ArboHeader emits back-click when currentfolder parentId is  0', async () => {         // When ArboHeader emits back-click         wrapper = createWrapper(           createSearchStoreMocked({             folders: foldersData,             filters: new DocumentsFilters({               search: 'test',               folderId: 1122,               period: new Period(),               findInChildFolders: false             })           })         )          const arboHeaderWrapper = wrapper.findComponent(ArboHeader)          await arboHeaderWrapper.vm.$emit('back-click')          // Then we should go to the main view         expect(routerMock.push).toHaveBeenCalledWith({           name: 'MainView'         })         expect(storeMock.dispatch).not.toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 4521,             period: { endDate: '', startDate: '' },             search: 'test'           }         )       })        it('Should go to the main view when back-click ArboHeader emits back-click when currentfolder parentId is not 0', async () => {         // When ArboHeader emits back-click         const storeMock = createSearchStoreMocked({           folders: foldersData,           filters: new DocumentsFilters({             search: '',             folderId: 1123,             period: new Period(),             findInChildFolders: false           })         })          storeMock.dispatch = jest.fn()          wrapper = createWrapper(storeMock)          const arboHeaderWrapper = wrapper.findComponent(ArboHeader)          await arboHeaderWrapper.vm.$emit('back-click')          //Then we should go back to folder parent         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             search: '',             folderId: 1222,             findInChildFolders: false,             period: new Period(),             certified: 'all'           }         )          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/fetchDocuments'         )       })        it('Should emit on-selected-folder-change when ArboHeader emits update:searchFolderId', async () => {         // When arboHeaderWrapper emits update:searchFolderId         const arboHeaderWrapper = wrapper.findComponent(ArboHeader)          await arboHeaderWrapper.vm.$emit('update:searchFolderId', 29)          // Then dispatch with setFilters action must be called with 29 as folderId         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/setFilters',           {             findInChildFolders: false,             folderId: 29,             search: '',             period: new Period(),             certified: 'all'           }         )       })     })   })    describe('binding with DocumentDetailsDrawer', () => {     const documentFile = new Document({       name: 'columbo.pdf'     } as DocumentFromAPI)      const openDrawer = async () =>       await arboDocumentsTableWrapper.vm.$emit('document-clicked', documentFile)      it('props binding', async () => {       // When ArboDocumentsTable emits document-clicked with a new Document as payload       await openDrawer()        // Then the payload must be bound with the DocumentDetailsDrawer prop document       documentDetailsDrawer = findDocumentDetailsDrawer(wrapper)       expect(documentDetailsDrawer.props('document')).toStrictEqual(         documentFile       )        expect(documentDetailsDrawer.props('opened')).toStrictEqual(true)     })   }) }) "
"<template>   <div     class=""main-view""     v-loading=""folders.isLoading""     element-loading-background=""transparent""   >     <main-view-layout       :disabled=""isUploading""       :hasAccessDs=""hasAccessDs""       is-main-view-btn       @upload-triggered=""handleFilesOnChangeByUploadBtn""     >       <template #tree>         <main-view-tree :folders=""folders"" />       </template>       <template #list-view>         <documents-search-filters           :search=""filters.search""           :active-filters-count=""activeFiltersCount""           @update:search=""handleChangeInput""           @change-filters=""handleChangeFilters""           @reset-filters=""handleResetFilters""         />         <template v-if=""areAnyFilters"">           <folder-tabs :folders=""folders"" @tab-selected=""tabSelectedHandler"" />           <documents-table             class=""main-doc-content""             :documents=""documents""             :search=""filters.search""             :are-all-documents-loaded=""areAllDocumentsLoaded""             @on-download-document=""dispatchDownloadDocument""             @on-scroll-to-bottom=""handleScrollToBottom""             @document-clicked=""handleDocumentClicked""           />         </template>         <div class=""arbo-card-list"" v-else>           <arbo-card-list />           <trash-card v-show=""folders.collection.length > 0"" />         </div>       </template>       <template #dragfile>         <documents-upload-box           v-show=""displayUploadBox""           :disabled=""isUploading""           @on-files-change=""handleFilesOnChangeByUploadBox""         />       </template>       <template #category>         <mail-to-ged-card           v-if=""folders.collection.length > 0""           @open-mail-to-ged=""handleOpenMailToGed""         />       </template>     </main-view-layout>     <who-upload-modal       v-model=""isUploadTypeModalOpened""       :folders=""folders""       @on-treat-by-client=""handleUploadByClient""       @on-treat-by-collab=""handleUploadByCollab""       @popup-folder-select-close=""handleUploadTypeModalClose""     />     <mail-to-ged-modal       v-model=""isMailToGedOpened""       :mailToGedInfos=""mailToGedInformations""       @close=""handleMailToGedCloseModal""       @more-info=""moreInfoHandler""     />     <document-details-drawer       v-model:opened=""showDocDrawer""       :document=""documentSelected""     />   </div> </template>  <script lang=""ts""> import { defineComponent, onMounted, ref, computed, watch } from 'vue' import { useStore } from 'vuex' import { router } from '@kpmg/mypulse-shared-dependencies'  import useVModel from '@/Common/hooks' import useSearchStoreHelpers from '@/modules/Search/store/helpers' import MainViewLayout from '@/modules/Search/components/Layouts/MainViewLayout.vue' import DocumentsTable from '@/modules/Search/components/DocumentsTable/DocumentsTable.vue' import FolderTabs from '@/modules/Search/components/Tabs/FolderTabs.vue' import DocumentsSearchFilters from '@/modules/Search/components/Filters/DocumentsSearchFilters.vue'  import useUploadStoreHelpers from '@/modules/DataManipulation/Upload/store/helpers' import WhoUploadModal from '@/modules/DataManipulation/Upload/components/WhoUploadModal/WhoUploadModal.vue' import DocumentsUploadBox from '@/modules/DataManipulation/Upload/components/DocumentsUploadModal/Activators/DocumentsUploadBox.vue' import DocumentsPaginator from '@/modules/Search/models/Documents/Query/DocumentsPaginator' import { StateUpload } from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import FileUpload from '@/modules/DataManipulation/Upload/models/Files/Inputs/FileUpload' import ArboCardList from '@/modules/Search/components/Cards/ArboCardList.vue' import MailToGedModal from '@/modules/DataManipulation/MailToGed/components/Modals/MailToGedModal.vue' import MailToGedCard from '@/modules/DataManipulation/MailToGed/components/MailToGedCard.vue' import {   pageViewFactory,   trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import TrashCard from '@/modules/Trash/components/Cards/TrashCard.vue' import redirections from '@/modules/DataManipulation/Upload/hooks/redirections' import useMailToGedStoreHelpers from '@/modules/DataManipulation/MailToGed/store/helpers' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator' import MainViewTree from '@/modules/Search/components/Trees/MainViewTree.vue' import Period from '@/Common/models/List/Period' import DocumentsFilters from '@/modules/Search/models/Documents/Query/DocumentsFilters' import useDrawer from '@/modules/Search/hooks/useDrawer' import DocumentDetailsDrawer from '@/modules/Search/components/Drawer/DocumentDetailsDrawer.vue'  export default defineComponent({   name: 'MainView',   components: {     DocumentDetailsDrawer,     MainViewTree,     TrashCard,     ArboCardList,     DocumentsSearchFilters,     MainViewLayout,     DocumentsTable,     DocumentsUploadBox,     FolderTabs,     WhoUploadModal,     MailToGedModal,     MailToGedCard   },   props: {     isDocumentUploadModalOpened: {       type: Boolean,       required: true     },     resetFilters: {       type: String,       default: 'true'     }   },   emits: [     'disable-selection-categories',     'upload-all-files-same-folder',     'update:isDocumentUploadModalOpened'   ],   setup(props, { emit }) {     pageViewFactory(analyticsCode['document-pgv'])     const store = useStore()     const { mailToGedInformations, GetMailToGedInformations } =       useMailToGedStoreHelpers(store)     const {       folders,       documents,       filters,       fetchDocuments,       fetchAndPushDocuments,       areAllDocumentsLoaded,       searchFolderId,       setSearchFolderId,       setSearch,       dispatchDownloadDocument,       setPaginator,       paginator,       setPage,       getActiveFiltersCount,       areAnyFilters,       setPeriod,       setCertified     } = useSearchStoreHelpers()      const {       setFiles,       setSelectedFolderToUpload,       isUploading,       closeGedNotification,       hasAccessDs     } = useUploadStoreHelpers()      const { goToMainView, goToArboView } = useSearchNavigator()      const isUploadTypeModalOpened = ref(false)      const { handleDocumentClicked, documentSelected, showDocDrawer } =       useDrawer()      const isDocumentUploadModalOpened = useVModel(       props,       'isDocumentUploadModalOpened'     )      const { goToDefaultFolder } = redirections()      onMounted(async () => {       setPaginator(store, new DocumentsPaginator())       setSearchFolderId(store, { searchFolderId: 0, findInChildFolders: true })       if (filters(store).value.search) {         await fetchDocuments(store)       }        if (router.currentRoute.value.query.openWhoUploadModal) {         isUploadTypeModalOpened.value = true       }        if (router.currentRoute.value.query.openFilesUploadModal) {         isDocumentUploadModalOpened.value = true       }     })      const isMailToGedOpened = ref(false)     const moreInfoHandler = () => {       if (mailToGedInformations.value.moreInformationLink) {         window.open(mailToGedInformations.value.moreInformationLink)       }     }      const handleOpenMailToGed = async () => {       GetMailToGedInformations()       isMailToGedOpened.value = true     }      const handleMailToGedCloseModal = () => {       isMailToGedOpened.value = false     }     const handleChangeInput = async (value: string) => {       setPage(store, 1)       setSearchFolderId(store, {         searchFolderId: searchFolderId(store).value,         findInChildFolders: true       })       setSearch(store, value)        await fetchDocuments(store)        goToMainView({ search: true })     }      const handleChangeFilters = async (filtersPayload: DocumentsFilters) => {       setPeriod(store, filtersPayload.period)       setCertified(store, filtersPayload.certified)        await fetchDocuments(store)        goToMainView({ search: true })     }      const handleResetFilters = async () => {       setSearch(store, '')       setPeriod(store, new Period())       setCertified(store, 'all')     }      const handleUploadTypeModalClose = () => {       if (isUploadTypeModalOpened.value) {         trackEventFactory(analyticsCode['updm-select-tree-cross-close'])         isUploadTypeModalOpened.value = false       }     }      const handleUploadByClient = (selectedDefaultFolderId: number) => {       trackEventFactory(analyticsCode['updm-select-tree-continue-client'])       isDocumentUploadModalOpened.value = true       isUploadTypeModalOpened.value = false       emit('disable-selection-categories', false)        goToDefaultFolder(         selectedDefaultFolderId,         folders(store),         selectDefaultFolder       )     }      const selectDefaultFolder = (defaultFolderId: number) => {       setSelectedFolderToUpload(store, defaultFolderId ?? 0)     }      const handleUploadByCollab = (selectedDefaultFolderId: number) => {       const folder = folders(store).value.getDefaultUploadFolderById(         selectedDefaultFolderId       )        if (folder?.id) {         trackEventFactory(analyticsCode['updm-select-tree-continue-collab'])         setSelectedFolderToUpload(store, folder.id)         emit('disable-selection-categories', true)         emit('upload-all-files-same-folder')         isDocumentUploadModalOpened.value = true         isUploadTypeModalOpened.value = false       }     }      const folderShortcutClickHandle = (folderId: number) => {       goToArboView({ folderId })     }      const tabSelectedHandler = async (searchFolderId: number) => {       setPage(store, 1)        setSearchFolderId(store, {         searchFolderId,         findInChildFolders: true       })        await fetchDocuments(store)     }      const handleFilesOnChange = (filesData: File[]) => {       setFiles(         store,         filesData.map((f: File) => new FileUpload(f, StateUpload.TO_UPLOAD))       )       isUploadTypeModalOpened.value = true       closeGedNotification(store)     }     const handleFilesOnChangeByUploadBox = (filesData: File[]) => {       trackEventFactory(analyticsCode['mdv-cta-upload-widget-click'])       handleFilesOnChange(filesData)     }     const handleFilesOnChangeByUploadBtn = (filesData: File[]) => {       trackEventFactory(analyticsCode['mdv-cta-upload-button-click'])       handleFilesOnChange(filesData)     }      const handleScrollToBottom = async () => {       if (areAllDocumentsLoaded(store).value) {         return       }        setPage(store, paginator(store).value.pageNumber + 1)        await fetchAndPushDocuments(store)     }      const activeFiltersCount = getActiveFiltersCount(store)      watch(       () => router.currentRoute.value.query,       (newVal, oldVal) => {         if (           (oldVal?.search && newVal?.search == null) ||           (oldVal?.search == null && newVal?.search == null)         ) {           handleResetFilters()         }       }     )      return {       moreInfoHandler,       mailToGedInformations,       handleOpenMailToGed,       isMailToGedOpened,       handleMailToGedCloseModal,       displayUploadBox: computed(         () => folders(store).value.collection.length > 0       ),       hasAccessDs: computed(() => {         return hasAccessDs(store)       }),       activeFiltersCount,       areAnyFilters: areAnyFilters(store),       folders: folders(store),       filters: filters(store),       handleChangeFilters,       handleResetFilters,       documents: documents(store),       areAllDocumentsLoaded: areAllDocumentsLoaded(store),       folderShortcutClickHandle,       tabSelectedHandler,       handleChangeInput,       dispatchDownloadDocument: (documentId: string) =>         dispatchDownloadDocument(store, documentId),       isUploadTypeModalOpened,       handleUploadByClient,       handleUploadByCollab,       handleUploadTypeModalClose,       handleScrollToBottom,       isUploading: isUploading(store),       handleFilesOnChangeByUploadBox,       handleFilesOnChangeByUploadBtn,       handleDocumentClicked,       documentSelected,       showDocDrawer     }   } }) </script>","describe('MainView', () => {   beforeEach(() => {     jest.clearAllMocks()      storeMock = createSearchStoreMocked({       areAnyFilters: true,       filters: new DocumentsFilters({         search: 'test',         period: new Period(),         folderId: 0,         findInChildFolders: true       })     })      wrapper = createWrapper(defaultProps, storeMock)     documentsTableWrapper = findDocumentsTable(wrapper)     expect(pageViewFactory).toBeCalledWith('document-pgv')     storeMock.dispatch = jest.fn()   })   afterEach(() => {     jest.clearAllMocks()   })    describe('onMounted', () => {     it('Should reset paginator and and set the folderId to 0 (all folders) and finally fetch the documents if filters.search is not undefined', async () => {       const storeWithSearch = createSearchStoreMocked({         filters: new DocumentsFilters({           search: 'test',           period: new Period(),           folderId: 0,           findInChildFolders: true         })       })        storeWithSearch.dispatch = jest.fn()        wrapper = await createWrapper(defaultProps, storeWithSearch)        expect(storeWithSearch.dispatch).toHaveBeenNthCalledWith(         1,         'GED/Search/setPaginator',         { pageNumber: 1, itemsPerPage: 100, totalItems: 0 }       )       expect(storeWithSearch.dispatch).toHaveBeenNthCalledWith(         2,         'GED/Search/setFilters',         {           search: 'test',           folderId: 0,           findInChildFolders: true,           period: new Period(),           certified: 'all'         }       )       expect(storeWithSearch.dispatch).toHaveBeenNthCalledWith(         3,         'GED/Search/fetchDocuments'       )     })     it('Should reset paginator and and set the folderId to 0 (all folders) and not fetch the documents if filters.search is undefined', async () => {       const storeNoFilterSearchMock = createSearchStoreMocked({         searchActive: false,         activeFiltersCount: 0,         folders: Folders.loaded([]),         filters: new DocumentsFilters({           findInChildFolders: true,           search: undefined as never,           period: new Period(),           folderId: 0         })       })        storeNoFilterSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeNoFilterSearchMock)        expect(storeNoFilterSearchMock.dispatch).toHaveBeenNthCalledWith(         1,         'GED/Search/setPaginator',         { pageNumber: 1, itemsPerPage: 100, totalItems: 0 }       )       expect(storeNoFilterSearchMock.dispatch).toHaveBeenNthCalledWith(         2,         'GED/Search/setFilters',         {           search: '',           folderId: 0,           findInChildFolders: true,           period: new Period(),           certified: 'all'         }       )       expect(storeNoFilterSearchMock.dispatch).not.toHaveBeenCalledWith(         3,         'GED/Search/fetchDocuments'       )     })     it('should open the WhoUploadModal When openWhoUploadModal query param is at true', async () => {       // Given openWhoUploadModal is at true       // Then the WhoUploadModal must be opened       expect(findWhoUploadModal(wrapper).props('modelValue')).toBe(true)     })   })    describe('events', () => {     describe('events from MailToGedModal', () => {       it(""Should handle more-info event when it's emitted"", async () => {         const w = { location: { origin: 'http://127.0.0.1' } } as Window         const mockWindowOpen = jest.fn().mockReturnValue(w)          window.open = mockWindowOpen          // When MailToGedModal emit more-info         const mailToGedModalWrapper: VueWrapper<ComponentPublicInstance> =           wrapper.findComponent(MailToGedModal)          mailToGedModalWrapper.vm.$emit('more-info')          // Then should navigate to the correct url         expect(mockWindowOpen).toBeCalledWith('https://www.kpmg.fr/mailtoged')       })        it(""Should handle close event when it's emitted"", async () => {         wrapper.vm.isMailToGedOpened = true          const mailToGedModalWrapper: VueWrapper<ComponentPublicInstance> =           wrapper.findComponent(MailToGedModal)          mailToGedModalWrapper.vm.$emit('close')         await wrapper.vm.$nextTick()          expect(wrapper.vm.isMailToGedOpened).toBe(false)       })     })     it('Should change filters store and fetch documents when tabSelectedHandler fired', async () => {       const storeWithSearchMock = createSearchStoreMocked({         documents: documentsData,         areAnyFilters: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         })       })        storeWithSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithSearchMock)        const documentsTabsWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(FolderTabs)        await documentsTabsWrapper.vm.$emit('tab-selected', 99)        // Reset the page to 1       expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         1,         'GED/Search/setPaginator',         {           itemsPerPage: 100,           pageNumber: 1,           totalItems: 0         }       )        // Set the folderId       expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         2,         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: 'test',           period: new Period(),           certified: 'all'         }       )        // fetch the documents       expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         3,         'GED/Search/fetchDocuments'       )     })      it('Should change filters store, reset pagination and fetch documents when handleChangeInput fired', async () => {       const storeWithSearchMock = createSearchStoreMocked({         searchActive: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         })       })        wrapper = createWrapper(defaultProps, storeWithSearchMock)        storeWithSearchMock.dispatch = jest.fn()        const documentsSearchFiltersWrapper = findDocumentsSearchFilters(wrapper)        await documentsSearchFiltersWrapper.vm.$emit('update:search', 'xf')        expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         1,         'GED/Search/setPaginator',         {           pageNumber: 1,           itemsPerPage: 100,           totalItems: 0         }       )       expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         2,         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: 'test',           period: new Period(),           certified: 'all'         }       )       expect(storeWithSearchMock.dispatch).toHaveBeenNthCalledWith(         3,         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: 'xf',           period: new Period(),           certified: 'all'         }       )     })      it('Should emit 3 events when on-treat-by-collab event is emitted', async () => {       const storeWithSearchMock = createSearchStoreMocked({         searchActive: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         }),         folders: foldersData       })        storeWithSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithSearchMock)        const popWrapper = wrapper.findComponent(WhoUploadModal)        await popWrapper.vm.$emit('on-treat-by-collab', 1122)        expect(trackEventFactory).toBeCalledWith(         'updm-select-tree-continue-collab'       )       expect(wrapper.emitted()['disable-selection-categories']).toBeTruthy()       expect(wrapper.emitted()['disable-selection-categories']).toHaveLength(1)       expect(         wrapper.emitted()['disable-selection-categories'][0]       ).toStrictEqual([true])       expect(wrapper.emitted()['upload-all-files-same-folder']).toBeTruthy()       expect(wrapper.emitted()['upload-all-files-same-folder']).toHaveLength(1)       // Then dispatch with setSelectedFolderToUpload action must be call with 1223       expect(storeWithSearchMock.dispatch).toHaveBeenCalledWith(         'GED/DataManipulation/Upload/setSelectedFolderToUpload',         1223       )        expect(popWrapper.props().modelValue).toBe(false)       expect(wrapper.props().isDocumentUploadModalOpened).toBe(true)     })      it('Should not emit any events when on-treat-by-collab event is emitted on folder that have 0 default folder', async () => {       const storeWithFolders = createSearchStoreMocked({         folders: Folders.loaded([           {             id: 1122,             name: 'Comptabilité',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           },           {             id: 1233,             name: 'Gestion Sociale',             parent: { id: 0 },             children: [],             properties: {},             permissions: []           }         ])       })        storeWithFolders.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithFolders)       const popWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(WhoUploadModal)        await popWrapper.vm.$emit('on-treat-by-collab', 1122)        expect(trackEventFactory).not.toBeCalledWith(         'updm-select-tree-continue-collab'       )       expect(wrapper.emitted()['disable-selection-categories']).toBeFalsy()        expect(wrapper.emitted()['upload-all-files-same-folder']).toBeFalsy()       // Then dispatch with setSelectedFolderToUpload action must be call with 1223       expect(storeWithFolders.dispatch).not.toHaveBeenCalledWith(         'GED/DataManipulation/Upload/setSelectedFolderToUpload',         1223       )     })      it('Should 2 events when on-treat-by-client event is emitted and folderId should be the default one', async () => {       const storeWithSearchMock = createSearchStoreMocked({         searchActive: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         }),         folders: foldersData       })        storeWithSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithSearchMock)        const popWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(WhoUploadModal)        await popWrapper.vm.$emit('on-treat-by-collab', 1122)        await popWrapper.vm.$emit('on-treat-by-client', 1122)       expect(trackEventFactory).toBeCalledWith(         'updm-select-tree-continue-client'       )       expect(wrapper.emitted()['disable-selection-categories']).toBeTruthy()       expect(wrapper.emitted()['disable-selection-categories']).toHaveLength(2)       expect(wrapper.emitted()['disable-selection-categories']).toStrictEqual([         [true],         [false]       ])       // Then dispatch with setSelectedFolderToUpload action must be call with 27       expect(storeWithSearchMock.dispatch).toHaveBeenCalledWith(         'GED/DataManipulation/Upload/setSelectedFolderToUpload',         1223       )        expect(popWrapper.props().modelValue).toBe(false)       expect(wrapper.props().isDocumentUploadModalOpened).toBe(true)     })      it('Should 2 events when on-treat-by-client event is emitted and folderId should not be the default one', async () => {       const foldersData = Folders.loaded([         {           id: 1122,           name: 'Forms',           parent: { id: 0 },           children: [             {               id: 1223,               name: 'Test',               parent: { id: 1122 },               children: [],               properties: {                 defaultUpload: true               },               permissions: []             }           ],           properties: {},           permissions: []         }       ])        const storeWithFolders = createSearchStoreMocked({         folders: foldersData       })        storeWithFolders.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithFolders)        const popWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(WhoUploadModal)        await popWrapper.vm.$emit('on-treat-by-client', 1122)       expect(trackEventFactory).toBeCalledWith(         'updm-select-tree-continue-client'       )       expect(wrapper.emitted()['disable-selection-categories']).toBeTruthy()       expect(wrapper.emitted()['disable-selection-categories']).toHaveLength(1)       expect(         wrapper.emitted()['disable-selection-categories'][0]       ).toStrictEqual([false])       // Then dispatch with setSelectedFolderToUpload action must be call with 27       expect(storeWithFolders.dispatch).toHaveBeenCalledWith(         'GED/DataManipulation/Upload/setSelectedFolderToUpload',         1122       )        expect(popWrapper.props().modelValue).toBe(false)       expect(wrapper.props().isDocumentUploadModalOpened).toBe(true)     })      it('Should close upload type modal popup-folder-select-close event is emitted', async () => {       const DocumentUploadBoxWrapper = wrapper.findComponent(DocumentsUploadBox)        const files = [         new FileUpload(           new File([''], 'filename', { type: 'text/html' }),           StateUpload.UPLOADED         ),         new FileUpload(           new File([''], 'filename', { type: 'text/html' }),           StateUpload.CANCELED         )       ]        DocumentUploadBoxWrapper.vm.$emit('on-files-change', files)        const popWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(WhoUploadModal)        await popWrapper.vm.$emit('popup-folder-select-close')       await wrapper.vm.$nextTick()        expect(trackEventFactory).toBeCalledWith('updm-select-tree-cross-close')       expect(popWrapper.props().modelValue).toBe(false)     })      it('Should change filters store and fetch documents when change-filters fired', async () => {       const storeWithSearchMock = createSearchStoreMocked({         searchActive: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         })       })        storeWithSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithSearchMock)        const documentsSearchFiltersWrapper = findDocumentsSearchFilters(wrapper)        const period = new Period({         startDate: '2018-02-01T23:00:00.000Z',         endDate: '2019-06-05T22:00:00.000Z'       })        const filters = new DocumentsFilters()        filters.period = period       filters.certified = true        await documentsSearchFiltersWrapper.vm.$emit('change-filters', filters)        expect(storeWithSearchMock.dispatch).toHaveBeenCalledWith(         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: 'test',           period,           certified: 'all'         }       )       expect(storeWithSearchMock.dispatch).toHaveBeenCalledWith(         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: 'test',           period: new Period(),           certified: true         }       )     })      it('Should change filters store and fetch documents when reset-search-filters fired', async () => {       const storeWithoutSearchMock = createSearchStoreMocked({         searchActive: true,         filters: new DocumentsFilters({           findInChildFolders: true,           search: '',           period: new Period(),           folderId: 0         })       })        storeWithoutSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeWithoutSearchMock)        const documentsSearchFiltersWrapper = findDocumentsSearchFilters(wrapper)        await documentsSearchFiltersWrapper.vm.$emit('reset-filters')        expect(storeWithoutSearchMock.dispatch).toHaveBeenCalledWith(         'GED/Search/setFilters',         {           findInChildFolders: true,           folderId: 0,           search: '',           period: new Period(),           certified: 'all'         }       )     })      it('Should fire closeGedNotification and set isUploadTypeModalOpened true when upload type modal is opeend', async () => {       const DocumentUploadBoxWrapper = wrapper.findComponent(DocumentsUploadBox)        const files = [         new FileUpload(           new File([''], 'filename', { type: 'text/html' }),           StateUpload.UPLOADED         ),         new FileUpload(           new File([''], 'filename', { type: 'text/html' }),           StateUpload.CANCELED         )       ]        DocumentUploadBoxWrapper.vm.$emit('on-files-change', files)       await wrapper.vm.$nextTick()        expect(trackEventFactory).toBeCalledWith('mdv-cta-upload-widget-click')       const popWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(WhoUploadModal)        expect(popWrapper.props().modelValue).toBe(true)       expect(storeMock.dispatch).toHaveBeenCalledWith(         'GED/DataManipulation/Upload/closeGedNotification'       )     })      describe('bindings', () => {       it('Should bind filters.search with search prop of DocumentSearchInput', async () => {         const storeSearchMock = createSearchStoreMocked({           searchActive: true,           filters: new DocumentsFilters({             findInChildFolders: true,             search: 'test',             period: new Period(),             folderId: 0           })         })          storeSearchMock.dispatch = jest.fn()          wrapper = createWrapper(defaultProps, storeSearchMock)          const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          expect(documentsSearchFiltersWrapper.vm.search).toBe('test')       })        it('Should bind activeFilters of DocumentsSearchFilters with good value when anyFilterActive ', async () => {         const documentsSearchFiltersWrapper =           findDocumentsSearchFilters(wrapper)          expect(documentsSearchFiltersWrapper.vm.activeFiltersCount).toBe(0)       })        it('Should bind folders from store to folders property of DocumentsTabs', () => {         const storeSearchMock = createSearchStoreMocked({           areAnyFilters: true,           folders: foldersData         })          wrapper = createWrapper(defaultProps, storeSearchMock)          const documentsTabsWrapper: VueWrapper<ComponentPublicInstance> =           wrapper.findComponent(FolderTabs)          expect(documentsTabsWrapper.props().folders).toStrictEqual(foldersData)       })        it('Should bind folders from store to folders property of WhoUploadModal', () => {         const storeSearchMock = createSearchStoreMocked({           folders: foldersData         })          wrapper = createWrapper(defaultProps, storeSearchMock)          const popWrapper: VueWrapper<ComponentPublicInstance> =           wrapper.findComponent(WhoUploadModal)          expect(popWrapper.props().folders).toStrictEqual(foldersData)          expect(popWrapper.props().modelValue).toBe(false)       })     })   })   describe('DocumentsTable bindings', () => {     beforeEach(() => {       const storeSearchMock = createSearchStoreMocked({         areAnyFilters: true,         documents: documentsData,         filters: new DocumentsFilters({           findInChildFolders: true,           search: 'test',           period: new Period(),           folderId: 0         })       })        storeSearchMock.dispatch = jest.fn()        wrapper = createWrapper(defaultProps, storeSearchMock)       documentsTableWrapper = wrapper.findComponent(DocumentsTable)     })     describe('props', () => {       it('Should bind props correctly', () => {         expect(documentsTableWrapper.vm.documents).toStrictEqual(documentsData)         expect(documentsTableWrapper.props('search')).toBe('test')       })       it('Should bind areAllDocumentsLoaded from store to areAllDocumentsLoaded prop of DocumentsTable', async () => {         const storeSearchMock = createSearchStoreMocked({           areAllDocumentsLoaded: true,           areAnyFilters: true         })          wrapper = createWrapper(defaultProps, storeSearchMock)          documentsTableWrapper = wrapper.findComponent(DocumentsTable)          expect(documentsTableWrapper.vm.areAllDocumentsLoaded).toStrictEqual(           true         )       })     })     describe('rendering', () => {       it('Should be hidden when no filters are active', () => {         const storeWithoutSearchMock = createSearchStoreMocked({           areAnyFilters: false         })          wrapper = createWrapper(defaultProps, storeWithoutSearchMock)         expect(wrapper.findComponent(DocumentsTable).exists()).toBeFalsy()       })        describe('ArboCard display', () => {         const displayArboCardsCases = [           {             areAnyFilters: false,             isDocumentsTableDisplayed: false           },           {             areAnyFilters: true,             isDocumentsTableDisplayed: true           }         ]          it.each(displayArboCardsCases)(           'switch between ArboCardList or DocumentsTable',           ({ areAnyFilters, isDocumentsTableDisplayed }) => {             // Given             wrapper = createWrapper(               defaultProps,               createSearchStoreMocked({ areAnyFilters })             )              // Then             expect(wrapper.findComponent(DocumentsTable).exists()).toBe(               isDocumentsTableDisplayed             )             expect(wrapper.findComponent(ArboCardList).exists()).toBe(               !isDocumentsTableDisplayed             )           }         )       })     })     describe('events', () => {       it('Should call dispatch downloadDocument action with good documentId when on-download-document event is emitted from DocumensTable', async () => {         const storeMock = createSearchStoreMocked({           areAnyFilters: true         })          storeMock.dispatch = jest.fn()          wrapper = createWrapper(defaultProps, storeMock)          // When DocumentsTable emit a on-download-document         documentsTableWrapper = wrapper.findComponent(DocumentsTable)         await documentsTableWrapper.vm.$emit('on-download-document', '55')          // Then dispatch must be called to call downloadDocument action with '55'         expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Search/downloadDocument',           '55'         )       })       describe('on-scroll-to-bottom', () => {         it('Should dispatch setPaginator with pageNumber incremented and fetchAndPushDocuments', async () => {           // Given the pageNumber is 1 and all the documents are not loaded yet           const storeSearchMock = createSearchStoreMocked({             areAnyFilters: true,             documents: documentsData,             paginator: new DocumentsPaginator({               totalItems: 75246,               pageNumber: 1             }),             filters: new DocumentsFilters({               findInChildFolders: true,               search: 'test',               period: new Period(),               folderId: 0             })           })            storeSearchMock.dispatch = jest.fn()            wrapper = createWrapper(defaultProps, storeSearchMock)            documentsTableWrapper = wrapper.findComponent(DocumentsTable)            // When DocumentsTable emit a on-scroll-to-bottom           await documentsTableWrapper.vm.$emit('on-scroll-to-bottom')            // Then dispatch setPaginator           expect(storeSearchMock.dispatch).toHaveBeenCalledWith(             'GED/Search/setPaginator',             new DocumentsPaginator({               pageNumber: 2,               itemsPerPage: 100,               totalItems: 75246             })           )           // And dispatch fetchAndPushDocuments           expect(storeSearchMock.dispatch).toHaveBeenCalledWith(             'GED/Search/fetchAndPushDocuments'           )         })         it('Should early exist if all the documents are loaded', async () => {           // Given the pageNumber is 1 and all the documents are not loaded yet           const storeSearchMock = createSearchStoreMocked({             areAnyFilters: true,             documents: documentsData,             paginator: new DocumentsPaginator({               totalItems: 1,               pageNumber: 1             }),             filters: new DocumentsFilters({               findInChildFolders: true,               search: 'test',               period: new Period(),               folderId: 0             })           })            storeSearchMock.dispatch = jest.fn()            wrapper = createWrapper(defaultProps, storeSearchMock)            documentsTableWrapper = wrapper.findComponent(DocumentsTable)            // When DocumentsTable emit a on-scroll-to-bottom           await documentsTableWrapper.vm.$emit('on-scroll-to-bottom')            // Then dispatch setPaginator           expect(storeMock.dispatch).not.toHaveBeenNthCalledWith(             1,             'GED/Search/setPaginator',             new DocumentsPaginator({               pageNumber: 2,               itemsPerPage: 100,               totalItems: 0             })           )           // And dispatch fetchAndPushDocuments           expect(storeMock.dispatch).not.toHaveBeenNthCalledWith(             2,             'GED/Search/fetchAndPushDocuments'           )         })       })       describe('Documents upload box binding', () => {         it.each([           { isUploading: false, disabled: false },           { isUploading: true, disabled: true }         ])(           'Should not be disabled when isUploading is false',           ({ isUploading, disabled }) => {             const searchFilesStore = createFileStoreMock({ isUploading })              wrapper = createWrapper(defaultProps, searchFilesStore)              const DocumentUploadBoxWrapper =               wrapper.findComponent(DocumentsUploadBox)              expect(DocumentUploadBoxWrapper.props('disabled')).toBe(disabled)           }         )       })     })   })   describe('MainViewLayout Bindings', () => {     it('Should pass the correct disabled to chaild component', () => {       const MainViewLayoutWrapper = wrapper.findComponent(MainViewLayout)        expect(wrapper.vm.isUploading).toBe(         MainViewLayoutWrapper.props('disabled')       )     })     it('Should pass the correct hasAccessDs to chaild component', () => {       const MainViewLayoutWrapper = wrapper.findComponent(MainViewLayout)        expect(wrapper.vm.hasAccessDs).toBe(         MainViewLayoutWrapper.props('hasAccessDs')       )     })     it('Should pass the correct isMainViewBtn to child component', () => {       const MainViewLayoutWrapper = wrapper.findComponent(MainViewLayout)        expect(MainViewLayoutWrapper.props('isMainViewBtn')).toBe(true)     })     it('should display loading mask when folders are loading', () => {       const log = console.log        console.log = jest.fn()        wrapper = createWrapper(         defaultProps,         createSearchStoreMocked({           folders: Folders.loading()         }),         {           Loading: (node: Node, binding: DirectiveBinding) => {             console.log(`v-loading value : ${binding.value}`) // execute the emission of the on-scroll-to-bottom event           }         }       )        expect(console.log).toHaveBeenCalledWith('v-loading value : true')        console.log = log     })   })   describe('TrashCard bindings', () => {     describe('rendering', () => {       const trashCardDisplayCases = [         {           folders: Folders.loaded([]),           visible: false         },         {           folders: useFoldersData().FoldersData,           visible: true         }       ]        it.each(trashCardDisplayCases)(         'it should render TrashCard if there is folder',         async ({ folders, visible }) => {           wrapper = createWrapper(             defaultProps,             createSearchStoreMocked({               searchActive: false,               activeFiltersCount: 0,               folders             })           )           const trashCrad: DOMWrapper<HTMLDivElement> =             wrapper.find('.trash-card')            await wrapper.vm.$nextTick()           expect(trashCrad.element.style.display !== 'none').toBe(visible)         }       )     })   })   describe('MailToGedCard', () => {     describe('rendering', () => {       const mailToGedCardDisplayCases = [         {           folders: Folders.errored(),           visible: false         },         {           folders: Folders.loading(),           visible: false         },         {           folders: Folders.loaded([]),           visible: false         },         {           folders: useFoldersData().FoldersData,           visible: true         }       ]        it.each(mailToGedCardDisplayCases)(         'should display MailToGedCard only if folders are loaded',         async ({ folders, visible }) => {           wrapper = createWrapper(             defaultProps,             createSearchStoreMocked({               folders             })           )           const mailToGedModalWrapper = findMailToGedCard(wrapper)            expect(mailToGedModalWrapper.exists()).toBe(visible)         }       )     })     it('Should bind mailToGedInfos correctly', () => {       const mailToGedModalWrapper: VueWrapper<ComponentPublicInstance> =         wrapper.findComponent(MailToGedModal)        expect(mailToGedModalWrapper.props('mailToGedInfos')).toEqual(         MailToGedData       )     })   })   describe('binding with DocumentDetailsDrawer', () => {     const documentFile = new Document({       name: 'columbo.pdf'     } as DocumentFromAPI)      const openDrawer = async () =>       await documentsTableWrapper.vm.$emit('document-clicked', documentFile)      it('props binding', async () => {       // When ArboDocumentsTable emits document-clicked with a new Document as payload       await openDrawer()        // Then the payload must be bound with the DocumentDetailsDrawer prop document       documentsDetailsDrawer = findDocumentDetailsDrawer(wrapper)       expect(documentsDetailsDrawer.props('document')).toStrictEqual(         documentFile       )        expect(documentsDetailsDrawer.props('opened')).toStrictEqual(true)     })   }) }) "
"<template>   <div class=""trash-documents-table"">     <natto-table       :table-data=""documents.collection""       :loading=""areDocumentsLoading""       :pageNumber=""pageNumber""       :items-per-page=""documentsPerPage""       :items-total=""documentsTotalInFolderAndChild""       :row-class-name=""trashDocumentRowClass""       paginated       @page-opened=""handlePageOpened""     >       <template #default>         <document-type-element />         <document-name-element           value=""Nom du dossier/document""           display-description         />         <!-- <trash-document-origin /> -->         <document-creation-date-element is-Trash value=""Création"" />         <trash-document-restore           @restore-icon-click=""handleRestoreFileClickedByTab""         />         <trash-documents-actions-element           @restore-clicked=""handleRestoreFileClickedByMenu""         />       </template>     </natto-table>     <restore-file-modal-confirmation       v-model=""fileRestoreModalState.isRestoreFileModalConfirmationOpened""       :document-id=""fileRestoreModalState.documentId""       @restore-confirm=""$emit('restore-document', $event)""     />   </div> </template>  <script lang=""ts""> import { defineComponent, reactive, computed } from 'vue' import NattoTable, {   ElementPlusTablePayload } from '@/Common/components/Table/NattoTable.vue'  import TrashDocuments from '@/modules/Trash/models/Inputs/TrashDocuments' import DocumentTypeElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentTypeElement.vue' import DocumentNameElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentNameElement.vue' import DocumentCreationDateElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentCreationDateElement.vue' import TrashDocumentRestore from '@/modules/Trash/components/TrashDocumentsTableElements/TrashDocumentRestore.vue' import TrashDocumentsActionsElement from '@/modules/Trash/components/TrashDocumentsTableElements/TrashDocumentsActionsElement.vue' import RestoreFileModalConfirmation from '@/modules/Trash/components/Modals/RestoreFileModalConfirmation.vue' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import { useStore } from 'vuex' import useTrashModule from '@/modules/Trash/store/helpers'  export default defineComponent({   name: 'TrashDocumentsTable',   components: {     DocumentCreationDateElement,     DocumentNameElement,     DocumentTypeElement,     NattoTable,     TrashDocumentsActionsElement,     TrashDocumentRestore,     RestoreFileModalConfirmation   },   props: {     documents: {       type: TrashDocuments,       required: true     },     documentsPerPage: {       type: Number,       required: true     },     documentsTotalInFolderAndChild: {       type: Number,       default: 0     },     pageNumber: {       type: Number,       default: 1     }   },   emits: ['page-opened', 'restore-document'],   setup(props, { emit }) {     const store = useStore()     const { isInPendingList } = useTrashModule(store)      const handlePageOpened = (pageNumber: number) => {       emit('page-opened', pageNumber)     }      const fileRestoreModalState = reactive({       isRestoreFileModalConfirmationOpened: false,       documentId: ''     })      const trashDocumentRowClass = ({       row     }: ElementPlusTablePayload): string => {       return isInPendingList(row.id) ? 'row--disabled' : ''     }      const handleRestoreFileClickedByTab = (documentId: string) => {       if (!isInPendingList(documentId)) {         trackEventFactory(analyticsCode['tdv-tab-restore'])         handleRestoreFileClicked(documentId)       }     }      const handleRestoreFileClickedByMenu = (documentId: string) => {       if (!isInPendingList(documentId)) {         trackEventFactory(analyticsCode['tdv-menu-restore'])         handleRestoreFileClicked(documentId)       }     }      const handleRestoreFileClicked = (documentId: string) => {       fileRestoreModalState.documentId = documentId       fileRestoreModalState.isRestoreFileModalConfirmationOpened = true     }      const areDocumentsLoading = computed(() => {       return props.documents.state === 'loading'     })      return {       handlePageOpened,       fileRestoreModalState,       handleRestoreFileClickedByTab,       handleRestoreFileClickedByMenu,       areDocumentsLoading,       trashDocumentRowClass     }   } }) </script>","describe('TrashDocumentsTable', () => {   beforeEach(() => {     wrapper = createWrapper()     mainStoreMock.dispatch = jest.fn()   })    describe('bindings with NattoTable', () => {     describe('props', () => {       nattoTableWrapper = findNattoTable(wrapper)        expect(nattoTableWrapper.vm.tableData.length).toEqual(         defaultProps.documents.collection.length       )       expect(nattoTableWrapper.vm.itemsPerPage).toBe(10)       expect(nattoTableWrapper.vm.pageNumber).toBe(520)       expect(nattoTableWrapper.vm.itemsTotal).toBe(5201)       expect(nattoTableWrapper.vm.paginated).toBe(true)       expect(nattoTableWrapper.vm.loading).toBe(false)       expect(nattoTableWrapper.vm.rowClassName).toBe(         wrapper.vm.trashDocumentRowClass       )        describe('tests disabled row', () => {         const cases = [           { isInPendingList: true, expectedClass: 'row--disabled' },           { isInPendingList: false, expectedClass: '' }         ]          it.each(cases)(           'should disabled the row if the trashDocument is in restoration',           ({ isInPendingList, expectedClass }) => {             wrapper = createWrapper(               defaultProps,               createTrashStoreMock({ isInPendingList })             )              nattoTableWrapper = findNattoTable(wrapper)              if (!nattoTableWrapper.vm.rowClassName) {               return             }              expect(               nattoTableWrapper.vm.rowClassName({                 row: { id: 4545 },                 rowIndex: 45688               })             ).toBe(expectedClass)           }         )       })     })     describe('events', () => {       it('should emit page-opened when NattoTable emits page-opened', async () => {         const nattoTableWrapper: NattoTableWrapper =           wrapper.findComponent(NattoTable)          await nattoTableWrapper.vm.$emit('page-opened', 2)          expect(wrapper.emitted('page-opened')).toHaveLength(1)         expect(wrapper.emitted('page-opened')).toEqual([[2]])       })        it('should open confirmation modal when restore-clicked is emited', async () => {         const trashDocumentsActionsElementWrapper = wrapper.findComponent(           TrashDocumentsActionsElement         )          await trashDocumentsActionsElementWrapper.vm.$emit(           'restore-clicked',           '81180f6a-7ae3-441c-b3d1-3e85ff1732fd'         )         const restoreFileModalConfirmationWrapper: RestoreFileModalConfirmationWrapper =           wrapper.findComponent(RestoreFileModalConfirmation)          expect(trackEventFactory).toBeCalledWith('tdv-menu-restore')         expect(restoreFileModalConfirmationWrapper.vm.documentId).toBe(           '81180f6a-7ae3-441c-b3d1-3e85ff1732fd'         )         expect(restoreFileModalConfirmationWrapper.vm.modelValue).toBe(true)       })        it('should open confirmation modal when restore-icon-click is emited', async () => {         const TrashDocumentRestoreWrapper =           wrapper.findComponent(TrashDocumentRestore)          await TrashDocumentRestoreWrapper.vm.$emit('restore-icon-click', '1122')         const restoreFileModalConfirmationWrapper: RestoreFileModalConfirmationWrapper =           wrapper.findComponent(RestoreFileModalConfirmation)          expect(trackEventFactory).toBeCalledWith('tdv-tab-restore')         expect(restoreFileModalConfirmationWrapper.vm.documentId).toBe('1122')         expect(restoreFileModalConfirmationWrapper.vm.modelValue).toBe(true)       })        it('should emit restore-document when restore-confirm is emited', async () => {         const restoreFileModalConfirmationWrapper: RestoreFileModalConfirmationWrapper =           wrapper.findComponent(RestoreFileModalConfirmation)          await restoreFileModalConfirmationWrapper.vm.$emit(           'restore-confirm',           '1122'         )          expect(wrapper.emitted('restore-document')).toHaveLength(1)         expect(wrapper.emitted('restore-document')).toEqual([['1122']])       })     })   }) }) "
"<template>   <natto-tag :closable=""closable"">     {{ text }}   </natto-tag> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoTag from '@/Common/components/Tags/NattoTag.vue'  export default defineComponent({   name: 'TrashDocumentsTag',   components: {     NattoTag   },    props: {     text: String,     closable: Boolean   } }) </script>","describe('TrashDocumentsTag', () => {   beforeEach(() => {     wrapper = createWrapper('some text', 'color', false)   })   describe('binding', () => {     describe('props', () => {       it('Should bind text prop correctly', () => {         const nattoTagWrapper = findNattoTagWrapper(wrapper)          expect(nattoTagWrapper.text()).toContain('some text')       })       it('Should bind closable prop correctly', () => {         const nattoTagWrapper = findNattoTagWrapper(wrapper)          expect(nattoTagWrapper.props('closable')).toEqual(           wrapper.props('closable')         )       })     })   }) }) "
"<template>   <documents-table-element width=""3%"">     <template #item=""{ props }"">       <div         :class=""           props.restorationStatus === inProgressConst             ? 'restore-icon-disabled'             : 'restore-icon'         ""         @click=""$emit('restore-icon-click', props.id)""       >         <restore-icon />       </div>     </template>     <template #header> </template>   </documents-table-element> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DocumentsTableElement from '@/modules/Search/components/DocumentsTable/DocumentsTableElements/DocumentsTableElement.vue' import RestoreIcon from '@/Common/components/Icons/RestoreIcon.vue' import constants from '@/Common/constants'  export default defineComponent({   name: 'TrashDocumentRestore',   emits: ['restore-icon-click'],   components: {     DocumentsTableElement,     RestoreIcon   },    setup() {     return {       inProgressConst: constants.RESTORE_IN_PROGRESS     }   } }) </script>","describe('TrashDocumentRestore', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('events', () => {       it('Should fire restore-icon-click when restore icon is clicked', async () => {         const restoreIconWrapper = wrapper.find('.restore-icon')          await restoreIconWrapper.trigger('click')          expect(wrapper.emitted('restore-icon-click')).toBeTruthy()         expect(wrapper.emitted('restore-icon-click')).toHaveLength(1)         expect(wrapper.emitted('restore-icon-click')).toStrictEqual([[45]])       })     })   }) }) "
"<template>   <natto-card class=""trash-card"">     <div class=""trash-card-container"">       <div class=""trash-card-header"">         <trash-card-title :title=""$tc('ged.trash.arboCard.title')"" />       </div>       <div class=""arbo-card-content two-rows"">         <div class=""trash-description"">           <arbo-description             :description=""$tc('ged.trash.arboCard.description')""           />         </div>         <div class=""trash-shortcut"">           <trash-shortcut />         </div>       </div>     </div>   </natto-card> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import ArboDescription from '@/modules/Search/components/Cards/ArboDescription.vue' import TrashCardTitle from '@/modules/Trash/components/Cards/TrashCardTitle.vue' import NattoCard from '@/Common/components/Cards/NattoCard.vue' import TrashShortcut from '@/modules/Trash/components/Shortcuts/TrashShortcut.vue'  export default defineComponent({   name: 'TrashCard',    components: {     TrashShortcut,     NattoCard,     TrashCardTitle,     ArboDescription   } }) </script>","describe('TrashCard', () => {   beforeEach(() => {     wrapper = createWrapper()     trashCardTitleWrapper = findArboCardTitle(wrapper)   })   describe('binding', () => {     describe('props', () => {       it('Should bind headerTitle correctly ', () => {         expect(trashCardTitleWrapper.props('title')).toStrictEqual(           'ged.trash.arboCard.title'         )       })       describe('binding with arbo description', () => {         it('Should pass correct value to child component', () => {           const ArboDescriptionWrapper = wrapper.findComponent(ArboDescription)            expect(ArboDescriptionWrapper.props('description')).toBe(             'ged.trash.arboCard.description'           )         })       })       describe('trashShortcut', () => { })     })   }) }) "
"<template>   <div class=""trash-card__title"">     <delete-icon class=""trash-card__title--icon"" />     <span class=""trash-card__title--text"">       {{ title }}     </span>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import DeleteIcon from '@/Common/components/Icons/DeleteIcon.vue'  export default defineComponent({   name: 'TrashCardTitle',   components: { DeleteIcon },   props: {     title: {       type: String,       required: true     }   } }) </script>","describe('TrashCardTitle', () => {   beforeEach(() => {     wrapper = createWrapper()   })    describe('rendering', () => {     it('should render the title', () => {       wrapper = createWrapper({ title: 'test' })        expect(wrapper.text()).toContain('test')     })   }) }) "
"<template>   <section class=""folder-actions-dropdown__list"">     <document-action-dropdown-item       v-for=""{ id, label, icon, action } in documentActions""       :key=""id""       :label=""label""       :icon=""icon""       @click=""handleClickItem(action)""     />   </section> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import DocumentActionDropdownItem from '@/modules/Search/components/DocumentsTable/DocumentsTableItems/DocumentActionDropdownItem.vue' import { ITEMS } from '@/Common/types/actionItemTypes'  export default defineComponent({   name: 'TrashDocumentsActionsDropdownList',   components: { DocumentActionDropdownItem },   props: {     documentId: {       type: String,       required: true     }   },   emits: ['item-clicked'],   setup(props, { emit }) {     const documentActions = computed(() => [       {         id: props.documentId,         action: ITEMS.RESTORE,         label: 'Restaurer',         icon: 'refresh-left'       }     ])      return {       documentActions,       handleClickItem: (action: string) => {         emit('item-clicked', action, props.documentId)       }     }   } }) </script>","describe('DocumentActionsDropdownList', () => {   beforeEach(() => {     wrapper = createWrapper()   })   describe('binding', () => {     describe('events', () => {       it('Should fire item-clicked when item clicked', () => {         const dropdownItemWrapper = wrapper.findComponent(           DocumentActionDropdownItem         )          dropdownItemWrapper.trigger('click')          expect(wrapper.emitted('item-clicked')).toBeTruthy()       })     })   }) }) "
"<template>   <natto-dialog-popup     v-model=""isRestoreFileModalConfirmationOpened""     :title=""$t('ged.trash.restore.confirmation.title')""     :description=""$t('ged.trash.restore.confirmation.description')""     popup-type=""error""     @confirm-clicked=""handleConfirmClick""     @cancel-clicked=""handleCancelClick""   /> </template>  <script lang=""ts""> import { defineComponent, ref } from 'vue' import NattoDialogPopup from '@/Common/components/Modals/NattoDialogPopup.vue' import useVModel from '@/Common/hooks'  export default defineComponent({   name: 'RestoreFileModalConfirmation',   components: { NattoDialogPopup },   props: {     modelValue: {       type: Boolean,       required: true     },     documentId: {       type: String,       required: true     }   },   emits: ['restore-confirm'],   setup(props, { emit }) {     const isRestoreFileModalConfirmationOpened = useVModel(props)     const errorMessage = ref('')      const handleConfirmClick = () => {       emit('restore-confirm', props.documentId)       isRestoreFileModalConfirmationOpened.value = false     }      const handleCancelClick = () => {       isRestoreFileModalConfirmationOpened.value = false       errorMessage.value = ''     }      return {       isRestoreFileModalConfirmationOpened,       handleCancelClick,       errorMessage,       handleConfirmClick     }   } }) </script>","describe('RestoreFileModalConfirmation', () => {   beforeEach(() => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()   })    describe('bindings with NattoDialogPopup', () => {     test('props bindings', () => {       const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)        expect(nattoDialogPopupWrapper.props('modelValue')).toBe(true)       expect(nattoDialogPopupWrapper.props('title')).toBe(         'ged.trash.restore.confirmation.title'       )       expect(nattoDialogPopupWrapper.props('popupType')).toBe('error')       expect(nattoDialogPopupWrapper.props('description')).toBe(         'ged.trash.restore.confirmation.description'       )     })     describe('events bindings', () => {       it('should dispatch restoreFileByModal with documentId when NattoDialogPopup emit confirm-clicked and close the modal', async () => {         // When NattoDialogPopup emit confirm-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('confirm-clicked')         await wrapper.vm.$nextTick()          //expect(trackEventFactory).toBeCalledWith('adv-delete-file')         // Then         // expect(storeMock.dispatch).toHaveBeenCalledWith(         //   'GED/Trash/restoreFileByModal',         //   '4521'         // )         expect(wrapper.emitted('restore-confirm')).toHaveLength(1)         expect(wrapper.emitted('restore-confirm')).toEqual([['4521']])         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toEqual([[false]])       })       it('should close the modal when cancel button is clicked', async () => {         // When NattoDialogPopup emit cancel-clicked         const nattoDialogPopupWrapper = findNattoDialogPopupWrapper(wrapper)          await nattoDialogPopupWrapper.vm.$emit('cancel-clicked')          // Then the modal must be closed         expect(wrapper.emitted('update:modelValue')).toHaveLength(1)         expect(wrapper.emitted('update:modelValue')).toStrictEqual([[false]])       })     })   }) }) "
"<template>   <in-progress-popup     v-if=""displayInProgress""     :running=""totalPending""     @cancelRestore=""cancelRestoreHandler""   />   <success-popup     v-else-if=""displaySuccess""     :successed=""1""     :fileName=""restoredDocument.name""     @close=""handleClosePopup""     @redirect-to-location=""handleRedirection""   />   <failed-popup v-if=""displayFailed"" @close=""handleClosePopup"" /> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import { useStore } from 'vuex'  import { trackEventFactory } from '@/Common/helpers/analyticsLog' import constants from '@/Common/constants' import analyticsCode from '@/Common/constants/analyticsCode'  import TrashDocument from '@/modules/Trash/models/Inputs/TrashDocument' import TrashDocuments from '@/modules/Trash/models/Inputs/TrashDocuments' import SuccessPopup from '@/modules/Trash/components/Notification/Elements/SuccessPopup.vue' import FailedPopup from '@/modules/Trash/components/Notification/Elements/FailedPopup.vue' import InProgressPopup from '@/modules/Trash/components/Notification/Elements/InProgressPopup.vue' import useTrashModule from '@/modules/Trash/store/helpers'  export default defineComponent({   name: 'TrashViewRestorePopup',    emits: ['close', 'redirect-to-location', 'cancelRestore'],    props: {     duration: Number,     pending: Boolean,     success: Boolean,     failed: Boolean,     documents: {       type: TrashDocuments,       required: true     },     restoredDocument: TrashDocument   },    components: {     SuccessPopup,     FailedPopup,     InProgressPopup   },    setup(props, { emit }) {     const store = useStore()      const { totalPendingRestoration } = useTrashModule(store)      setTimeout(() => {       emit('close')     }, props.duration)      const handleRedirection = () => {       trackEventFactory(analyticsCode['tdv-notification-restore-cta'])       emit('redirect-to-location')     }      return {       totalPending: computed(         () =>           props.documents.collection.filter(             (doc) => doc.restorationStatus === constants.RESTORE_IN_PROGRESS           ).length       ),       displayInProgress: computed(() => !props.success && props.pending),       displaySuccess: props.success,       displayFailed: computed(() => props.failed),       cancelRestoreHandler: () => emit('cancelRestore'),       handleClosePopup: () => emit('close'),       handleRedirection,       totalPendingRestoration: totalPendingRestoration()     }   } }) </script>","describe('TrashViewRestorePopup', () => {   beforeEach(async () => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('binding', () => {     describe('props', () => {       const cases = [         { prop: 'duration', expected: 5000 },         { prop: 'pending', expected: true },         { prop: 'success', expected: false },         { prop: 'failed', expected: false },         { prop: 'documents', expected: documentsData },         { prop: 'restoredDocument', expected: documentsData.collection[0] }       ]        test.each(cases)(         'Should bind component props correctly',         ({ prop, expected }) => {           expect(wrapper.props(prop)).toEqual(expected)         }       )     })     describe('components', () => {       describe('SuccessPopup', () => {         describe('binding', () => {           beforeEach(async () => {             wrapper = createWrapper(storeMock, {               duration: 5000,               pending: false,               success: true,               failed: false,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })           describe('props', () => {             it('Should bind successed prop correctly correctly', () => {               const successPopupWrapper = wrapper.findComponent(SuccessPopup)                expect(successPopupWrapper.props('fileName')).toEqual(                 wrapper.vm.restoredDocument.name               )             })           })           describe('events', () => {             it('Should emit close event', async () => {               const successPopupWrapper = wrapper.findComponent(SuccessPopup)                await successPopupWrapper.vm.$emit('close')                expect(wrapper.emitted('close')).toBeTruthy()             })             it('Should emit redirect-to-location event', async () => {               const successPopupWrapper = wrapper.findComponent(SuccessPopup)                await successPopupWrapper.vm.$emit('redirect-to-location')                expect(trackEventFactory).toBeCalledWith(                 'tdv-notification-restore-cta'               )                expect(wrapper.emitted('redirect-to-location')).toBeTruthy()             })           })         })         describe('rendering', () => {           beforeEach(() => {             wrapper = createWrapper(storeMock, {               duration: 5000,               pending: false,               success: true,               failed: false,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })           it('Should display success popup when success is true', () => {             const successPopupWrapper = wrapper.findComponent(SuccessPopup)              expect(successPopupWrapper.exists()).toBeTruthy()           })         })       })       describe('FailedPopup', () => {         describe('binding', () => {           beforeEach(async () => {             wrapper = createWrapper(storeMock, {               duration: 5000,               pending: false,               success: false,               failed: true,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })            describe('events', () => {             it('Should emit close event', async () => {               const FailedPopupWrapper = wrapper.findComponent(FailedPopup)                await FailedPopupWrapper.vm.$emit('close')                expect(wrapper.emitted('close')).toBeTruthy()             })           })         })         describe('rendering', () => {           beforeEach(() => {             wrapper = createWrapper(storeMock, {               duration: 5000,               pending: false,               success: false,               failed: true,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })           it('Should display failed popup when failed is true', () => {             const FailedPopupWrapper = wrapper.findComponent(FailedPopup)              expect(FailedPopupWrapper.exists()).toBeTruthy()           })         })       })       describe('InProgressPopup', () => {         describe('binding', () => {           const DOCUMENTS_IN_RESTORATION_COUNT = 4            beforeEach(async () => {             for (let i = 0; i < DOCUMENTS_IN_RESTORATION_COUNT; i++) {               documentsData.collection[i].restorationStatus =                 constants.RESTORE_IN_PROGRESS             }              wrapper = createWrapper(storeMock, {               duration: 5000,               pending: true,               success: false,               failed: false,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })           describe('props', () => {             it('Should bind running prop correctly', () => {               const InProgressPopupWrapper =                 wrapper.findComponent(InProgressPopup)                expect(InProgressPopupWrapper.props('running')).toEqual(                 DOCUMENTS_IN_RESTORATION_COUNT               )             })           })           describe('events', () => {             it('Should emit cancel event', async () => {               const InProgressPopupWrapper =                 wrapper.findComponent(InProgressPopup)                await InProgressPopupWrapper.vm.$emit('cancelRestore')                expect(wrapper.emitted('cancelRestore')).toBeTruthy()             })           })         })         describe('rendering', () => {           beforeEach(() => {             wrapper = createWrapper(storeMock, {               duration: 5000,               pending: true,               success: false,               failed: false,               documents: documentsData,               restoredDocument: documentsData.collection[0]             })             storeMock.dispatch = jest.fn()           })           it('Should display inprogress popup when pending is true', () => {             const InProgressPopupWrapper =               wrapper.findComponent(InProgressPopup)              expect(InProgressPopupWrapper.exists()).toBeTruthy()           })         })       })     })   }) }) "
"<template>   <div class=""restore-success-container"">     <div class=""icon-zone""><i class=""mp-icon-check""></i></div>     <div class=""main-content-zone"">       <p class=""description"">         {{ successText }}       </p>       <p class=""sub-description"">{{ fileName }}</p>     </div>     <div class=""actions-zone"">       <mp-button         v-if=""successed == 1""         class=""go-to-destination-cta""         size=""small""         btn-type=""primary""         @click=""redirectToLocation""       >         {{ goToBtn }}       </mp-button>       <i v-else class=""mp-icon-close""></i>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent, computed } from 'vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'SuccessPopup',   emits: ['redirect-to-location'],   props: {     successed: { type: Number, required: true },     fileName: String   },   setup(props, { emit }) {     const { t } = useTranslation()      const successText = computed(() =>       t('ged.trash.restore.successPopup.restored')     )      const goToBtn = computed(() => t('ged.trash.restore.successPopup.goToBtn'))      return {       successText,       goToBtn,       redirectToLocation: () => emit('redirect-to-location')     }   } }) </script>","describe('SuccessPopup', () => {   beforeEach(() => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('binding', () => {     describe('props', () => {       const cases = [         { prop: 'successed', expected: 1 },         { prop: 'fileName', expected: 'file_test.txt' }       ]        test.each(cases)(         'Should bind component props correctly',         ({ prop, expected }) => {           expect(wrapper.props(prop)).toEqual(expected)         }       )     })     describe('events', () => {       it('Should trigger redirect-to-location event ', async () => {         const btn = wrapper.find('.go-to-destination-cta')          await btn.trigger('click')         expect(wrapper.emitted('redirect-to-location')).toBeTruthy()       })     })   }) }) "
"<template>   <div class=""restore-failed-container"">     <div class=""icon-zone""><warning-icon /></div>     <div class=""main-content-zone"">       <p class=""description"">{{ FailedMessageTitle }}</p>       <p class=""sub-description"">         {{ FailedMessage }}       </p>     </div>     <div class=""actions-zone"">       <i class=""el-icon-circle-close close-icon"" @click=""closeHandler""></i>     </div>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import WarningIcon from '@/Common/components/Icons/WarningIcon.vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'FailedPopup',   components: {     WarningIcon   },   props: {     canceled: Number,     errored: Number   },   setup(props, { emit }) {     const { tc } = useTranslation()      const FailedMessage = tc('ged.trash.restore.failedPopup.content')      const FailedMessageTitle = tc('ged.trash.restore.failedPopup.title')      return {       FailedMessage,       FailedMessageTitle,       closeHandler: () => emit('close')     }   } }) </script>","describe('FailedPopup', () => {   beforeEach(async () => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('binding', () => {     describe('props', () => {       const cases = [         { prop: 'canceled', expected: 0 },         { prop: 'errored', expected: 2 }       ]        test.each(cases)(         'Should bind component props correctly',         ({ prop, expected }) => {           expect(wrapper.props(prop)).toEqual(expected)         }       )     })     describe('events', () => {       it('Should trigger close event ', async () => {         const btn = wrapper.find('.close-icon')          await btn.trigger('click')         expect(wrapper.emitted('close')).toBeTruthy()       })     })   }) }) "
"<template>   <div class=""in-progress-restore-container"">     <div class=""icon-zone""><restore-icon-blue /></div>     <div class=""main-content-zone"">       <p class=""description"">         <span class=""primary"">{{ running }}</span>         {{ inProgressText }}       </p>     </div>   </div> </template>  <script lang=""ts""> import { computed, defineComponent } from 'vue' import RestoreIconBlue from '@/Common/components/Icons/RestoreIconBlue.vue' import { useTranslation } from '@/Common/hooks/useTranslation'  export default defineComponent({   name: 'InProgressPopup',   emits: ['cancelRestore'],   components: {     RestoreIconBlue   },   props: {     total: Number,     running: Number   },    setup(props, { emit }) {     const { tc } = useTranslation()      const inProgressText = computed(() =>       tc('ged.trash.restore.inProgressPopup.content', props.running, {         count: props.running       })     )      return {       cancelHandler: () => emit('cancelRestore'),       inProgressText     }   } }) </script>","describe('InProgressPopupPopup', () => {   beforeEach(async () => {     wrapper = createWrapper()     storeMock.dispatch = jest.fn()     tMock = jest.fn()     tcMock = jest.fn()     jest.spyOn(translationHelper, 'useTranslation').mockReturnValue({       t: tMock,       tc: tcMock     })   })   describe('binding', () => {     describe('props', () => {       const cases = [         { prop: 'total', expected: 1 },         { prop: 'running', expected: 1 }       ]        test.each(cases)(         'Should bind component props correctly',         ({ prop, expected }) => {           expect(wrapper.props(prop)).toEqual(expected)         }       )     })   }) }) "
"<template>   <div class=""trash-view-header"">     <trash-header-back-button @click=""handleGoBackClick"" />      <div class=""header-content"">       <div class=""header-title"">         <h1>           {{ $t('ged.trash.title') }}           <span class=""description"">             {{ $t('ged.trash.recentDelete') }}           </span>         </h1>       </div>     </div>     <div class=""spacer"" />     <!-- <div class=""header-icon"">       <div class=""info-icon-container"">         <trash-view-info-btn @click=""$emit('info-btn-click')"" />         <documents-archive-btn           icon=""delete""           :buttoninnerText=""$t('ged.trash.archiveAll')""           @click=""$emit('archive-btn-click')""         />       </div>     </div> -->   </div>   <div class=""header-tag"">     <!-- <trash-documents-tag       :text=""$t('ged.trash.archiveIn60Days')""       color=""#FCE4E9""     /> -->   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import TrashHeaderBackButton from '@/modules/Trash/components/Header/TrashHeaderBackButton.vue' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import useSearchNavigator from '@/modules/Search/navigator/useSearchNavigator'  export default defineComponent({   name: 'TrashViewHeader',   emits: ['info-btn-click', 'archive-btn-click'],   components: {     TrashHeaderBackButton   },    setup() {     const { goToMainView } = useSearchNavigator()      const handleGoBackClick = () => {       trackEventFactory(analyticsCode['tdv-goback'])       goToMainView()     }      return {       handleGoBackClick     }   } }) </script>","describe('TrashViewHeader', () => {   beforeEach(() => {     wrapper = createWrapper()     routerMock.push = jest.fn()   })   describe('binding', () => {     describe('events', () => {       it('Should emit trash-back-click when back button is clicked ', async () => {         const TrashHeaderBackButtonWrapper = wrapper.findComponent(           TrashHeaderBackButton         )          await TrashHeaderBackButtonWrapper.vm.$emit('click')         await wrapper.vm.$nextTick()         expect(routerMock.push).toHaveBeenCalledWith({           name: 'MainView'         })       })     })   }) }) "
"<template>   <div class=""documents-archive-btn"">     <mp-button size=""small"">       <div class=""btn-text"">{{ buttoninnerText }}</div>        <div class=""btn-icon"">         <natto-icon :elementName=""icon"" />       </div>     </mp-button>   </div> </template>  <script lang=""ts""> import { defineComponent } from 'vue' import NattoIcon from '@/Common/components/Icons/NattoIcon.vue'  export default defineComponent({   name: 'DocumentsArchiveBtn',   components: { NattoIcon },   props: {     icon: {       type: String,       default: 'delete'     },     buttoninnerText: {       type: String     }   } }) </script>","describe('DocumentsArchiveBtn', () => {   beforeEach(() => {     wrapper = createWrapper('delete', 'Tout Archiver')   })   describe('binding', () => {     it('Should bind buttoninnerText prop correctly', () => {       const btnText = findDomElement(wrapper, '.btn-text')        expect(btnText.text()).toEqual('Tout Archiver')     })     it('Should bind icon prop correctly', () => {       const NattoIconWrapper = wrapper.findComponent(NattoIcon)        expect(NattoIconWrapper.props('elementName')).toEqual(         wrapper.props('icon')       )     })   }) }) "
"<template>   <natto-shortcut-card     type=""danger""     class=""trash-shortcut""     :loading=""totalLoading""     :text=""       $tc('ged.documents', trashDocumentsCount, { count: trashDocumentsCount })     ""     prepend-icon=""file""     @click=""handleClick""   /> </template>  <script lang=""ts""> import { defineComponent, onBeforeMount } from 'vue' import NattoShortcutCard from '@/Common/components/Cards/NattoShortcutCard.vue' import { useStore } from 'vuex' import useTrashModule from '@/modules/Trash/store/helpers' import { trackEventFactory } from '@/Common/helpers/analyticsLog' import analyticsCode from '@/Common/constants/analyticsCode' import useTrashNavigator from '@/modules/Trash/navigator/useTrashNavigator'  export default defineComponent({   name: 'TrashShortcut',   components: { NattoShortcutCard },    setup() {     const store = useStore()      const { goToTrashView } = useTrashNavigator()      const handleClick = () => {       trackEventFactory(analyticsCode['mdv-cta-trash-explore-click'])       goToTrashView()     }      const { documentsTotalCount, fetchTrashDocumentsTotalCount, totalLoading } =       useTrashModule(store)      onBeforeMount(async () => {       await fetchTrashDocumentsTotalCount()     })      return {       trashDocumentsCount: documentsTotalCount(),       totalLoading: totalLoading(),       handleClick     }   } }) </script>","describe('TrashShortcut', () => {   beforeEach(async () => {     wrapper = createWrapper()     nattoShortcutCardWrapper = findNattoShortcutCard(wrapper)     routerMock.push = jest.fn()     storeMock.dispatch = jest.fn()   })   describe('binding with NattoShortcutCard', () => {     it('props bindings', () => {       expect(nattoShortcutCardWrapper.props('prependIcon')).toBe('file')       expect(nattoShortcutCardWrapper.props('text')).toBe(         'ged.documents with 1905'       )       expect(nattoShortcutCardWrapper.props('type')).toBe('danger')     })     describe('events', () => {       it('Should go to trash view when shortcut card emit click', async () => {         await nattoShortcutCardWrapper.vm.$emit('click')          expect(routerMock.push).toHaveBeenCalledWith({ name: 'TrashView' })       })       it('Should dispatch fetchTrashDocumentsTotalCount onBeforeMount', async () => {         wrapper = createWrapper()          expect(storeMock.dispatch).toHaveBeenCalledWith(           'GED/Trash/fetchTrashDocumentsTotalCount'         )       })     })   }) }) "
